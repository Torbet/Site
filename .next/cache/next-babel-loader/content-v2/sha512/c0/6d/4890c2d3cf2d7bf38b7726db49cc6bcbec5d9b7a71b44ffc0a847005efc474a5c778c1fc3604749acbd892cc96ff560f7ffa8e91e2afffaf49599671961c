{"ast":null,"code":"\"use strict\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nexports.__esModule = true;\nexports.matchHas = matchHas;\nexports.compileNonPath = compileNonPath;\nexports.default = prepareDestination;\nexports.getSafeParamName = void 0;\n\nvar _querystring = require(\"./querystring\");\n\nvar _parseRelativeUrl = require(\"./parse-relative-url\");\n\nvar pathToRegexp = _interopRequireWildcard(require(\"next/dist/compiled/path-to-regexp\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n} // ensure only a-zA-Z are used for param names for proper interpolating\n// with path-to-regexp\n\n\nconst getSafeParamName = paramName => {\n  let newParamName = '';\n\n  for (let i = 0; i < paramName.length; i++) {\n    const charCode = paramName.charCodeAt(i);\n\n    if (charCode > 64 && charCode < 91 || // A-Z\n    charCode > 96 && charCode < 123 // a-z\n    ) {\n        newParamName += paramName[i];\n      }\n  }\n\n  return newParamName;\n};\n\nexports.getSafeParamName = getSafeParamName;\n\nfunction matchHas(req, has, query) {\n  const params = {};\n  const allMatch = has.every(hasItem => {\n    let value;\n    let key = hasItem.key;\n\n    switch (hasItem.type) {\n      case 'header':\n        {\n          key = key.toLowerCase();\n          value = req.headers[key];\n          break;\n        }\n\n      case 'cookie':\n        {\n          value = req.cookies[hasItem.key];\n          break;\n        }\n\n      case 'query':\n        {\n          value = query[key];\n          break;\n        }\n\n      case 'host':\n        {\n          const {\n            host\n          } = (req == null ? void 0 : req.headers) || {}; // remove port from host if present\n\n          const hostname = host == null ? void 0 : host.split(':')[0].toLowerCase();\n          value = hostname;\n          break;\n        }\n\n      default:\n        {\n          break;\n        }\n    }\n\n    if (!hasItem.value && value) {\n      params[getSafeParamName(key)] = value;\n      return true;\n    } else if (value) {\n      const matcher = new RegExp(`^${hasItem.value}$`);\n      const matches = value.match(matcher);\n\n      if (matches) {\n        if (matches.groups) {\n          Object.keys(matches.groups).forEach(groupKey => {\n            const safeKey = getSafeParamName(groupKey);\n\n            if (safeKey && matches.groups[groupKey]) {\n              params[safeKey] = matches.groups[groupKey];\n            }\n          });\n        } else {\n          params[getSafeParamName(key || 'host')] = matches[0];\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  });\n\n  if (allMatch) {\n    return params;\n  }\n\n  return false;\n}\n\nfunction compileNonPath(value, params) {\n  if (!value.includes(':')) {\n    return value;\n  }\n\n  for (const key of Object.keys(params)) {\n    if (value.includes(`:${key}`)) {\n      value = value.replace(new RegExp(`:${key}\\\\*`, 'g'), `:${key}--ESCAPED_PARAM_ASTERISKS`).replace(new RegExp(`:${key}\\\\?`, 'g'), `:${key}--ESCAPED_PARAM_QUESTION`).replace(new RegExp(`:${key}\\\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`).replace(new RegExp(`:${key}(?!\\\\w)`, 'g'), `--ESCAPED_PARAM_COLON${key}`);\n    }\n  }\n\n  value = value.replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*'); // the value needs to start with a forward-slash to be compiled\n  // correctly\n\n  return pathToRegexp.compile(`/${value}`, {\n    validate: false\n  })(params).substr(1);\n}\n\nfunction prepareDestination(destination, params, query, appendParamsToQuery) {\n  let parsedDestination = {}; // clone query so we don't modify the original\n\n  query = Object.assign({}, query);\n  const hadLocale = query.__nextLocale;\n  delete query.__nextLocale;\n  delete query.__nextDefaultLocale;\n\n  if (destination.startsWith('/')) {\n    parsedDestination = (0, _parseRelativeUrl.parseRelativeUrl)(destination);\n  } else {\n    const {\n      pathname,\n      searchParams,\n      hash,\n      hostname,\n      port,\n      protocol,\n      search,\n      href\n    } = new URL(destination);\n    parsedDestination = {\n      pathname,\n      query: (0, _querystring.searchParamsToUrlQuery)(searchParams),\n      hash,\n      protocol,\n      hostname,\n      port,\n      search,\n      href\n    };\n  }\n\n  const destQuery = parsedDestination.query;\n  const destPath = `${parsedDestination.pathname}${parsedDestination.hash || ''}`;\n  const destPathParamKeys = [];\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys);\n  const destPathParams = destPathParamKeys.map(key => key.name);\n  let destinationCompiler = pathToRegexp.compile(destPath, // we don't validate while compiling the destination since we should\n  // have already validated before we got to this point and validating\n  // breaks compiling destinations with named pattern params from the source\n  // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n  // since compile validation is meant for reversing and not for inserting\n  // params from a separate path-regex into another\n  {\n    validate: false\n  });\n  let newUrl; // update any params in query values\n\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray;\n\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = compileNonPath(value, params);\n    }\n\n    destQuery[key] = value;\n  } // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n\n\n  let paramKeys = Object.keys(params); // remove internal param for i18n\n\n  if (hadLocale) {\n    paramKeys = paramKeys.filter(name => name !== 'nextInternalLocale');\n  }\n\n  if (appendParamsToQuery && !paramKeys.some(key => destPathParams.includes(key))) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = params[key];\n      }\n    }\n  }\n\n  try {\n    newUrl = destinationCompiler(params);\n    const [pathname, hash] = newUrl.split('#');\n    parsedDestination.pathname = pathname;\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`;\n    delete parsedDestination.search;\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(`To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`);\n    }\n\n    throw err;\n  } // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n\n\n  parsedDestination.query = _objectSpread(_objectSpread({}, query), parsedDestination.query);\n  return {\n    newUrl,\n    parsedDestination\n  };\n}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/prepare-destination.ts"],"names":["getSafeParamName","paramName","newParamName","i","charCode","params","allMatch","has","hasItem","key","value","req","query","hostname","host","matcher","matches","Object","groupKey","safeKey","pathToRegexp","validate","parsedDestination","hadLocale","destination","destQuery","destPath","pathname","destPathParamKeys","destPathParams","destinationCompiler","Array","strOrArray","compileNonPath","paramKeys","name","appendParamsToQuery","newUrl","hash","err"],"mappings":"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","sourcesContent":["import { IncomingMessage } from 'http'\nimport { ParsedUrlQuery } from 'querystring'\nimport { searchParamsToUrlQuery } from './querystring'\nimport { parseRelativeUrl } from './parse-relative-url'\nimport * as pathToRegexp from 'next/dist/compiled/path-to-regexp'\nimport { RouteHas } from '../../../../lib/load-custom-routes'\n\ntype Params = { [param: string]: any }\n\n// ensure only a-zA-Z are used for param names for proper interpolating\n// with path-to-regexp\nexport const getSafeParamName = (paramName: string) => {\n  let newParamName = ''\n\n  for (let i = 0; i < paramName.length; i++) {\n    const charCode = paramName.charCodeAt(i)\n\n    if (\n      (charCode > 64 && charCode < 91) || // A-Z\n      (charCode > 96 && charCode < 123) // a-z\n    ) {\n      newParamName += paramName[i]\n    }\n  }\n  return newParamName\n}\n\nexport function matchHas(\n  req: IncomingMessage,\n  has: RouteHas[],\n  query: Params\n): false | Params {\n  const params: Params = {}\n  const allMatch = has.every((hasItem) => {\n    let value: undefined | string\n    let key = hasItem.key\n\n    switch (hasItem.type) {\n      case 'header': {\n        key = key!.toLowerCase()\n        value = req.headers[key] as string\n        break\n      }\n      case 'cookie': {\n        value = (req as any).cookies[hasItem.key]\n        break\n      }\n      case 'query': {\n        value = query[key!]\n        break\n      }\n      case 'host': {\n        const { host } = req?.headers || {}\n        // remove port from host if present\n        const hostname = host?.split(':')[0].toLowerCase()\n        value = hostname\n        break\n      }\n      default: {\n        break\n      }\n    }\n\n    if (!hasItem.value && value) {\n      params[getSafeParamName(key!)] = value\n      return true\n    } else if (value) {\n      const matcher = new RegExp(`^${hasItem.value}$`)\n      const matches = value.match(matcher)\n\n      if (matches) {\n        if (matches.groups) {\n          Object.keys(matches.groups).forEach((groupKey) => {\n            const safeKey = getSafeParamName(groupKey)\n\n            if (safeKey && matches.groups![groupKey]) {\n              params[safeKey] = matches.groups![groupKey]\n            }\n          })\n        } else {\n          params[getSafeParamName(key || 'host')] = matches[0]\n        }\n        return true\n      }\n    }\n    return false\n  })\n\n  if (allMatch) {\n    return params\n  }\n  return false\n}\n\nexport function compileNonPath(value: string, params: Params): string {\n  if (!value.includes(':')) {\n    return value\n  }\n\n  for (const key of Object.keys(params)) {\n    if (value.includes(`:${key}`)) {\n      value = value\n        .replace(\n          new RegExp(`:${key}\\\\*`, 'g'),\n          `:${key}--ESCAPED_PARAM_ASTERISKS`\n        )\n        .replace(\n          new RegExp(`:${key}\\\\?`, 'g'),\n          `:${key}--ESCAPED_PARAM_QUESTION`\n        )\n        .replace(new RegExp(`:${key}\\\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`)\n        .replace(\n          new RegExp(`:${key}(?!\\\\w)`, 'g'),\n          `--ESCAPED_PARAM_COLON${key}`\n        )\n    }\n  }\n  value = value\n    .replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1')\n    .replace(/--ESCAPED_PARAM_PLUS/g, '+')\n    .replace(/--ESCAPED_PARAM_COLON/g, ':')\n    .replace(/--ESCAPED_PARAM_QUESTION/g, '?')\n    .replace(/--ESCAPED_PARAM_ASTERISKS/g, '*')\n\n  // the value needs to start with a forward-slash to be compiled\n  // correctly\n  return pathToRegexp\n    .compile(`/${value}`, { validate: false })(params)\n    .substr(1)\n}\n\nexport default function prepareDestination(\n  destination: string,\n  params: Params,\n  query: ParsedUrlQuery,\n  appendParamsToQuery: boolean\n) {\n  let parsedDestination: {\n    query?: ParsedUrlQuery\n    protocol?: string\n    hostname?: string\n    port?: string\n  } & ReturnType<typeof parseRelativeUrl> = {} as any\n\n  // clone query so we don't modify the original\n  query = Object.assign({}, query)\n  const hadLocale = query.__nextLocale\n  delete query.__nextLocale\n  delete query.__nextDefaultLocale\n\n  if (destination.startsWith('/')) {\n    parsedDestination = parseRelativeUrl(destination)\n  } else {\n    const {\n      pathname,\n      searchParams,\n      hash,\n      hostname,\n      port,\n      protocol,\n      search,\n      href,\n    } = new URL(destination)\n\n    parsedDestination = {\n      pathname,\n      query: searchParamsToUrlQuery(searchParams),\n      hash,\n      protocol,\n      hostname,\n      port,\n      search,\n      href,\n    }\n  }\n\n  const destQuery = parsedDestination.query\n  const destPath = `${parsedDestination.pathname!}${\n    parsedDestination.hash || ''\n  }`\n  const destPathParamKeys: pathToRegexp.Key[] = []\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys)\n\n  const destPathParams = destPathParamKeys.map((key) => key.name)\n\n  let destinationCompiler = pathToRegexp.compile(\n    destPath,\n    // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    { validate: false }\n  )\n  let newUrl\n\n  // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = compileNonPath(value, params)\n    }\n    destQuery[key] = value\n  }\n\n  // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n  let paramKeys = Object.keys(params)\n\n  // remove internal param for i18n\n  if (hadLocale) {\n    paramKeys = paramKeys.filter((name) => name !== 'nextInternalLocale')\n  }\n\n  if (\n    appendParamsToQuery &&\n    !paramKeys.some((key) => destPathParams.includes(key))\n  ) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = params[key]\n      }\n    }\n  }\n\n  try {\n    newUrl = destinationCompiler(params)\n\n    const [pathname, hash] = newUrl.split('#')\n    parsedDestination.pathname = pathname\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`\n    delete (parsedDestination as any).search\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(\n        `To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`\n      )\n    }\n    throw err\n  }\n\n  // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = {\n    ...query,\n    ...parsedDestination.query,\n  }\n\n  return {\n    newUrl,\n    parsedDestination,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}