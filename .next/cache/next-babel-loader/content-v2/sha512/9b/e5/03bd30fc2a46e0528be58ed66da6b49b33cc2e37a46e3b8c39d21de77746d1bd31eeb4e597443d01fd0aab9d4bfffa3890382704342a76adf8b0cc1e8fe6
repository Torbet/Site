{"ast":null,"code":"/*\n*   Stripe WebGl Gradient Animation\n*   All Credits to Stripe.com\n*   ScrollObserver functionality to disable animation when not scrolled into view has been disabled and \n*   commented out for now.\n*   https://kevinhufnagl.com\n*/\n//Converting colors to proper format\nfunction normalizeColor(hexCode) {\n  return [(hexCode >> 16 & 255) / 255, (hexCode >> 8 & 255) / 255, (255 & hexCode) / 255];\n}\n\n[\"SCREEN\", \"LINEAR_LIGHT\"].reduce((hexCode, t, n) => Object.assign(hexCode, {\n  [t]: n\n}), {}); //Essential functionality of WebGl\n//t = width\n//n = height\n\nclass MiniGl {\n  constructor(canvas, width, height, debug = false) {\n    const _miniGl = this,\n          debug_output = -1 !== document.location.search.toLowerCase().indexOf(\"debug=webgl\");\n\n    _miniGl.canvas = canvas, _miniGl.gl = _miniGl.canvas.getContext(\"webgl\", {\n      antialias: true\n    }), _miniGl.meshes = [];\n    const context = _miniGl.gl;\n    width && height && this.setSize(width, height), _miniGl.lastDebugMsg, _miniGl.debug = debug && debug_output ? function (e) {\n      const t = new Date();\n      t - _miniGl.lastDebugMsg > 1e3 && console.log(\"---\"), console.log(t.toLocaleTimeString() + Array(Math.max(0, 32 - e.length)).join(\" \") + e + \": \", ...Array.from(arguments).slice(1)), _miniGl.lastDebugMsg = t;\n    } : () => {}, Object.defineProperties(_miniGl, {\n      Material: {\n        enumerable: false,\n        value: class {\n          constructor(vertexShaders, fragments, uniforms = {}) {\n            const material = this;\n\n            function getShaderByType(type, source) {\n              const shader = context.createShader(type);\n              return context.shaderSource(shader, source), context.compileShader(shader), context.getShaderParameter(shader, context.COMPILE_STATUS) || console.error(context.getShaderInfoLog(shader)), _miniGl.debug(\"Material.compileShaderSource\", {\n                source: source\n              }), shader;\n            }\n\n            function getUniformVariableDeclarations(uniforms, type) {\n              return Object.entries(uniforms).map(([uniform, value]) => value.getDeclaration(uniform, type)).join(\"\\n\");\n            }\n\n            material.uniforms = uniforms, material.uniformInstances = [];\n            const prefix = \"\\n              precision highp float;\\n            \";\n            material.vertexSource = `\\n              ${prefix}\\n              attribute vec4 position;\\n              attribute vec2 uv;\\n              attribute vec2 uvNorm;\\n              ${getUniformVariableDeclarations(_miniGl.commonUniforms, \"vertex\")}\\n              ${getUniformVariableDeclarations(uniforms, \"vertex\")}\\n              ${vertexShaders}\\n            `, material.Source = `\\n              ${prefix}\\n              ${getUniformVariableDeclarations(_miniGl.commonUniforms, \"fragment\")}\\n              ${getUniformVariableDeclarations(uniforms, \"fragment\")}\\n              ${fragments}\\n            `, material.vertexShader = getShaderByType(context.VERTEX_SHADER, material.vertexSource), material.fragmentShader = getShaderByType(context.FRAGMENT_SHADER, material.Source), material.program = context.createProgram(), context.attachShader(material.program, material.vertexShader), context.attachShader(material.program, material.fragmentShader), context.linkProgram(material.program), context.getProgramParameter(material.program, context.LINK_STATUS) || console.error(context.getProgramInfoLog(material.program)), context.useProgram(material.program), material.attachUniforms(void 0, _miniGl.commonUniforms), material.attachUniforms(void 0, material.uniforms);\n          } //t = uniform\n\n\n          attachUniforms(name, uniforms) {\n            //n  = material\n            const material = this;\n            void 0 === name ? Object.entries(uniforms).forEach(([name, uniform]) => {\n              material.attachUniforms(name, uniform);\n            }) : \"array\" == uniforms.type ? uniforms.value.forEach((uniform, i) => material.attachUniforms(`${name}[${i}]`, uniform)) : \"struct\" == uniforms.type ? Object.entries(uniforms.value).forEach(([uniform, i]) => material.attachUniforms(`${name}.${uniform}`, i)) : (_miniGl.debug(\"Material.attachUniforms\", {\n              name: name,\n              uniform: uniforms\n            }), material.uniformInstances.push({\n              uniform: uniforms,\n              location: context.getUniformLocation(material.program, name)\n            }));\n          }\n\n        }\n      },\n      Uniform: {\n        enumerable: !1,\n        value: class {\n          constructor(e) {\n            this.type = \"float\", Object.assign(this, e);\n            this.typeFn = {\n              float: \"1f\",\n              int: \"1i\",\n              vec2: \"2fv\",\n              vec3: \"3fv\",\n              vec4: \"4fv\",\n              mat4: \"Matrix4fv\"\n            }[this.type] || \"1f\", this.update();\n          }\n\n          update(value) {\n            void 0 !== this.value && context[`uniform${this.typeFn}`](value, 0 === this.typeFn.indexOf(\"Matrix\") ? this.transpose : this.value, 0 === this.typeFn.indexOf(\"Matrix\") ? this.value : null);\n          } //e - name\n          //t - type\n          //n - length\n\n\n          getDeclaration(name, type, length) {\n            const uniform = this;\n\n            if (uniform.excludeFrom !== type) {\n              if (\"array\" === uniform.type) return uniform.value[0].getDeclaration(name, type, uniform.value.length) + `\\nconst int ${name}_length = ${uniform.value.length};`;\n\n              if (\"struct\" === uniform.type) {\n                let name_no_prefix = name.replace(\"u_\", \"\");\n                return name_no_prefix = name_no_prefix.charAt(0).toUpperCase() + name_no_prefix.slice(1), `uniform struct ${name_no_prefix} \n                                  {\\n` + Object.entries(uniform.value).map(([name, uniform]) => uniform.getDeclaration(name, type).replace(/^uniform/, \"\")).join(\"\") + `\\n} ${name}${length > 0 ? `[${length}]` : \"\"};`;\n              }\n\n              return `uniform ${uniform.type} ${name}${length > 0 ? `[${length}]` : \"\"};`;\n            }\n          }\n\n        }\n      },\n      PlaneGeometry: {\n        enumerable: !1,\n        value: class {\n          constructor(width, height, n, i, orientation) {\n            context.createBuffer(), this.attributes = {\n              position: new _miniGl.Attribute({\n                target: context.ARRAY_BUFFER,\n                size: 3\n              }),\n              uv: new _miniGl.Attribute({\n                target: context.ARRAY_BUFFER,\n                size: 2\n              }),\n              uvNorm: new _miniGl.Attribute({\n                target: context.ARRAY_BUFFER,\n                size: 2\n              }),\n              index: new _miniGl.Attribute({\n                target: context.ELEMENT_ARRAY_BUFFER,\n                size: 3,\n                type: context.UNSIGNED_SHORT\n              })\n            }, this.setTopology(n, i), this.setSize(width, height, orientation);\n          }\n\n          setTopology(e = 1, t = 1) {\n            const n = this;\n            n.xSegCount = e, n.ySegCount = t, n.vertexCount = (n.xSegCount + 1) * (n.ySegCount + 1), n.quadCount = n.xSegCount * n.ySegCount * 2, n.attributes.uv.values = new Float32Array(2 * n.vertexCount), n.attributes.uvNorm.values = new Float32Array(2 * n.vertexCount), n.attributes.index.values = new Uint16Array(3 * n.quadCount);\n\n            for (let e = 0; e <= n.ySegCount; e++) for (let t = 0; t <= n.xSegCount; t++) {\n              const i = e * (n.xSegCount + 1) + t;\n\n              if (n.attributes.uv.values[2 * i] = t / n.xSegCount, n.attributes.uv.values[2 * i + 1] = 1 - e / n.ySegCount, n.attributes.uvNorm.values[2 * i] = t / n.xSegCount * 2 - 1, n.attributes.uvNorm.values[2 * i + 1] = 1 - e / n.ySegCount * 2, t < n.xSegCount && e < n.ySegCount) {\n                const s = e * n.xSegCount + t;\n                n.attributes.index.values[6 * s] = i, n.attributes.index.values[6 * s + 1] = i + 1 + n.xSegCount, n.attributes.index.values[6 * s + 2] = i + 1, n.attributes.index.values[6 * s + 3] = i + 1, n.attributes.index.values[6 * s + 4] = i + 1 + n.xSegCount, n.attributes.index.values[6 * s + 5] = i + 2 + n.xSegCount;\n              }\n            }\n\n            n.attributes.uv.update(), n.attributes.uvNorm.update(), n.attributes.index.update(), _miniGl.debug(\"Geometry.setTopology\", {\n              uv: n.attributes.uv,\n              uvNorm: n.attributes.uvNorm,\n              index: n.attributes.index\n            });\n          }\n\n          setSize(width = 1, height = 1, orientation = \"xz\") {\n            const geometry = this;\n            geometry.width = width, geometry.height = height, geometry.orientation = orientation, geometry.attributes.position.values && geometry.attributes.position.values.length === 3 * geometry.vertexCount || (geometry.attributes.position.values = new Float32Array(3 * geometry.vertexCount));\n            const o = width / -2,\n                  r = height / -2,\n                  segment_width = width / geometry.xSegCount,\n                  segment_height = height / geometry.ySegCount;\n\n            for (let yIndex = 0; yIndex <= geometry.ySegCount; yIndex++) {\n              const t = r + yIndex * segment_height;\n\n              for (let xIndex = 0; xIndex <= geometry.xSegCount; xIndex++) {\n                const r = o + xIndex * segment_width,\n                      l = yIndex * (geometry.xSegCount + 1) + xIndex;\n                geometry.attributes.position.values[3 * l + \"xyz\".indexOf(orientation[0])] = r, geometry.attributes.position.values[-3 * l + \"xyz\".indexOf(orientation[1])] = -t;\n              }\n            }\n\n            geometry.attributes.position.update(), _miniGl.debug(\"Geometry.setSize\", {\n              position: geometry.attributes.position\n            });\n          }\n\n        }\n      },\n      Mesh: {\n        enumerable: !1,\n        value: class {\n          constructor(geometry, material) {\n            const mesh = this;\n            mesh.geometry = geometry, mesh.material = material, mesh.wireframe = !1, mesh.attributeInstances = [], Object.entries(mesh.geometry.attributes).forEach(([e, attribute]) => {\n              mesh.attributeInstances.push({\n                attribute: attribute,\n                location: attribute.attach(e, mesh.material.program)\n              });\n            }), _miniGl.meshes.push(mesh), _miniGl.debug(\"Mesh.constructor\", {\n              mesh: mesh\n            });\n          }\n\n          draw() {\n            context.useProgram(this.material.program), this.material.uniformInstances.forEach(({\n              uniform: e,\n              location: t\n            }) => e.update(t)), this.attributeInstances.forEach(({\n              attribute: e,\n              location: t\n            }) => e.use(t)), context.drawElements(this.wireframe ? context.LINES : context.TRIANGLES, this.geometry.attributes.index.values.length, context.UNSIGNED_SHORT, 0);\n          }\n\n          remove() {\n            _miniGl.meshes = _miniGl.meshes.filter(e => e != this);\n          }\n\n        }\n      },\n      Attribute: {\n        enumerable: !1,\n        value: class {\n          constructor(e) {\n            this.type = context.FLOAT, this.normalized = !1, this.buffer = context.createBuffer(), Object.assign(this, e), this.update();\n          }\n\n          update() {\n            void 0 !== this.values && (context.bindBuffer(this.target, this.buffer), context.bufferData(this.target, this.values, context.STATIC_DRAW));\n          }\n\n          attach(e, t) {\n            const n = context.getAttribLocation(t, e);\n            return this.target === context.ARRAY_BUFFER && (context.enableVertexAttribArray(n), context.vertexAttribPointer(n, this.size, this.type, this.normalized, 0, 0)), n;\n          }\n\n          use(e) {\n            context.bindBuffer(this.target, this.buffer), this.target === context.ARRAY_BUFFER && (context.enableVertexAttribArray(e), context.vertexAttribPointer(e, this.size, this.type, this.normalized, 0, 0));\n          }\n\n        }\n      }\n    });\n    const a = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n    _miniGl.commonUniforms = {\n      projectionMatrix: new _miniGl.Uniform({\n        type: \"mat4\",\n        value: a\n      }),\n      modelViewMatrix: new _miniGl.Uniform({\n        type: \"mat4\",\n        value: a\n      }),\n      resolution: new _miniGl.Uniform({\n        type: \"vec2\",\n        value: [1, 1]\n      }),\n      aspectRatio: new _miniGl.Uniform({\n        type: \"float\",\n        value: 1\n      })\n    };\n  }\n\n  setSize(e = 640, t = 480) {\n    this.width = e, this.height = t, this.canvas.width = e, this.canvas.height = t, this.gl.viewport(0, 0, e, t), this.commonUniforms.resolution.value = [e, t], this.commonUniforms.aspectRatio.value = e / t, this.debug(\"MiniGL.setSize\", {\n      width: e,\n      height: t\n    });\n  } //left, right, top, bottom, near, far\n\n\n  setOrthographicCamera(e = 0, t = 0, n = 0, i = -2e3, s = 2e3) {\n    this.commonUniforms.projectionMatrix.value = [2 / this.width, 0, 0, 0, 0, 2 / this.height, 0, 0, 0, 0, 2 / (i - s), 0, e, t, n, 1], this.debug(\"setOrthographicCamera\", this.commonUniforms.projectionMatrix.value);\n  }\n\n  render() {\n    this.gl.clearColor(0, 0, 0, 0), this.gl.clearDepth(1), this.meshes.forEach(e => e.draw());\n  }\n\n} //Sets initial properties\n\n\nfunction e(object, propertyName, val) {\n  return propertyName in object ? Object.defineProperty(object, propertyName, {\n    value: val,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : object[propertyName] = val, object;\n} //Gradient object\n\n\nexport class Gradient {\n  constructor(...t) {\n    e(this, \"el\", void 0), e(this, \"cssVarRetries\", 0), e(this, \"maxCssVarRetries\", 200), e(this, \"angle\", 0), e(this, \"isLoadedClass\", !1), e(this, \"isScrolling\", !1),\n    /*e(this, \"isStatic\", o.disableAmbientAnimations()),*/\n    e(this, \"scrollingTimeout\", void 0), e(this, \"scrollingRefreshDelay\", 200), e(this, \"isIntersecting\", !1), e(this, \"shaderFiles\", void 0), e(this, \"vertexShader\", void 0), e(this, \"sectionColors\", void 0), e(this, \"computedCanvasStyle\", void 0), e(this, \"conf\", void 0), e(this, \"uniforms\", void 0), e(this, \"t\", 1253106), e(this, \"last\", 0), e(this, \"width\", void 0), e(this, \"minWidth\", 1111), e(this, \"height\", 600), e(this, \"xSegCount\", void 0), e(this, \"ySegCount\", void 0), e(this, \"mesh\", void 0), e(this, \"material\", void 0), e(this, \"geometry\", void 0), e(this, \"minigl\", void 0), e(this, \"scrollObserver\", void 0), e(this, \"amp\", 320), e(this, \"seed\", 5), e(this, \"freqX\", 14e-5), e(this, \"freqY\", 29e-5), e(this, \"freqDelta\", 1e-5), e(this, \"activeColors\", [1, 1, 1, 1]), e(this, \"isMetaKey\", !1), e(this, \"isGradientLegendVisible\", !1), e(this, \"isMouseDown\", !1), e(this, \"handleScroll\", () => {\n      clearTimeout(this.scrollingTimeout), this.scrollingTimeout = setTimeout(this.handleScrollEnd, this.scrollingRefreshDelay), this.isGradientLegendVisible && this.hideGradientLegend(), this.conf.playing && (this.isScrolling = !0, this.pause());\n    }), e(this, \"handleScrollEnd\", () => {\n      this.isScrolling = !1, this.isIntersecting && this.play();\n    }), e(this, \"resize\", () => {\n      this.width = window.innerWidth, this.minigl.setSize(this.width, this.height), this.minigl.setOrthographicCamera(), this.xSegCount = Math.ceil(this.width * this.conf.density[0]), this.ySegCount = Math.ceil(this.height * this.conf.density[1]), this.mesh.geometry.setTopology(this.xSegCount, this.ySegCount), this.mesh.geometry.setSize(this.width, this.height), this.mesh.material.uniforms.u_shadow_power.value = this.width < 600 ? 5 : 6;\n    }), e(this, \"handleMouseDown\", e => {\n      this.isGradientLegendVisible && (this.isMetaKey = e.metaKey, this.isMouseDown = !0, !1 === this.conf.playing && requestAnimationFrame(this.animate));\n    }), e(this, \"handleMouseUp\", () => {\n      this.isMouseDown = !1;\n    }), e(this, \"animate\", e => {\n      if (!this.shouldSkipFrame(e) || this.isMouseDown) {\n        if (this.t += Math.min(e - this.last, 1e3 / 15), this.last = e, this.isMouseDown) {\n          let e = 160;\n          this.isMetaKey && (e = -160), this.t += e;\n        }\n\n        this.mesh.material.uniforms.u_time.value = this.t, this.minigl.render();\n      }\n\n      if (0 !== this.last && this.isStatic) return this.minigl.render(), void this.disconnect();\n      (\n      /*this.isIntersecting && */\n      this.conf.playing || this.isMouseDown) && requestAnimationFrame(this.animate);\n    }), e(this, \"addIsLoadedClass\", () => {\n      /*this.isIntersecting && */\n      !this.isLoadedClass && (this.isLoadedClass = !0, this.el.classList.add(\"isLoaded\"), setTimeout(() => {\n        this.el.parentElement.classList.add(\"isLoaded\");\n      }, 3e3));\n    }), e(this, \"pause\", () => {\n      this.conf.playing = false;\n    }), e(this, \"play\", () => {\n      requestAnimationFrame(this.animate), this.conf.playing = true;\n    }), e(this, \"initGradient\", selector => {\n      this.el = document.querySelector(selector);\n      this.connect();\n      return this;\n    });\n  }\n\n  async connect() {\n    this.shaderFiles = {\n      vertex: \"varying vec3 v_color;\\n\\nvoid main() {\\n  float time = u_time * u_global.noiseSpeed;\\n\\n  vec2 noiseCoord = resolution * uvNorm * u_global.noiseFreq;\\n\\n  vec2 st = 1. - uvNorm.xy;\\n\\n  //\\n  // Tilting the plane\\n  //\\n\\n  // Front-to-back tilt\\n  float tilt = resolution.y / 2.0 * uvNorm.y;\\n\\n  // Left-to-right angle\\n  float incline = resolution.x * uvNorm.x / 2.0 * u_vertDeform.incline;\\n\\n  // Up-down shift to offset incline\\n  float offset = resolution.x / 2.0 * u_vertDeform.incline * mix(u_vertDeform.offsetBottom, u_vertDeform.offsetTop, uv.y);\\n\\n  //\\n  // Vertex noise\\n  //\\n\\n  float noise = snoise(vec3(\\n    noiseCoord.x * u_vertDeform.noiseFreq.x + time * u_vertDeform.noiseFlow,\\n    noiseCoord.y * u_vertDeform.noiseFreq.y,\\n    time * u_vertDeform.noiseSpeed + u_vertDeform.noiseSeed\\n  )) * u_vertDeform.noiseAmp;\\n\\n  // Fade noise to zero at edges\\n  noise *= 1.0 - pow(abs(uvNorm.y), 2.0);\\n\\n  // Clamp to 0\\n  noise = max(0.0, noise);\\n\\n  vec3 pos = vec3(\\n    position.x,\\n    position.y + tilt + incline + noise - offset,\\n    position.z\\n  );\\n\\n  //\\n  // Vertex color, to be passed to fragment shader\\n  //\\n\\n  if (u_active_colors[0] == 1.) {\\n    v_color = u_baseColor;\\n  }\\n\\n  for (int i = 0; i < u_waveLayers_length; i++) {\\n    if (u_active_colors[i + 1] == 1.) {\\n      WaveLayers layer = u_waveLayers[i];\\n\\n      float noise = smoothstep(\\n        layer.noiseFloor,\\n        layer.noiseCeil,\\n        snoise(vec3(\\n          noiseCoord.x * layer.noiseFreq.x + time * layer.noiseFlow,\\n          noiseCoord.y * layer.noiseFreq.y,\\n          time * layer.noiseSpeed + layer.noiseSeed\\n        )) / 2.0 + 0.5\\n      );\\n\\n      v_color = blendNormal(v_color, layer.color, pow(noise, 4.));\\n    }\\n  }\\n\\n  //\\n  // Finish\\n  //\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\\n}\",\n      noise: \"//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : stegu\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//               https://github.com/stegu/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n    return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n{\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n          + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n}\",\n      blend: \"//\\n// https://github.com/jamieowen/glsl-blend\\n//\\n\\n// Normal\\n\\nvec3 blendNormal(vec3 base, vec3 blend) {\\n\\treturn blend;\\n}\\n\\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Screen\\n\\nfloat blendScreen(float base, float blend) {\\n\\treturn 1.0-((1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendScreen(vec3 base, vec3 blend) {\\n\\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\\n}\\n\\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Multiply\\n\\nvec3 blendMultiply(vec3 base, vec3 blend) {\\n\\treturn base*blend;\\n}\\n\\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Overlay\\n\\nfloat blendOverlay(float base, float blend) {\\n\\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendOverlay(vec3 base, vec3 blend) {\\n\\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\\n}\\n\\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Hard light\\n\\nvec3 blendHardLight(vec3 base, vec3 blend) {\\n\\treturn blendOverlay(blend,base);\\n}\\n\\nvec3 blendHardLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendHardLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Soft light\\n\\nfloat blendSoftLight(float base, float blend) {\\n\\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\\n}\\n\\nvec3 blendSoftLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\\n}\\n\\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Color dodge\\n\\nfloat blendColorDodge(float base, float blend) {\\n\\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\\n}\\n\\nvec3 blendColorDodge(vec3 base, vec3 blend) {\\n\\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\\n}\\n\\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Color burn\\n\\nfloat blendColorBurn(float base, float blend) {\\n\\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\\n}\\n\\nvec3 blendColorBurn(vec3 base, vec3 blend) {\\n\\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\\n}\\n\\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Vivid Light\\n\\nfloat blendVividLight(float base, float blend) {\\n\\treturn (blend<0.5)?blendColorBurn(base,(2.0*blend)):blendColorDodge(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendVividLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendVividLight(base.r,blend.r),blendVividLight(base.g,blend.g),blendVividLight(base.b,blend.b));\\n}\\n\\nvec3 blendVividLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendVividLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Lighten\\n\\nfloat blendLighten(float base, float blend) {\\n\\treturn max(blend,base);\\n}\\n\\nvec3 blendLighten(vec3 base, vec3 blend) {\\n\\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\\n}\\n\\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear burn\\n\\nfloat blendLinearBurn(float base, float blend) {\\n\\t// Note : Same implementation as BlendSubtractf\\n\\treturn max(base+blend-1.0,0.0);\\n}\\n\\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\\n\\t// Note : Same implementation as BlendSubtract\\n\\treturn max(base+blend-vec3(1.0),vec3(0.0));\\n}\\n\\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear dodge\\n\\nfloat blendLinearDodge(float base, float blend) {\\n\\t// Note : Same implementation as BlendAddf\\n\\treturn min(base+blend,1.0);\\n}\\n\\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\\n\\t// Note : Same implementation as BlendAdd\\n\\treturn min(base+blend,vec3(1.0));\\n}\\n\\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear light\\n\\nfloat blendLinearLight(float base, float blend) {\\n\\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendLinearLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\\n}\\n\\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\",\n      fragment: \"varying vec3 v_color;\\n\\nvoid main() {\\n  vec3 color = v_color;\\n  if (u_darken_top == 1.0) {\\n    vec2 st = gl_FragCoord.xy/resolution.xy;\\n    color.g -= pow(st.y + sin(-12.0) * st.x, u_shadow_power) * 0.4;\\n  }\\n  gl_FragColor = vec4(color, 1.0);\\n}\"\n    }, this.conf = {\n      presetName: \"\",\n      wireframe: false,\n      density: [.06, .16],\n      zoom: 1,\n      rotation: 0,\n      playing: true\n    }, document.querySelectorAll(\"canvas\").length < 1 ? console.log(\"DID NOT LOAD HERO STRIPE CANVAS\") : (this.minigl = new MiniGl(this.el, null, null, !0), requestAnimationFrame(() => {\n      this.el && (this.computedCanvasStyle = getComputedStyle(this.el), this.waitForCssVars());\n    })\n    /*\n    this.scrollObserver = await s.create(.1, !1),\n    this.scrollObserver.observe(this.el),\n    this.scrollObserver.onSeparate(() => {\n        window.removeEventListener(\"scroll\", this.handleScroll), window.removeEventListener(\"mousedown\", this.handleMouseDown), window.removeEventListener(\"mouseup\", this.handleMouseUp), window.removeEventListener(\"keydown\", this.handleKeyDown), this.isIntersecting = !1, this.conf.playing && this.pause()\n    }), \n    this.scrollObserver.onIntersect(() => {\n        window.addEventListener(\"scroll\", this.handleScroll), window.addEventListener(\"mousedown\", this.handleMouseDown), window.addEventListener(\"mouseup\", this.handleMouseUp), window.addEventListener(\"keydown\", this.handleKeyDown), this.isIntersecting = !0, this.addIsLoadedClass(), this.play()\n    })*/\n    );\n  }\n\n  disconnect() {\n    this.scrollObserver && (window.removeEventListener(\"scroll\", this.handleScroll), window.removeEventListener(\"mousedown\", this.handleMouseDown), window.removeEventListener(\"mouseup\", this.handleMouseUp), window.removeEventListener(\"keydown\", this.handleKeyDown), this.scrollObserver.disconnect()), window.removeEventListener(\"resize\", this.resize);\n  }\n\n  initMaterial() {\n    this.uniforms = {\n      u_time: new this.minigl.Uniform({\n        value: 0\n      }),\n      u_shadow_power: new this.minigl.Uniform({\n        value: 5\n      }),\n      u_darken_top: new this.minigl.Uniform({\n        value: \"\" === this.el.dataset.jsDarkenTop ? 1 : 0\n      }),\n      u_active_colors: new this.minigl.Uniform({\n        value: this.activeColors,\n        type: \"vec4\"\n      }),\n      u_global: new this.minigl.Uniform({\n        value: {\n          noiseFreq: new this.minigl.Uniform({\n            value: [this.freqX, this.freqY],\n            type: \"vec2\"\n          }),\n          noiseSpeed: new this.minigl.Uniform({\n            value: 5e-6\n          })\n        },\n        type: \"struct\"\n      }),\n      u_vertDeform: new this.minigl.Uniform({\n        value: {\n          incline: new this.minigl.Uniform({\n            value: Math.sin(this.angle) / Math.cos(this.angle)\n          }),\n          offsetTop: new this.minigl.Uniform({\n            value: -.5\n          }),\n          offsetBottom: new this.minigl.Uniform({\n            value: -.5\n          }),\n          noiseFreq: new this.minigl.Uniform({\n            value: [3, 4],\n            type: \"vec2\"\n          }),\n          noiseAmp: new this.minigl.Uniform({\n            value: this.amp\n          }),\n          noiseSpeed: new this.minigl.Uniform({\n            value: 10\n          }),\n          noiseFlow: new this.minigl.Uniform({\n            value: 3\n          }),\n          noiseSeed: new this.minigl.Uniform({\n            value: this.seed\n          })\n        },\n        type: \"struct\",\n        excludeFrom: \"fragment\"\n      }),\n      u_baseColor: new this.minigl.Uniform({\n        value: this.sectionColors[0],\n        type: \"vec3\",\n        excludeFrom: \"fragment\"\n      }),\n      u_waveLayers: new this.minigl.Uniform({\n        value: [],\n        excludeFrom: \"fragment\",\n        type: \"array\"\n      })\n    };\n\n    for (let e = 1; e < this.sectionColors.length; e += 1) this.uniforms.u_waveLayers.value.push(new this.minigl.Uniform({\n      value: {\n        color: new this.minigl.Uniform({\n          value: this.sectionColors[e],\n          type: \"vec3\"\n        }),\n        noiseFreq: new this.minigl.Uniform({\n          value: [2 + e / this.sectionColors.length, 3 + e / this.sectionColors.length],\n          type: \"vec2\"\n        }),\n        noiseSpeed: new this.minigl.Uniform({\n          value: 11 + .3 * e\n        }),\n        noiseFlow: new this.minigl.Uniform({\n          value: 6.5 + .3 * e\n        }),\n        noiseSeed: new this.minigl.Uniform({\n          value: this.seed + 10 * e\n        }),\n        noiseFloor: new this.minigl.Uniform({\n          value: .1\n        }),\n        noiseCeil: new this.minigl.Uniform({\n          value: .63 + .07 * e\n        })\n      },\n      type: \"struct\"\n    }));\n\n    return this.vertexShader = [this.shaderFiles.noise, this.shaderFiles.blend, this.shaderFiles.vertex].join(\"\\n\\n\"), new this.minigl.Material(this.vertexShader, this.shaderFiles.fragment, this.uniforms);\n  }\n\n  initMesh() {\n    this.material = this.initMaterial(), this.geometry = new this.minigl.PlaneGeometry(), this.mesh = new this.minigl.Mesh(this.geometry, this.material);\n  }\n\n  shouldSkipFrame(e) {\n    return !!window.document.hidden || !this.conf.playing || parseInt(e, 10) % 2 == 0 || void 0;\n  }\n\n  updateFrequency(e) {\n    this.freqX += e, this.freqY += e;\n  }\n\n  toggleColor(index) {\n    this.activeColors[index] = 0 === this.activeColors[index] ? 1 : 0;\n  }\n\n  showGradientLegend() {\n    this.width > this.minWidth && (this.isGradientLegendVisible = !0, document.body.classList.add(\"isGradientLegendVisible\"));\n  }\n\n  hideGradientLegend() {\n    this.isGradientLegendVisible = !1, document.body.classList.remove(\"isGradientLegendVisible\");\n  }\n\n  init() {\n    this.initGradientColors(), this.initMesh(), this.resize(), requestAnimationFrame(this.animate), window.addEventListener(\"resize\", this.resize);\n  }\n  /*\n  * Waiting for the css variables to become available, usually on page load before we can continue.\n  * Using default colors assigned below if no variables have been found after maxCssVarRetries\n  */\n\n\n  waitForCssVars() {\n    if (this.computedCanvasStyle && -1 !== this.computedCanvasStyle.getPropertyValue(\"--gradient-color-1\").indexOf(\"#\")) this.init(), this.addIsLoadedClass();else {\n      if (this.cssVarRetries += 1, this.cssVarRetries > this.maxCssVarRetries) {\n        return this.sectionColors = [16711680, 16711680, 16711935, 65280, 255], void this.init();\n      }\n\n      requestAnimationFrame(() => this.waitForCssVars());\n    }\n  }\n  /*\n  * Initializes the four section colors by retrieving them from css variables.\n  */\n\n\n  initGradientColors() {\n    this.sectionColors = [\"--gradient-color-1\", \"--gradient-color-2\", \"--gradient-color-3\", \"--gradient-color-4\"].map(cssPropertyName => {\n      let hex = this.computedCanvasStyle.getPropertyValue(cssPropertyName).trim(); //Check if shorthand hex value was used and double the length so the conversion in normalizeColor will work.\n\n      if (4 === hex.length) {\n        const hexTemp = hex.substr(1).split(\"\").map(hexTemp => hexTemp + hexTemp).join(\"\");\n        hex = `#${hexTemp}`;\n      }\n\n      return hex && `0x${hex.substr(1)}`;\n    }).filter(Boolean).map(normalizeColor);\n  }\n\n}\n/*\n*Finally initializing the Gradient class, assigning a canvas to it and calling Gradient.connect() which initializes everything,\n* Use Gradient.pause() and Gradient.play() for controls.\n*\n* Here are some default property values you can change anytime:\n* Amplitude:    Gradient.amp = 0\n* Colors:       Gradient.sectionColors (if you change colors, use normalizeColor(#hexValue)) before you assign it.\n*\n*\n* Useful functions\n* Gradient.toggleColor(index)\n* Gradient.updateFrequency(freq)\n*/","map":{"version":3,"sources":["/Users/guy/Development/Web/Site/api/gradient.js"],"names":["normalizeColor","hexCode","reduce","t","n","Object","assign","MiniGl","constructor","canvas","width","height","debug","_miniGl","debug_output","document","location","search","toLowerCase","indexOf","gl","getContext","antialias","meshes","context","setSize","lastDebugMsg","e","Date","console","log","toLocaleTimeString","Array","Math","max","length","join","from","arguments","slice","defineProperties","Material","enumerable","value","vertexShaders","fragments","uniforms","material","getShaderByType","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","error","getShaderInfoLog","getUniformVariableDeclarations","entries","map","uniform","getDeclaration","uniformInstances","prefix","vertexSource","commonUniforms","Source","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","program","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","useProgram","attachUniforms","name","forEach","i","push","getUniformLocation","Uniform","typeFn","float","int","vec2","vec3","vec4","mat4","update","transpose","excludeFrom","name_no_prefix","replace","charAt","toUpperCase","PlaneGeometry","orientation","createBuffer","attributes","position","Attribute","target","ARRAY_BUFFER","size","uv","uvNorm","index","ELEMENT_ARRAY_BUFFER","UNSIGNED_SHORT","setTopology","xSegCount","ySegCount","vertexCount","quadCount","values","Float32Array","Uint16Array","s","geometry","o","r","segment_width","segment_height","yIndex","xIndex","l","Mesh","mesh","wireframe","attributeInstances","attribute","attach","draw","use","drawElements","LINES","TRIANGLES","remove","filter","FLOAT","normalized","buffer","bindBuffer","bufferData","STATIC_DRAW","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","a","projectionMatrix","modelViewMatrix","resolution","aspectRatio","viewport","setOrthographicCamera","render","clearColor","clearDepth","object","propertyName","val","defineProperty","configurable","writable","Gradient","clearTimeout","scrollingTimeout","setTimeout","handleScrollEnd","scrollingRefreshDelay","isGradientLegendVisible","hideGradientLegend","conf","playing","isScrolling","pause","isIntersecting","play","window","innerWidth","minigl","ceil","density","u_shadow_power","isMetaKey","metaKey","isMouseDown","requestAnimationFrame","animate","shouldSkipFrame","min","last","u_time","isStatic","disconnect","isLoadedClass","el","classList","add","parentElement","selector","querySelector","connect","shaderFiles","vertex","noise","blend","fragment","presetName","zoom","rotation","querySelectorAll","computedCanvasStyle","getComputedStyle","waitForCssVars","scrollObserver","removeEventListener","handleScroll","handleMouseDown","handleMouseUp","handleKeyDown","resize","initMaterial","u_darken_top","dataset","jsDarkenTop","u_active_colors","activeColors","u_global","noiseFreq","freqX","freqY","noiseSpeed","u_vertDeform","incline","sin","angle","cos","offsetTop","offsetBottom","noiseAmp","amp","noiseFlow","noiseSeed","seed","u_baseColor","sectionColors","u_waveLayers","color","noiseFloor","noiseCeil","initMesh","hidden","parseInt","updateFrequency","toggleColor","showGradientLegend","minWidth","body","init","initGradientColors","addEventListener","getPropertyValue","addIsLoadedClass","cssVarRetries","maxCssVarRetries","cssPropertyName","hex","trim","hexTemp","substr","split","Boolean"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA,SAASA,cAAT,CAAwBC,OAAxB,EAAiC;AAC7B,SAAO,CAAC,CAACA,OAAO,IAAI,EAAX,GAAgB,GAAjB,IAAwB,GAAzB,EAA8B,CAACA,OAAO,IAAI,CAAX,GAAe,GAAhB,IAAuB,GAArD,EAA0D,CAAC,MAAMA,OAAP,IAAkB,GAA5E,CAAP;AACH;;AAAC,CAAC,QAAD,EAAW,cAAX,EAA2BC,MAA3B,CAAkC,CAACD,OAAD,EAAUE,CAAV,EAAaC,CAAb,KAAmBC,MAAM,CAACC,MAAP,CAAcL,OAAd,EAAuB;AAC1E,GAACE,CAAD,GAAKC;AADqE,CAAvB,CAArD,EAEE,EAFF,E,CAIF;AACA;AACA;;AACA,MAAMG,MAAN,CAAa;AACTC,EAAAA,WAAW,CAACC,MAAD,EAASC,KAAT,EAAgBC,MAAhB,EAAwBC,KAAK,GAAG,KAAhC,EAAuC;AAC9C,UAAMC,OAAO,GAAG,IAAhB;AAAA,UACIC,YAAY,GAAG,CAAC,CAAD,KAAOC,QAAQ,CAACC,QAAT,CAAkBC,MAAlB,CAAyBC,WAAzB,GAAuCC,OAAvC,CAA+C,aAA/C,CAD1B;;AAEAN,IAAAA,OAAO,CAACJ,MAAR,GAAiBA,MAAjB,EAAyBI,OAAO,CAACO,EAAR,GAAaP,OAAO,CAACJ,MAAR,CAAeY,UAAf,CAA0B,OAA1B,EAAmC;AACrEC,MAAAA,SAAS,EAAE;AAD0D,KAAnC,CAAtC,EAEIT,OAAO,CAACU,MAAR,GAAiB,EAFrB;AAGA,UAAMC,OAAO,GAAGX,OAAO,CAACO,EAAxB;AACAV,IAAAA,KAAK,IAAIC,MAAT,IAAmB,KAAKc,OAAL,CAAaf,KAAb,EAAoBC,MAApB,CAAnB,EAAgDE,OAAO,CAACa,YAAxD,EAAsEb,OAAO,CAACD,KAAR,GAAgBA,KAAK,IAAIE,YAAT,GAAwB,UAAUa,CAAV,EAAa;AACvH,YAAMxB,CAAC,GAAG,IAAIyB,IAAJ,EAAV;AACAzB,MAAAA,CAAC,GAAGU,OAAO,CAACa,YAAZ,GAA2B,GAA3B,IAAkCG,OAAO,CAACC,GAAR,CAAY,KAAZ,CAAlC,EAAsDD,OAAO,CAACC,GAAR,CAAY3B,CAAC,CAAC4B,kBAAF,KAAyBC,KAAK,CAACC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,KAAKP,CAAC,CAACQ,MAAnB,CAAD,CAAL,CAAkCC,IAAlC,CAAuC,GAAvC,CAAzB,GAAuET,CAAvE,GAA2E,IAAvF,EAA6F,GAAGK,KAAK,CAACK,IAAN,CAAWC,SAAX,EAAsBC,KAAtB,CAA4B,CAA5B,CAAhG,CAAtD,EAAuL1B,OAAO,CAACa,YAAR,GAAuBvB,CAA9M;AACH,KAHqF,GAGlF,MAAM,CAAG,CAHb,EAGeE,MAAM,CAACmC,gBAAP,CAAwB3B,OAAxB,EAAiC;AAC5C4B,MAAAA,QAAQ,EAAE;AACNC,QAAAA,UAAU,EAAE,KADN;AAENC,QAAAA,KAAK,EAAE,MAAM;AACTnC,UAAAA,WAAW,CAACoC,aAAD,EAAgBC,SAAhB,EAA2BC,QAAQ,GAAG,EAAtC,EAA0C;AACjD,kBAAMC,QAAQ,GAAG,IAAjB;;AACA,qBAASC,eAAT,CAAyBC,IAAzB,EAA+BC,MAA/B,EAAuC;AACnC,oBAAMC,MAAM,GAAG3B,OAAO,CAAC4B,YAAR,CAAqBH,IAArB,CAAf;AACA,qBAAOzB,OAAO,CAAC6B,YAAR,CAAqBF,MAArB,EAA6BD,MAA7B,GAAsC1B,OAAO,CAAC8B,aAAR,CAAsBH,MAAtB,CAAtC,EAAqE3B,OAAO,CAAC+B,kBAAR,CAA2BJ,MAA3B,EAAmC3B,OAAO,CAACgC,cAA3C,KAA8D3B,OAAO,CAAC4B,KAAR,CAAcjC,OAAO,CAACkC,gBAAR,CAAyBP,MAAzB,CAAd,CAAnI,EAAoLtC,OAAO,CAACD,KAAR,CAAc,8BAAd,EAA8C;AACrOsC,gBAAAA,MAAM,EAAEA;AAD6N,eAA9C,CAApL,EAEHC,MAFJ;AAGH;;AACD,qBAASQ,8BAAT,CAAwCb,QAAxC,EAAkDG,IAAlD,EAAwD;AACpD,qBAAO5C,MAAM,CAACuD,OAAP,CAAed,QAAf,EAAyBe,GAAzB,CAA6B,CAAC,CAACC,OAAD,EAAUnB,KAAV,CAAD,KAAsBA,KAAK,CAACoB,cAAN,CAAqBD,OAArB,EAA8Bb,IAA9B,CAAnD,EAAwFb,IAAxF,CAA6F,IAA7F,CAAP;AACH;;AACDW,YAAAA,QAAQ,CAACD,QAAT,GAAoBA,QAApB,EAA8BC,QAAQ,CAACiB,gBAAT,GAA4B,EAA1D;AAEA,kBAAMC,MAAM,GAAG,sDAAf;AACAlB,YAAAA,QAAQ,CAACmB,YAAT,GAAyB,mBAAkBD,MAAO,mIAAkIN,8BAA8B,CAAC9C,OAAO,CAACsD,cAAT,EAAyB,QAAzB,CAAmC,mBAAkBR,8BAA8B,CAACb,QAAD,EAAW,QAAX,CAAqB,mBAAkBF,aAAc,gBAA1V,EACIG,QAAQ,CAACqB,MAAT,GAAmB,mBAAkBH,MAAO,mBAAkBN,8BAA8B,CAAC9C,OAAO,CAACsD,cAAT,EAAyB,UAAzB,CAAqC,mBAAkBR,8BAA8B,CAACb,QAAD,EAAW,UAAX,CAAuB,mBAAkBD,SAAU,gBADxO,EAEIE,QAAQ,CAACsB,YAAT,GAAwBrB,eAAe,CAACxB,OAAO,CAAC8C,aAAT,EAAwBvB,QAAQ,CAACmB,YAAjC,CAF3C,EAGInB,QAAQ,CAACwB,cAAT,GAA0BvB,eAAe,CAACxB,OAAO,CAACgD,eAAT,EAA0BzB,QAAQ,CAACqB,MAAnC,CAH7C,EAIIrB,QAAQ,CAAC0B,OAAT,GAAmBjD,OAAO,CAACkD,aAAR,EAJvB,EAKIlD,OAAO,CAACmD,YAAR,CAAqB5B,QAAQ,CAAC0B,OAA9B,EAAuC1B,QAAQ,CAACsB,YAAhD,CALJ,EAMI7C,OAAO,CAACmD,YAAR,CAAqB5B,QAAQ,CAAC0B,OAA9B,EAAuC1B,QAAQ,CAACwB,cAAhD,CANJ,EAOI/C,OAAO,CAACoD,WAAR,CAAoB7B,QAAQ,CAAC0B,OAA7B,CAPJ,EAQIjD,OAAO,CAACqD,mBAAR,CAA4B9B,QAAQ,CAAC0B,OAArC,EAA8CjD,OAAO,CAACsD,WAAtD,KAAsEjD,OAAO,CAAC4B,KAAR,CAAcjC,OAAO,CAACuD,iBAAR,CAA0BhC,QAAQ,CAAC0B,OAAnC,CAAd,CAR1E,EASIjD,OAAO,CAACwD,UAAR,CAAmBjC,QAAQ,CAAC0B,OAA5B,CATJ,EAUI1B,QAAQ,CAACkC,cAAT,CAAwB,KAAK,CAA7B,EAAgCpE,OAAO,CAACsD,cAAxC,CAVJ,EAWIpB,QAAQ,CAACkC,cAAT,CAAwB,KAAK,CAA7B,EAAgClC,QAAQ,CAACD,QAAzC,CAXJ;AAYH,WA3BQ,CA4BT;;;AACAmC,UAAAA,cAAc,CAACC,IAAD,EAAOpC,QAAP,EAAiB;AAC3B;AACA,kBAAMC,QAAQ,GAAG,IAAjB;AACA,iBAAK,CAAL,KAAWmC,IAAX,GAAkB7E,MAAM,CAACuD,OAAP,CAAed,QAAf,EAAyBqC,OAAzB,CAAiC,CAAC,CAACD,IAAD,EAAOpB,OAAP,CAAD,KAAqB;AACpEf,cAAAA,QAAQ,CAACkC,cAAT,CAAwBC,IAAxB,EAA8BpB,OAA9B;AACH,aAFiB,CAAlB,GAEK,WAAWhB,QAAQ,CAACG,IAApB,GAA2BH,QAAQ,CAACH,KAAT,CAAewC,OAAf,CAAuB,CAACrB,OAAD,EAAUsB,CAAV,KAAgBrC,QAAQ,CAACkC,cAAT,CAAyB,GAAEC,IAAK,IAAGE,CAAE,GAArC,EAAyCtB,OAAzC,CAAvC,CAA3B,GAAuH,YAAYhB,QAAQ,CAACG,IAArB,GAA4B5C,MAAM,CAACuD,OAAP,CAAed,QAAQ,CAACH,KAAxB,EAA+BwC,OAA/B,CAAuC,CAAC,CAACrB,OAAD,EAAUsB,CAAV,CAAD,KAAkBrC,QAAQ,CAACkC,cAAT,CAAyB,GAAEC,IAAK,IAAGpB,OAAQ,EAA3C,EAA8CsB,CAA9C,CAAzD,CAA5B,IAA0IvE,OAAO,CAACD,KAAR,CAAc,yBAAd,EAAyC;AAC3SsE,cAAAA,IAAI,EAAEA,IADqS;AAE3SpB,cAAAA,OAAO,EAAEhB;AAFkS,aAAzC,GAGlQC,QAAQ,CAACiB,gBAAT,CAA0BqB,IAA1B,CAA+B;AAC/BvB,cAAAA,OAAO,EAAEhB,QADsB;AAE/B9B,cAAAA,QAAQ,EAAEQ,OAAO,CAAC8D,kBAAR,CAA2BvC,QAAQ,CAAC0B,OAApC,EAA6CS,IAA7C;AAFqB,aAA/B,CAHwH,CAF5H;AASH;;AAzCQ;AAFP,OADkC;AA+C5CK,MAAAA,OAAO,EAAE;AACL7C,QAAAA,UAAU,EAAE,CAAC,CADR;AAELC,QAAAA,KAAK,EAAE,MAAM;AACTnC,UAAAA,WAAW,CAACmB,CAAD,EAAI;AACX,iBAAKsB,IAAL,GAAY,OAAZ,EAAqB5C,MAAM,CAACC,MAAP,CAAc,IAAd,EAAoBqB,CAApB,CAArB;AACA,iBAAK6D,MAAL,GAAc;AACVC,cAAAA,KAAK,EAAE,IADG;AAEVC,cAAAA,GAAG,EAAE,IAFK;AAGVC,cAAAA,IAAI,EAAE,KAHI;AAIVC,cAAAA,IAAI,EAAE,KAJI;AAKVC,cAAAA,IAAI,EAAE,KALI;AAMVC,cAAAA,IAAI,EAAE;AANI,cAOZ,KAAK7C,IAPO,KAOE,IAPhB,EAOsB,KAAK8C,MAAL,EAPtB;AAQH;;AACDA,UAAAA,MAAM,CAACpD,KAAD,EAAQ;AACV,iBAAK,CAAL,KAAW,KAAKA,KAAhB,IAAyBnB,OAAO,CAAE,UAAS,KAAKgE,MAAO,EAAvB,CAAP,CAAiC7C,KAAjC,EAAwC,MAAM,KAAK6C,MAAL,CAAYrE,OAAZ,CAAoB,QAApB,CAAN,GAAsC,KAAK6E,SAA3C,GAAuD,KAAKrD,KAApG,EAA2G,MAAM,KAAK6C,MAAL,CAAYrE,OAAZ,CAAoB,QAApB,CAAN,GAAsC,KAAKwB,KAA3C,GAAmD,IAA9J,CAAzB;AACH,WAdQ,CAeT;AACA;AACA;;;AACAoB,UAAAA,cAAc,CAACmB,IAAD,EAAOjC,IAAP,EAAad,MAAb,EAAqB;AAC/B,kBAAM2B,OAAO,GAAG,IAAhB;;AACA,gBAAIA,OAAO,CAACmC,WAAR,KAAwBhD,IAA5B,EAAkC;AAC9B,kBAAI,YAAYa,OAAO,CAACb,IAAxB,EAA8B,OAAOa,OAAO,CAACnB,KAAR,CAAc,CAAd,EAAiBoB,cAAjB,CAAgCmB,IAAhC,EAAsCjC,IAAtC,EAA4Ca,OAAO,CAACnB,KAAR,CAAcR,MAA1D,IAAqE,eAAc+C,IAAK,aAAYpB,OAAO,CAACnB,KAAR,CAAcR,MAAO,GAAhI;;AAC9B,kBAAI,aAAa2B,OAAO,CAACb,IAAzB,EAA+B;AAC3B,oBAAIiD,cAAc,GAAGhB,IAAI,CAACiB,OAAL,CAAa,IAAb,EAAmB,EAAnB,CAArB;AACA,uBAAOD,cAAc,GACjBA,cAAc,CAACE,MAAf,CAAsB,CAAtB,EAAyBC,WAAzB,KACAH,cAAc,CAAC3D,KAAf,CAAqB,CAArB,CAFG,EAGF,kBAAiB2D,cAAe;AACrE,sCADoC,GAEA7F,MAAM,CAACuD,OAAP,CAAeE,OAAO,CAACnB,KAAvB,EAA8BkB,GAA9B,CAAkC,CAAC,CAACqB,IAAD,EAAOpB,OAAP,CAAD,KAC9BA,OAAO,CAACC,cAAR,CAAuBmB,IAAvB,EAA6BjC,IAA7B,EACKkD,OADL,CACa,UADb,EACyB,EADzB,CADJ,EAGK/D,IAHL,CAGU,EAHV,CAFA,GAMG,OAAM8C,IAAK,GAAE/C,MAAM,GAAG,CAAT,GAAc,IAAGA,MAAO,GAAxB,GAA6B,EAAG,GATpD;AAUH;;AACD,qBAAQ,WAAU2B,OAAO,CAACb,IAAK,IAAGiC,IAAK,GAAE/C,MAAM,GAAG,CAAT,GAAc,IAAGA,MAAO,GAAxB,GAA6B,EAAG,GAAzE;AACH;AACJ;;AArCQ;AAFR,OA/CmC;AAyF5CmE,MAAAA,aAAa,EAAE;AACX5D,QAAAA,UAAU,EAAE,CAAC,CADF;AAEXC,QAAAA,KAAK,EAAE,MAAM;AACTnC,UAAAA,WAAW,CAACE,KAAD,EAAQC,MAAR,EAAgBP,CAAhB,EAAmBgF,CAAnB,EAAsBmB,WAAtB,EAAmC;AAC1C/E,YAAAA,OAAO,CAACgF,YAAR,IAAwB,KAAKC,UAAL,GAAkB;AACtCC,cAAAA,QAAQ,EAAE,IAAI7F,OAAO,CAAC8F,SAAZ,CAAsB;AAC5BC,gBAAAA,MAAM,EAAEpF,OAAO,CAACqF,YADY;AAE5BC,gBAAAA,IAAI,EAAE;AAFsB,eAAtB,CAD4B;AAKtCC,cAAAA,EAAE,EAAE,IAAIlG,OAAO,CAAC8F,SAAZ,CAAsB;AACtBC,gBAAAA,MAAM,EAAEpF,OAAO,CAACqF,YADM;AAEtBC,gBAAAA,IAAI,EAAE;AAFgB,eAAtB,CALkC;AAStCE,cAAAA,MAAM,EAAE,IAAInG,OAAO,CAAC8F,SAAZ,CAAsB;AAC1BC,gBAAAA,MAAM,EAAEpF,OAAO,CAACqF,YADU;AAE1BC,gBAAAA,IAAI,EAAE;AAFoB,eAAtB,CAT8B;AAatCG,cAAAA,KAAK,EAAE,IAAIpG,OAAO,CAAC8F,SAAZ,CAAsB;AACzBC,gBAAAA,MAAM,EAAEpF,OAAO,CAAC0F,oBADS;AAEzBJ,gBAAAA,IAAI,EAAE,CAFmB;AAGzB7D,gBAAAA,IAAI,EAAEzB,OAAO,CAAC2F;AAHW,eAAtB;AAb+B,aAA1C,EAkBG,KAAKC,WAAL,CAAiBhH,CAAjB,EAAoBgF,CAApB,CAlBH,EAkB2B,KAAK3D,OAAL,CAAaf,KAAb,EAAoBC,MAApB,EAA4B4F,WAA5B,CAlB3B;AAmBH;;AACDa,UAAAA,WAAW,CAACzF,CAAC,GAAG,CAAL,EAAQxB,CAAC,GAAG,CAAZ,EAAe;AACtB,kBAAMC,CAAC,GAAG,IAAV;AACAA,YAAAA,CAAC,CAACiH,SAAF,GAAc1F,CAAd,EAAiBvB,CAAC,CAACkH,SAAF,GAAcnH,CAA/B,EAAkCC,CAAC,CAACmH,WAAF,GAAgB,CAACnH,CAAC,CAACiH,SAAF,GAAc,CAAf,KAAqBjH,CAAC,CAACkH,SAAF,GAAc,CAAnC,CAAlD,EAAyFlH,CAAC,CAACoH,SAAF,GAAcpH,CAAC,CAACiH,SAAF,GAAcjH,CAAC,CAACkH,SAAhB,GAA4B,CAAnI,EAAsIlH,CAAC,CAACqG,UAAF,CAAaM,EAAb,CAAgBU,MAAhB,GAAyB,IAAIC,YAAJ,CAAiB,IAAItH,CAAC,CAACmH,WAAvB,CAA/J,EAAoMnH,CAAC,CAACqG,UAAF,CAAaO,MAAb,CAAoBS,MAApB,GAA6B,IAAIC,YAAJ,CAAiB,IAAItH,CAAC,CAACmH,WAAvB,CAAjO,EAAsQnH,CAAC,CAACqG,UAAF,CAAaQ,KAAb,CAAmBQ,MAAnB,GAA4B,IAAIE,WAAJ,CAAgB,IAAIvH,CAAC,CAACoH,SAAtB,CAAlS;;AACA,iBAAK,IAAI7F,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIvB,CAAC,CAACkH,SAAvB,EAAkC3F,CAAC,EAAnC,EACI,KAAK,IAAIxB,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIC,CAAC,CAACiH,SAAvB,EAAkClH,CAAC,EAAnC,EAAuC;AACnC,oBAAMiF,CAAC,GAAGzD,CAAC,IAAIvB,CAAC,CAACiH,SAAF,GAAc,CAAlB,CAAD,GAAwBlH,CAAlC;;AACA,kBAAIC,CAAC,CAACqG,UAAF,CAAaM,EAAb,CAAgBU,MAAhB,CAAuB,IAAIrC,CAA3B,IAAgCjF,CAAC,GAAGC,CAAC,CAACiH,SAAtC,EAAiDjH,CAAC,CAACqG,UAAF,CAAaM,EAAb,CAAgBU,MAAhB,CAAuB,IAAIrC,CAAJ,GAAQ,CAA/B,IAAoC,IAAIzD,CAAC,GAAGvB,CAAC,CAACkH,SAA/F,EAA0GlH,CAAC,CAACqG,UAAF,CAAaO,MAAb,CAAoBS,MAApB,CAA2B,IAAIrC,CAA/B,IAAoCjF,CAAC,GAAGC,CAAC,CAACiH,SAAN,GAAkB,CAAlB,GAAsB,CAApK,EAAuKjH,CAAC,CAACqG,UAAF,CAAaO,MAAb,CAAoBS,MAApB,CAA2B,IAAIrC,CAAJ,GAAQ,CAAnC,IAAwC,IAAIzD,CAAC,GAAGvB,CAAC,CAACkH,SAAN,GAAkB,CAArO,EAAwOnH,CAAC,GAAGC,CAAC,CAACiH,SAAN,IAAmB1F,CAAC,GAAGvB,CAAC,CAACkH,SAArQ,EAAgR;AAC5Q,sBAAMM,CAAC,GAAGjG,CAAC,GAAGvB,CAAC,CAACiH,SAAN,GAAkBlH,CAA5B;AACAC,gBAAAA,CAAC,CAACqG,UAAF,CAAaQ,KAAb,CAAmBQ,MAAnB,CAA0B,IAAIG,CAA9B,IAAmCxC,CAAnC,EAAsChF,CAAC,CAACqG,UAAF,CAAaQ,KAAb,CAAmBQ,MAAnB,CAA0B,IAAIG,CAAJ,GAAQ,CAAlC,IAAuCxC,CAAC,GAAG,CAAJ,GAAQhF,CAAC,CAACiH,SAAvF,EAAkGjH,CAAC,CAACqG,UAAF,CAAaQ,KAAb,CAAmBQ,MAAnB,CAA0B,IAAIG,CAAJ,GAAQ,CAAlC,IAAuCxC,CAAC,GAAG,CAA7I,EAAgJhF,CAAC,CAACqG,UAAF,CAAaQ,KAAb,CAAmBQ,MAAnB,CAA0B,IAAIG,CAAJ,GAAQ,CAAlC,IAAuCxC,CAAC,GAAG,CAA3L,EAA8LhF,CAAC,CAACqG,UAAF,CAAaQ,KAAb,CAAmBQ,MAAnB,CAA0B,IAAIG,CAAJ,GAAQ,CAAlC,IAAuCxC,CAAC,GAAG,CAAJ,GAAQhF,CAAC,CAACiH,SAA/O,EAA0PjH,CAAC,CAACqG,UAAF,CAAaQ,KAAb,CAAmBQ,MAAnB,CAA0B,IAAIG,CAAJ,GAAQ,CAAlC,IAAuCxC,CAAC,GAAG,CAAJ,GAAQhF,CAAC,CAACiH,SAA3S;AACH;AACJ;;AACLjH,YAAAA,CAAC,CAACqG,UAAF,CAAaM,EAAb,CAAgBhB,MAAhB,IAA0B3F,CAAC,CAACqG,UAAF,CAAaO,MAAb,CAAoBjB,MAApB,EAA1B,EAAwD3F,CAAC,CAACqG,UAAF,CAAaQ,KAAb,CAAmBlB,MAAnB,EAAxD,EAAqFlF,OAAO,CAACD,KAAR,CAAc,sBAAd,EAAsC;AACvHmG,cAAAA,EAAE,EAAE3G,CAAC,CAACqG,UAAF,CAAaM,EADsG;AAEvHC,cAAAA,MAAM,EAAE5G,CAAC,CAACqG,UAAF,CAAaO,MAFkG;AAGvHC,cAAAA,KAAK,EAAE7G,CAAC,CAACqG,UAAF,CAAaQ;AAHmG,aAAtC,CAArF;AAKH;;AACDxF,UAAAA,OAAO,CAACf,KAAK,GAAG,CAAT,EAAYC,MAAM,GAAG,CAArB,EAAwB4F,WAAW,GAAG,IAAtC,EAA4C;AAC/C,kBAAMsB,QAAQ,GAAG,IAAjB;AACAA,YAAAA,QAAQ,CAACnH,KAAT,GAAiBA,KAAjB,EACImH,QAAQ,CAAClH,MAAT,GAAkBA,MADtB,EAEIkH,QAAQ,CAACtB,WAAT,GAAuBA,WAF3B,EAGIsB,QAAQ,CAACpB,UAAT,CAAoBC,QAApB,CAA6Be,MAA7B,IAAuCI,QAAQ,CAACpB,UAAT,CAAoBC,QAApB,CAA6Be,MAA7B,CAAoCtF,MAApC,KAA+C,IAAI0F,QAAQ,CAACN,WAAnG,KACIM,QAAQ,CAACpB,UAAT,CAAoBC,QAApB,CAA6Be,MAA7B,GAAsC,IAAIC,YAAJ,CAAiB,IAAIG,QAAQ,CAACN,WAA9B,CAD1C,CAHJ;AAKA,kBAAMO,CAAC,GAAGpH,KAAK,GAAG,CAAC,CAAnB;AAAA,kBACIqH,CAAC,GAAGpH,MAAM,GAAG,CAAC,CADlB;AAAA,kBAEIqH,aAAa,GAAGtH,KAAK,GAAGmH,QAAQ,CAACR,SAFrC;AAAA,kBAGIY,cAAc,GAAGtH,MAAM,GAAGkH,QAAQ,CAACP,SAHvC;;AAIA,iBAAK,IAAIY,MAAM,GAAG,CAAlB,EAAqBA,MAAM,IAAIL,QAAQ,CAACP,SAAxC,EAAmDY,MAAM,EAAzD,EAA6D;AACzD,oBAAM/H,CAAC,GAAG4H,CAAC,GAAGG,MAAM,GAAGD,cAAvB;;AACA,mBAAK,IAAIE,MAAM,GAAG,CAAlB,EAAqBA,MAAM,IAAIN,QAAQ,CAACR,SAAxC,EAAmDc,MAAM,EAAzD,EAA6D;AACzD,sBAAMJ,CAAC,GAAGD,CAAC,GAAGK,MAAM,GAAGH,aAAvB;AAAA,sBACII,CAAC,GAAGF,MAAM,IAAIL,QAAQ,CAACR,SAAT,GAAqB,CAAzB,CAAN,GAAoCc,MAD5C;AAEAN,gBAAAA,QAAQ,CAACpB,UAAT,CAAoBC,QAApB,CAA6Be,MAA7B,CAAoC,IAAIW,CAAJ,GAAQ,MAAMjH,OAAN,CAAcoF,WAAW,CAAC,CAAD,CAAzB,CAA5C,IAA6EwB,CAA7E,EACIF,QAAQ,CAACpB,UAAT,CAAoBC,QAApB,CAA6Be,MAA7B,CAAoC,CAAC,CAAD,GAAKW,CAAL,GAAS,MAAMjH,OAAN,CAAcoF,WAAW,CAAC,CAAD,CAAzB,CAA7C,IAA8E,CAACpG,CADnF;AAEH;AACJ;;AACD0H,YAAAA,QAAQ,CAACpB,UAAT,CAAoBC,QAApB,CAA6BX,MAA7B,IAAuClF,OAAO,CAACD,KAAR,CAAc,kBAAd,EAAkC;AACrE8F,cAAAA,QAAQ,EAAEmB,QAAQ,CAACpB,UAAT,CAAoBC;AADuC,aAAlC,CAAvC;AAGH;;AA9DQ;AAFF,OAzF6B;AA4J5C2B,MAAAA,IAAI,EAAE;AACF3F,QAAAA,UAAU,EAAE,CAAC,CADX;AAEFC,QAAAA,KAAK,EAAE,MAAM;AACTnC,UAAAA,WAAW,CAACqH,QAAD,EAAW9E,QAAX,EAAqB;AAC5B,kBAAMuF,IAAI,GAAG,IAAb;AACAA,YAAAA,IAAI,CAACT,QAAL,GAAgBA,QAAhB,EAA0BS,IAAI,CAACvF,QAAL,GAAgBA,QAA1C,EAAoDuF,IAAI,CAACC,SAAL,GAAiB,CAAC,CAAtE,EAAyED,IAAI,CAACE,kBAAL,GAA0B,EAAnG,EAAuGnI,MAAM,CAACuD,OAAP,CAAe0E,IAAI,CAACT,QAAL,CAAcpB,UAA7B,EAAyCtB,OAAzC,CAAiD,CAAC,CAACxD,CAAD,EAAI8G,SAAJ,CAAD,KAAoB;AACxKH,cAAAA,IAAI,CAACE,kBAAL,CAAwBnD,IAAxB,CAA6B;AACzBoD,gBAAAA,SAAS,EAAEA,SADc;AAEzBzH,gBAAAA,QAAQ,EAAEyH,SAAS,CAACC,MAAV,CAAiB/G,CAAjB,EAAoB2G,IAAI,CAACvF,QAAL,CAAc0B,OAAlC;AAFe,eAA7B;AAIH,aALsG,CAAvG,EAKI5D,OAAO,CAACU,MAAR,CAAe8D,IAAf,CAAoBiD,IAApB,CALJ,EAK+BzH,OAAO,CAACD,KAAR,CAAc,kBAAd,EAAkC;AAC7D0H,cAAAA,IAAI,EAAEA;AADuD,aAAlC,CAL/B;AAQH;;AACDK,UAAAA,IAAI,GAAG;AACHnH,YAAAA,OAAO,CAACwD,UAAR,CAAmB,KAAKjC,QAAL,CAAc0B,OAAjC,GAA2C,KAAK1B,QAAL,CAAciB,gBAAd,CAA+BmB,OAA/B,CAAuC,CAAC;AAC/ErB,cAAAA,OAAO,EAAEnC,CADsE;AAE/EX,cAAAA,QAAQ,EAAEb;AAFqE,aAAD,KAG5EwB,CAAC,CAACoE,MAAF,CAAS5F,CAAT,CAHqC,CAA3C,EAGoB,KAAKqI,kBAAL,CAAwBrD,OAAxB,CAAgC,CAAC;AACjDsD,cAAAA,SAAS,EAAE9G,CADsC;AAEjDX,cAAAA,QAAQ,EAAEb;AAFuC,aAAD,KAG9CwB,CAAC,CAACiH,GAAF,CAAMzI,CAAN,CAHc,CAHpB,EAMiBqB,OAAO,CAACqH,YAAR,CAAqB,KAAKN,SAAL,GAAiB/G,OAAO,CAACsH,KAAzB,GAAiCtH,OAAO,CAACuH,SAA9D,EAAyE,KAAKlB,QAAL,CAAcpB,UAAd,CAAyBQ,KAAzB,CAA+BQ,MAA/B,CAAsCtF,MAA/G,EAAuHX,OAAO,CAAC2F,cAA/H,EAA+I,CAA/I,CANjB;AAOH;;AACD6B,UAAAA,MAAM,GAAG;AACLnI,YAAAA,OAAO,CAACU,MAAR,GAAiBV,OAAO,CAACU,MAAR,CAAe0H,MAAf,CAAsBtH,CAAC,IAAIA,CAAC,IAAI,IAAhC,CAAjB;AACH;;AAvBQ;AAFX,OA5JsC;AAwL5CgF,MAAAA,SAAS,EAAE;AACPjE,QAAAA,UAAU,EAAE,CAAC,CADN;AAEPC,QAAAA,KAAK,EAAE,MAAM;AACTnC,UAAAA,WAAW,CAACmB,CAAD,EAAI;AACX,iBAAKsB,IAAL,GAAYzB,OAAO,CAAC0H,KAApB,EAA2B,KAAKC,UAAL,GAAkB,CAAC,CAA9C,EAAiD,KAAKC,MAAL,GAAc5H,OAAO,CAACgF,YAAR,EAA/D,EAAuFnG,MAAM,CAACC,MAAP,CAAc,IAAd,EAAoBqB,CAApB,CAAvF,EAA+G,KAAKoE,MAAL,EAA/G;AACH;;AACDA,UAAAA,MAAM,GAAG;AACL,iBAAK,CAAL,KAAW,KAAK0B,MAAhB,KAA2BjG,OAAO,CAAC6H,UAAR,CAAmB,KAAKzC,MAAxB,EAAgC,KAAKwC,MAArC,GAA8C5H,OAAO,CAAC8H,UAAR,CAAmB,KAAK1C,MAAxB,EAAgC,KAAKa,MAArC,EAA6CjG,OAAO,CAAC+H,WAArD,CAAzE;AACH;;AACDb,UAAAA,MAAM,CAAC/G,CAAD,EAAIxB,CAAJ,EAAO;AACT,kBAAMC,CAAC,GAAGoB,OAAO,CAACgI,iBAAR,CAA0BrJ,CAA1B,EAA6BwB,CAA7B,CAAV;AACA,mBAAO,KAAKiF,MAAL,KAAgBpF,OAAO,CAACqF,YAAxB,KAAyCrF,OAAO,CAACiI,uBAAR,CAAgCrJ,CAAhC,GAAoCoB,OAAO,CAACkI,mBAAR,CAA4BtJ,CAA5B,EAA+B,KAAK0G,IAApC,EAA0C,KAAK7D,IAA/C,EAAqD,KAAKkG,UAA1D,EAAsE,CAAtE,EAAyE,CAAzE,CAA7E,GAA2J/I,CAAlK;AACH;;AACDwI,UAAAA,GAAG,CAACjH,CAAD,EAAI;AACHH,YAAAA,OAAO,CAAC6H,UAAR,CAAmB,KAAKzC,MAAxB,EAAgC,KAAKwC,MAArC,GAA8C,KAAKxC,MAAL,KAAgBpF,OAAO,CAACqF,YAAxB,KAAyCrF,OAAO,CAACiI,uBAAR,CAAgC9H,CAAhC,GAAoCH,OAAO,CAACkI,mBAAR,CAA4B/H,CAA5B,EAA+B,KAAKmF,IAApC,EAA0C,KAAK7D,IAA/C,EAAqD,KAAKkG,UAA1D,EAAsE,CAAtE,EAAyE,CAAzE,CAA7E,CAA9C;AACH;;AAbQ;AAFN;AAxLiC,KAAjC,CAHf;AA8MA,UAAMQ,CAAC,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B,EAA+B,CAA/B,EAAkC,CAAlC,EAAqC,CAArC,EAAwC,CAAxC,EAA2C,CAA3C,EAA8C,CAA9C,CAAV;AACA9I,IAAAA,OAAO,CAACsD,cAAR,GAAyB;AACrByF,MAAAA,gBAAgB,EAAE,IAAI/I,OAAO,CAAC0E,OAAZ,CAAoB;AAClCtC,QAAAA,IAAI,EAAE,MAD4B;AAElCN,QAAAA,KAAK,EAAEgH;AAF2B,OAApB,CADG;AAKrBE,MAAAA,eAAe,EAAE,IAAIhJ,OAAO,CAAC0E,OAAZ,CAAoB;AACjCtC,QAAAA,IAAI,EAAE,MAD2B;AAEjCN,QAAAA,KAAK,EAAEgH;AAF0B,OAApB,CALI;AASrBG,MAAAA,UAAU,EAAE,IAAIjJ,OAAO,CAAC0E,OAAZ,CAAoB;AAC5BtC,QAAAA,IAAI,EAAE,MADsB;AAE5BN,QAAAA,KAAK,EAAE,CAAC,CAAD,EAAI,CAAJ;AAFqB,OAApB,CATS;AAarBoH,MAAAA,WAAW,EAAE,IAAIlJ,OAAO,CAAC0E,OAAZ,CAAoB;AAC7BtC,QAAAA,IAAI,EAAE,OADuB;AAE7BN,QAAAA,KAAK,EAAE;AAFsB,OAApB;AAbQ,KAAzB;AAkBH;;AACDlB,EAAAA,OAAO,CAACE,CAAC,GAAG,GAAL,EAAUxB,CAAC,GAAG,GAAd,EAAmB;AACtB,SAAKO,KAAL,GAAaiB,CAAb,EAAgB,KAAKhB,MAAL,GAAcR,CAA9B,EAAiC,KAAKM,MAAL,CAAYC,KAAZ,GAAoBiB,CAArD,EAAwD,KAAKlB,MAAL,CAAYE,MAAZ,GAAqBR,CAA7E,EAAgF,KAAKiB,EAAL,CAAQ4I,QAAR,CAAiB,CAAjB,EAAoB,CAApB,EAAuBrI,CAAvB,EAA0BxB,CAA1B,CAAhF,EAA8G,KAAKgE,cAAL,CAAoB2F,UAApB,CAA+BnH,KAA/B,GAAuC,CAAChB,CAAD,EAAIxB,CAAJ,CAArJ,EAA6J,KAAKgE,cAAL,CAAoB4F,WAApB,CAAgCpH,KAAhC,GAAwChB,CAAC,GAAGxB,CAAzM,EAA4M,KAAKS,KAAL,CAAW,gBAAX,EAA6B;AACrOF,MAAAA,KAAK,EAAEiB,CAD8N;AAErOhB,MAAAA,MAAM,EAAER;AAF6N,KAA7B,CAA5M;AAIH,GA/OQ,CAgPT;;;AACA8J,EAAAA,qBAAqB,CAACtI,CAAC,GAAG,CAAL,EAAQxB,CAAC,GAAG,CAAZ,EAAeC,CAAC,GAAG,CAAnB,EAAsBgF,CAAC,GAAG,CAAC,GAA3B,EAAgCwC,CAAC,GAAG,GAApC,EAAyC;AAC1D,SAAKzD,cAAL,CAAoByF,gBAApB,CAAqCjH,KAArC,GAA6C,CAAC,IAAI,KAAKjC,KAAV,EAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,EAA6B,IAAI,KAAKC,MAAtC,EAA8C,CAA9C,EAAiD,CAAjD,EAAoD,CAApD,EAAuD,CAAvD,EAA0D,KAAKyE,CAAC,GAAGwC,CAAT,CAA1D,EAAuE,CAAvE,EAA0EjG,CAA1E,EAA6ExB,CAA7E,EAAgFC,CAAhF,EAAmF,CAAnF,CAA7C,EAAoI,KAAKQ,KAAL,CAAW,uBAAX,EAAoC,KAAKuD,cAAL,CAAoByF,gBAApB,CAAqCjH,KAAzE,CAApI;AACH;;AACDuH,EAAAA,MAAM,GAAG;AACL,SAAK9I,EAAL,CAAQ+I,UAAR,CAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B,GAAgC,KAAK/I,EAAL,CAAQgJ,UAAR,CAAmB,CAAnB,CAAhC,EAAuD,KAAK7I,MAAL,CAAY4D,OAAZ,CAAoBxD,CAAC,IAAIA,CAAC,CAACgH,IAAF,EAAzB,CAAvD;AACH;;AAtPQ,C,CA2Pb;;;AACA,SAAShH,CAAT,CAAW0I,MAAX,EAAmBC,YAAnB,EAAiCC,GAAjC,EAAsC;AAClC,SAAOD,YAAY,IAAID,MAAhB,GAAyBhK,MAAM,CAACmK,cAAP,CAAsBH,MAAtB,EAA8BC,YAA9B,EAA4C;AACxE3H,IAAAA,KAAK,EAAE4H,GADiE;AAExE7H,IAAAA,UAAU,EAAE,CAAC,CAF2D;AAGxE+H,IAAAA,YAAY,EAAE,CAAC,CAHyD;AAIxEC,IAAAA,QAAQ,EAAE,CAAC;AAJ6D,GAA5C,CAAzB,GAKFL,MAAM,CAACC,YAAD,CAAN,GAAuBC,GALrB,EAK0BF,MALjC;AAMH,C,CAED;;;AACA,OAAO,MAAMM,QAAN,CAAe;AAClBnK,EAAAA,WAAW,CAAC,GAAGL,CAAJ,EAAO;AACdwB,IAAAA,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,KAAK,CAAlB,CAAD,EAAuBA,CAAC,CAAC,IAAD,EAAO,eAAP,EAAwB,CAAxB,CAAxB,EAAoDA,CAAC,CAAC,IAAD,EAAO,kBAAP,EAA2B,GAA3B,CAArD,EAAsFA,CAAC,CAAC,IAAD,EAAO,OAAP,EAAgB,CAAhB,CAAvF,EAA2GA,CAAC,CAAC,IAAD,EAAO,eAAP,EAAwB,CAAC,CAAzB,CAA5G,EAAyIA,CAAC,CAAC,IAAD,EAAO,aAAP,EAAsB,CAAC,CAAvB,CAA1I;AAAqK;AAAuDA,IAAAA,CAAC,CAAC,IAAD,EAAO,kBAAP,EAA2B,KAAK,CAAhC,CAA7N,EAAiQA,CAAC,CAAC,IAAD,EAAO,uBAAP,EAAgC,GAAhC,CAAlQ,EAAwSA,CAAC,CAAC,IAAD,EAAO,gBAAP,EAAyB,CAAC,CAA1B,CAAzS,EAAuUA,CAAC,CAAC,IAAD,EAAO,aAAP,EAAsB,KAAK,CAA3B,CAAxU,EAAuWA,CAAC,CAAC,IAAD,EAAO,cAAP,EAAuB,KAAK,CAA5B,CAAxW,EAAwYA,CAAC,CAAC,IAAD,EAAO,eAAP,EAAwB,KAAK,CAA7B,CAAzY,EAA0aA,CAAC,CAAC,IAAD,EAAO,qBAAP,EAA8B,KAAK,CAAnC,CAA3a,EAAkdA,CAAC,CAAC,IAAD,EAAO,MAAP,EAAe,KAAK,CAApB,CAAnd,EAA2eA,CAAC,CAAC,IAAD,EAAO,UAAP,EAAmB,KAAK,CAAxB,CAA5e,EAAwgBA,CAAC,CAAC,IAAD,EAAO,GAAP,EAAY,OAAZ,CAAzgB,EAA+hBA,CAAC,CAAC,IAAD,EAAO,MAAP,EAAe,CAAf,CAAhiB,EAAmjBA,CAAC,CAAC,IAAD,EAAO,OAAP,EAAgB,KAAK,CAArB,CAApjB,EAA6kBA,CAAC,CAAC,IAAD,EAAO,UAAP,EAAmB,IAAnB,CAA9kB,EAAwmBA,CAAC,CAAC,IAAD,EAAO,QAAP,EAAiB,GAAjB,CAAzmB,EAAgoBA,CAAC,CAAC,IAAD,EAAO,WAAP,EAAoB,KAAK,CAAzB,CAAjoB,EAA8pBA,CAAC,CAAC,IAAD,EAAO,WAAP,EAAoB,KAAK,CAAzB,CAA/pB,EAA4rBA,CAAC,CAAC,IAAD,EAAO,MAAP,EAAe,KAAK,CAApB,CAA7rB,EAAqtBA,CAAC,CAAC,IAAD,EAAO,UAAP,EAAmB,KAAK,CAAxB,CAAttB,EAAkvBA,CAAC,CAAC,IAAD,EAAO,UAAP,EAAmB,KAAK,CAAxB,CAAnvB,EAA+wBA,CAAC,CAAC,IAAD,EAAO,QAAP,EAAiB,KAAK,CAAtB,CAAhxB,EAA0yBA,CAAC,CAAC,IAAD,EAAO,gBAAP,EAAyB,KAAK,CAA9B,CAA3yB,EAA60BA,CAAC,CAAC,IAAD,EAAO,KAAP,EAAc,GAAd,CAA90B,EAAk2BA,CAAC,CAAC,IAAD,EAAO,MAAP,EAAe,CAAf,CAAn2B,EAAs3BA,CAAC,CAAC,IAAD,EAAO,OAAP,EAAgB,KAAhB,CAAv3B,EAA+4BA,CAAC,CAAC,IAAD,EAAO,OAAP,EAAgB,KAAhB,CAAh5B,EAAw6BA,CAAC,CAAC,IAAD,EAAO,WAAP,EAAoB,IAApB,CAAz6B,EAAo8BA,CAAC,CAAC,IAAD,EAAO,cAAP,EAAuB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAvB,CAAr8B,EAA2+BA,CAAC,CAAC,IAAD,EAAO,WAAP,EAAoB,CAAC,CAArB,CAA5+B,EAAqgCA,CAAC,CAAC,IAAD,EAAO,yBAAP,EAAkC,CAAC,CAAnC,CAAtgC,EAA6iCA,CAAC,CAAC,IAAD,EAAO,aAAP,EAAsB,CAAC,CAAvB,CAA9iC,EAAykCA,CAAC,CAAC,IAAD,EAAO,cAAP,EAAuB,MAAM;AACnmCiJ,MAAAA,YAAY,CAAC,KAAKC,gBAAN,CAAZ,EAAqC,KAAKA,gBAAL,GAAwBC,UAAU,CAAC,KAAKC,eAAN,EAAuB,KAAKC,qBAA5B,CAAvE,EAA2H,KAAKC,uBAAL,IAAgC,KAAKC,kBAAL,EAA3J,EAAsL,KAAKC,IAAL,CAAUC,OAAV,KAAsB,KAAKC,WAAL,GAAmB,CAAC,CAApB,EAAuB,KAAKC,KAAL,EAA7C,CAAtL;AACH,KAFykC,CAA1kC,EAEI3J,CAAC,CAAC,IAAD,EAAO,iBAAP,EAA0B,MAAM;AACjC,WAAK0J,WAAL,GAAmB,CAAC,CAApB,EAAuB,KAAKE,cAAL,IAAuB,KAAKC,IAAL,EAA9C;AACH,KAFI,CAFL,EAII7J,CAAC,CAAC,IAAD,EAAO,QAAP,EAAiB,MAAM;AACxB,WAAKjB,KAAL,GAAa+K,MAAM,CAACC,UAApB,EAAgC,KAAKC,MAAL,CAAYlK,OAAZ,CAAoB,KAAKf,KAAzB,EAAgC,KAAKC,MAArC,CAAhC,EAA8E,KAAKgL,MAAL,CAAY1B,qBAAZ,EAA9E,EAAmH,KAAK5C,SAAL,GAAiBpF,IAAI,CAAC2J,IAAL,CAAU,KAAKlL,KAAL,GAAa,KAAKyK,IAAL,CAAUU,OAAV,CAAkB,CAAlB,CAAvB,CAApI,EAAkL,KAAKvE,SAAL,GAAiBrF,IAAI,CAAC2J,IAAL,CAAU,KAAKjL,MAAL,GAAc,KAAKwK,IAAL,CAAUU,OAAV,CAAkB,CAAlB,CAAxB,CAAnM,EAAkP,KAAKvD,IAAL,CAAUT,QAAV,CAAmBT,WAAnB,CAA+B,KAAKC,SAApC,EAA+C,KAAKC,SAApD,CAAlP,EAAkT,KAAKgB,IAAL,CAAUT,QAAV,CAAmBpG,OAAnB,CAA2B,KAAKf,KAAhC,EAAuC,KAAKC,MAA5C,CAAlT,EAAuW,KAAK2H,IAAL,CAAUvF,QAAV,CAAmBD,QAAnB,CAA4BgJ,cAA5B,CAA2CnJ,KAA3C,GAAmD,KAAKjC,KAAL,GAAa,GAAb,GAAmB,CAAnB,GAAuB,CAAjb;AACH,KAFI,CAJL,EAMIiB,CAAC,CAAC,IAAD,EAAO,iBAAP,EAA0BA,CAAC,IAAI;AAChC,WAAKsJ,uBAAL,KAAiC,KAAKc,SAAL,GAAiBpK,CAAC,CAACqK,OAAnB,EAA4B,KAAKC,WAAL,GAAmB,CAAC,CAAhD,EAAmD,CAAC,CAAD,KAAO,KAAKd,IAAL,CAAUC,OAAjB,IAA4Bc,qBAAqB,CAAC,KAAKC,OAAN,CAArI;AACH,KAFI,CANL,EAQIxK,CAAC,CAAC,IAAD,EAAO,eAAP,EAAwB,MAAM;AAC/B,WAAKsK,WAAL,GAAmB,CAAC,CAApB;AACH,KAFI,CARL,EAUItK,CAAC,CAAC,IAAD,EAAO,SAAP,EAAkBA,CAAC,IAAI;AACxB,UAAI,CAAC,KAAKyK,eAAL,CAAqBzK,CAArB,CAAD,IAA4B,KAAKsK,WAArC,EAAkD;AAC9C,YAAI,KAAK9L,CAAL,IAAU8B,IAAI,CAACoK,GAAL,CAAS1K,CAAC,GAAG,KAAK2K,IAAlB,EAAwB,MAAM,EAA9B,CAAV,EAA6C,KAAKA,IAAL,GAAY3K,CAAzD,EAA4D,KAAKsK,WAArE,EAAkF;AAC9E,cAAItK,CAAC,GAAG,GAAR;AACA,eAAKoK,SAAL,KAAmBpK,CAAC,GAAG,CAAC,GAAxB,GAA8B,KAAKxB,CAAL,IAAUwB,CAAxC;AACH;;AACD,aAAK2G,IAAL,CAAUvF,QAAV,CAAmBD,QAAnB,CAA4ByJ,MAA5B,CAAmC5J,KAAnC,GAA2C,KAAKxC,CAAhD,EAAmD,KAAKwL,MAAL,CAAYzB,MAAZ,EAAnD;AAEH;;AACD,UAAI,MAAM,KAAKoC,IAAX,IAAmB,KAAKE,QAA5B,EAAsC,OAAO,KAAKb,MAAL,CAAYzB,MAAZ,IAAsB,KAAK,KAAKuC,UAAL,EAAlC;AACtC;AAAC;AAA2B,WAAKtB,IAAL,CAAUC,OAAV,IAAqB,KAAKa,WAAtD,KAAsEC,qBAAqB,CAAC,KAAKC,OAAN,CAA3F;AACH,KAXI,CAVL,EAqBIxK,CAAC,CAAC,IAAD,EAAO,kBAAP,EAA2B,MAAM;AAClC;AAA2B,OAAC,KAAK+K,aAAN,KAAwB,KAAKA,aAAL,GAAqB,CAAC,CAAtB,EAAyB,KAAKC,EAAL,CAAQC,SAAR,CAAkBC,GAAlB,CAAsB,UAAtB,CAAzB,EAA4D/B,UAAU,CAAC,MAAM;AAChI,aAAK6B,EAAL,CAAQG,aAAR,CAAsBF,SAAtB,CAAgCC,GAAhC,CAAoC,UAApC;AACH,OAF4H,EAE1H,GAF0H,CAA9F;AAG9B,KAJI,CArBL,EAyBIlL,CAAC,CAAC,IAAD,EAAO,OAAP,EAAgB,MAAM;AACvB,WAAKwJ,IAAL,CAAUC,OAAV,GAAoB,KAApB;AACH,KAFI,CAzBL,EA2BIzJ,CAAC,CAAC,IAAD,EAAO,MAAP,EAAe,MAAM;AACtBuK,MAAAA,qBAAqB,CAAC,KAAKC,OAAN,CAArB,EAAqC,KAAKhB,IAAL,CAAUC,OAAV,GAAoB,IAAzD;AACH,KAFI,CA3BL,EA6BIzJ,CAAC,CAAC,IAAD,EAAO,cAAP,EAAwBoL,QAAD,IAAc;AACtC,WAAKJ,EAAL,GAAU5L,QAAQ,CAACiM,aAAT,CAAuBD,QAAvB,CAAV;AACA,WAAKE,OAAL;AACA,aAAO,IAAP;AACH,KAJI,CA7BL;AAkCH;;AACD,QAAMA,OAAN,GAAgB;AACZ,SAAKC,WAAL,GAAmB;AACfC,MAAAA,MAAM,EAAE,uzDADO;AAEfC,MAAAA,KAAK,EAAE,u7FAFQ;AAGfC,MAAAA,KAAK,EAAE,kiKAHQ;AAIfC,MAAAA,QAAQ,EAAE;AAJK,KAAnB,EAMI,KAAKnC,IAAL,GAAY;AACRoC,MAAAA,UAAU,EAAE,EADJ;AAERhF,MAAAA,SAAS,EAAE,KAFH;AAGRsD,MAAAA,OAAO,EAAE,CAAC,GAAD,EAAM,GAAN,CAHD;AAIR2B,MAAAA,IAAI,EAAE,CAJE;AAKRC,MAAAA,QAAQ,EAAE,CALF;AAMRrC,MAAAA,OAAO,EAAE;AAND,KANhB,EAcIrK,QAAQ,CAAC2M,gBAAT,CAA0B,QAA1B,EAAoCvL,MAApC,GAA6C,CAA7C,GAAiDN,OAAO,CAACC,GAAR,CAAY,iCAAZ,CAAjD,IAEI,KAAK6J,MAAL,GAAc,IAAIpL,MAAJ,CAAW,KAAKoM,EAAhB,EAAoB,IAApB,EAA0B,IAA1B,EAAgC,CAAC,CAAjC,CAAd,EACAT,qBAAqB,CAAC,MAAM;AACxB,WAAKS,EAAL,KAAY,KAAKgB,mBAAL,GAA2BC,gBAAgB,CAAC,KAAKjB,EAAN,CAA3C,EAAsD,KAAKkB,cAAL,EAAlE;AACH,KAFoB;AAGrB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdY,KAdJ;AA+BH;;AACDpB,EAAAA,UAAU,GAAG;AACT,SAAKqB,cAAL,KAAwBrC,MAAM,CAACsC,mBAAP,CAA2B,QAA3B,EAAqC,KAAKC,YAA1C,GAAyDvC,MAAM,CAACsC,mBAAP,CAA2B,WAA3B,EAAwC,KAAKE,eAA7C,CAAzD,EAAwHxC,MAAM,CAACsC,mBAAP,CAA2B,SAA3B,EAAsC,KAAKG,aAA3C,CAAxH,EAAmLzC,MAAM,CAACsC,mBAAP,CAA2B,SAA3B,EAAsC,KAAKI,aAA3C,CAAnL,EAA8O,KAAKL,cAAL,CAAoBrB,UAApB,EAAtQ,GAAyShB,MAAM,CAACsC,mBAAP,CAA2B,QAA3B,EAAqC,KAAKK,MAA1C,CAAzS;AACH;;AACDC,EAAAA,YAAY,GAAG;AACX,SAAKvL,QAAL,GAAgB;AACZyJ,MAAAA,MAAM,EAAE,IAAI,KAAKZ,MAAL,CAAYpG,OAAhB,CAAwB;AAC5B5C,QAAAA,KAAK,EAAE;AADqB,OAAxB,CADI;AAIZmJ,MAAAA,cAAc,EAAE,IAAI,KAAKH,MAAL,CAAYpG,OAAhB,CAAwB;AACpC5C,QAAAA,KAAK,EAAE;AAD6B,OAAxB,CAJJ;AAOZ2L,MAAAA,YAAY,EAAE,IAAI,KAAK3C,MAAL,CAAYpG,OAAhB,CAAwB;AAClC5C,QAAAA,KAAK,EAAE,OAAO,KAAKgK,EAAL,CAAQ4B,OAAR,CAAgBC,WAAvB,GAAqC,CAArC,GAAyC;AADd,OAAxB,CAPF;AAUZC,MAAAA,eAAe,EAAE,IAAI,KAAK9C,MAAL,CAAYpG,OAAhB,CAAwB;AACrC5C,QAAAA,KAAK,EAAE,KAAK+L,YADyB;AAErCzL,QAAAA,IAAI,EAAE;AAF+B,OAAxB,CAVL;AAcZ0L,MAAAA,QAAQ,EAAE,IAAI,KAAKhD,MAAL,CAAYpG,OAAhB,CAAwB;AAC9B5C,QAAAA,KAAK,EAAE;AACHiM,UAAAA,SAAS,EAAE,IAAI,KAAKjD,MAAL,CAAYpG,OAAhB,CAAwB;AAC/B5C,YAAAA,KAAK,EAAE,CAAC,KAAKkM,KAAN,EAAa,KAAKC,KAAlB,CADwB;AAE/B7L,YAAAA,IAAI,EAAE;AAFyB,WAAxB,CADR;AAKH8L,UAAAA,UAAU,EAAE,IAAI,KAAKpD,MAAL,CAAYpG,OAAhB,CAAwB;AAChC5C,YAAAA,KAAK,EAAE;AADyB,WAAxB;AALT,SADuB;AAU9BM,QAAAA,IAAI,EAAE;AAVwB,OAAxB,CAdE;AA0BZ+L,MAAAA,YAAY,EAAE,IAAI,KAAKrD,MAAL,CAAYpG,OAAhB,CAAwB;AAClC5C,QAAAA,KAAK,EAAE;AACHsM,UAAAA,OAAO,EAAE,IAAI,KAAKtD,MAAL,CAAYpG,OAAhB,CAAwB;AAC7B5C,YAAAA,KAAK,EAAEV,IAAI,CAACiN,GAAL,CAAS,KAAKC,KAAd,IAAuBlN,IAAI,CAACmN,GAAL,CAAS,KAAKD,KAAd;AADD,WAAxB,CADN;AAIHE,UAAAA,SAAS,EAAE,IAAI,KAAK1D,MAAL,CAAYpG,OAAhB,CAAwB;AAC/B5C,YAAAA,KAAK,EAAE,CAAC;AADuB,WAAxB,CAJR;AAOH2M,UAAAA,YAAY,EAAE,IAAI,KAAK3D,MAAL,CAAYpG,OAAhB,CAAwB;AAClC5C,YAAAA,KAAK,EAAE,CAAC;AAD0B,WAAxB,CAPX;AAUHiM,UAAAA,SAAS,EAAE,IAAI,KAAKjD,MAAL,CAAYpG,OAAhB,CAAwB;AAC/B5C,YAAAA,KAAK,EAAE,CAAC,CAAD,EAAI,CAAJ,CADwB;AAE/BM,YAAAA,IAAI,EAAE;AAFyB,WAAxB,CAVR;AAcHsM,UAAAA,QAAQ,EAAE,IAAI,KAAK5D,MAAL,CAAYpG,OAAhB,CAAwB;AAC9B5C,YAAAA,KAAK,EAAE,KAAK6M;AADkB,WAAxB,CAdP;AAiBHT,UAAAA,UAAU,EAAE,IAAI,KAAKpD,MAAL,CAAYpG,OAAhB,CAAwB;AAChC5C,YAAAA,KAAK,EAAE;AADyB,WAAxB,CAjBT;AAoBH8M,UAAAA,SAAS,EAAE,IAAI,KAAK9D,MAAL,CAAYpG,OAAhB,CAAwB;AAC/B5C,YAAAA,KAAK,EAAE;AADwB,WAAxB,CApBR;AAuBH+M,UAAAA,SAAS,EAAE,IAAI,KAAK/D,MAAL,CAAYpG,OAAhB,CAAwB;AAC/B5C,YAAAA,KAAK,EAAE,KAAKgN;AADmB,WAAxB;AAvBR,SAD2B;AA4BlC1M,QAAAA,IAAI,EAAE,QA5B4B;AA6BlCgD,QAAAA,WAAW,EAAE;AA7BqB,OAAxB,CA1BF;AAyDZ2J,MAAAA,WAAW,EAAE,IAAI,KAAKjE,MAAL,CAAYpG,OAAhB,CAAwB;AACjC5C,QAAAA,KAAK,EAAE,KAAKkN,aAAL,CAAmB,CAAnB,CAD0B;AAEjC5M,QAAAA,IAAI,EAAE,MAF2B;AAGjCgD,QAAAA,WAAW,EAAE;AAHoB,OAAxB,CAzDD;AA8DZ6J,MAAAA,YAAY,EAAE,IAAI,KAAKnE,MAAL,CAAYpG,OAAhB,CAAwB;AAClC5C,QAAAA,KAAK,EAAE,EAD2B;AAElCsD,QAAAA,WAAW,EAAE,UAFqB;AAGlChD,QAAAA,IAAI,EAAE;AAH4B,OAAxB;AA9DF,KAAhB;;AAoEA,SAAK,IAAItB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKkO,aAAL,CAAmB1N,MAAvC,EAA+CR,CAAC,IAAI,CAApD,EAAuD,KAAKmB,QAAL,CAAcgN,YAAd,CAA2BnN,KAA3B,CAAiC0C,IAAjC,CAAsC,IAAI,KAAKsG,MAAL,CAAYpG,OAAhB,CAAwB;AACjH5C,MAAAA,KAAK,EAAE;AACHoN,QAAAA,KAAK,EAAE,IAAI,KAAKpE,MAAL,CAAYpG,OAAhB,CAAwB;AAC3B5C,UAAAA,KAAK,EAAE,KAAKkN,aAAL,CAAmBlO,CAAnB,CADoB;AAE3BsB,UAAAA,IAAI,EAAE;AAFqB,SAAxB,CADJ;AAKH2L,QAAAA,SAAS,EAAE,IAAI,KAAKjD,MAAL,CAAYpG,OAAhB,CAAwB;AAC/B5C,UAAAA,KAAK,EAAE,CAAC,IAAIhB,CAAC,GAAG,KAAKkO,aAAL,CAAmB1N,MAA5B,EAAoC,IAAIR,CAAC,GAAG,KAAKkO,aAAL,CAAmB1N,MAA/D,CADwB;AAE/Bc,UAAAA,IAAI,EAAE;AAFyB,SAAxB,CALR;AASH8L,QAAAA,UAAU,EAAE,IAAI,KAAKpD,MAAL,CAAYpG,OAAhB,CAAwB;AAChC5C,UAAAA,KAAK,EAAE,KAAK,KAAKhB;AADe,SAAxB,CATT;AAYH8N,QAAAA,SAAS,EAAE,IAAI,KAAK9D,MAAL,CAAYpG,OAAhB,CAAwB;AAC/B5C,UAAAA,KAAK,EAAE,MAAM,KAAKhB;AADa,SAAxB,CAZR;AAeH+N,QAAAA,SAAS,EAAE,IAAI,KAAK/D,MAAL,CAAYpG,OAAhB,CAAwB;AAC/B5C,UAAAA,KAAK,EAAE,KAAKgN,IAAL,GAAY,KAAKhO;AADO,SAAxB,CAfR;AAkBHqO,QAAAA,UAAU,EAAE,IAAI,KAAKrE,MAAL,CAAYpG,OAAhB,CAAwB;AAChC5C,UAAAA,KAAK,EAAE;AADyB,SAAxB,CAlBT;AAqBHsN,QAAAA,SAAS,EAAE,IAAI,KAAKtE,MAAL,CAAYpG,OAAhB,CAAwB;AAC/B5C,UAAAA,KAAK,EAAE,MAAM,MAAMhB;AADY,SAAxB;AArBR,OAD0G;AA0BjHsB,MAAAA,IAAI,EAAE;AA1B2G,KAAxB,CAAtC;;AA4BvD,WAAO,KAAKoB,YAAL,GAAoB,CAAC,KAAK6I,WAAL,CAAiBE,KAAlB,EAAyB,KAAKF,WAAL,CAAiBG,KAA1C,EAAiD,KAAKH,WAAL,CAAiBC,MAAlE,EAA0E/K,IAA1E,CAA+E,MAA/E,CAApB,EAA4G,IAAI,KAAKuJ,MAAL,CAAYlJ,QAAhB,CAAyB,KAAK4B,YAA9B,EAA4C,KAAK6I,WAAL,CAAiBI,QAA7D,EAAuE,KAAKxK,QAA5E,CAAnH;AACH;;AACDoN,EAAAA,QAAQ,GAAG;AACP,SAAKnN,QAAL,GAAgB,KAAKsL,YAAL,EAAhB,EAAqC,KAAKxG,QAAL,GAAgB,IAAI,KAAK8D,MAAL,CAAYrF,aAAhB,EAArD,EAAoF,KAAKgC,IAAL,GAAY,IAAI,KAAKqD,MAAL,CAAYtD,IAAhB,CAAqB,KAAKR,QAA1B,EAAoC,KAAK9E,QAAzC,CAAhG;AACH;;AACDqJ,EAAAA,eAAe,CAACzK,CAAD,EAAI;AACf,WAAO,CAAC,CAAC8J,MAAM,CAAC1K,QAAP,CAAgBoP,MAAlB,IAA6B,CAAC,KAAKhF,IAAL,CAAUC,OAAX,IAAuBgF,QAAQ,CAACzO,CAAD,EAAI,EAAJ,CAAR,GAAkB,CAAlB,IAAuB,CAAvB,IAA4B,KAAK,CAA5F;AACH;;AACD0O,EAAAA,eAAe,CAAC1O,CAAD,EAAI;AACf,SAAKkN,KAAL,IAAclN,CAAd,EAAiB,KAAKmN,KAAL,IAAcnN,CAA/B;AACH;;AACD2O,EAAAA,WAAW,CAACrJ,KAAD,EAAQ;AACf,SAAKyH,YAAL,CAAkBzH,KAAlB,IAA2B,MAAM,KAAKyH,YAAL,CAAkBzH,KAAlB,CAAN,GAAiC,CAAjC,GAAqC,CAAhE;AACH;;AACDsJ,EAAAA,kBAAkB,GAAG;AACjB,SAAK7P,KAAL,GAAa,KAAK8P,QAAlB,KAA+B,KAAKvF,uBAAL,GAA+B,CAAC,CAAhC,EAAmClK,QAAQ,CAAC0P,IAAT,CAAc7D,SAAd,CAAwBC,GAAxB,CAA4B,yBAA5B,CAAlE;AACH;;AACD3B,EAAAA,kBAAkB,GAAG;AACjB,SAAKD,uBAAL,GAA+B,CAAC,CAAhC,EAAmClK,QAAQ,CAAC0P,IAAT,CAAc7D,SAAd,CAAwB5D,MAAxB,CAA+B,yBAA/B,CAAnC;AACH;;AACD0H,EAAAA,IAAI,GAAG;AACH,SAAKC,kBAAL,IAA2B,KAAKT,QAAL,EAA3B,EAA4C,KAAK9B,MAAL,EAA5C,EAA2DlC,qBAAqB,CAAC,KAAKC,OAAN,CAAhF,EAAgGV,MAAM,CAACmF,gBAAP,CAAwB,QAAxB,EAAkC,KAAKxC,MAAvC,CAAhG;AACH;AACD;AACJ;AACA;AACA;;;AACIP,EAAAA,cAAc,GAAG;AACb,QAAI,KAAKF,mBAAL,IAA4B,CAAC,CAAD,KAAO,KAAKA,mBAAL,CAAyBkD,gBAAzB,CAA0C,oBAA1C,EAAgE1P,OAAhE,CAAwE,GAAxE,CAAvC,EAAqH,KAAKuP,IAAL,IAAa,KAAKI,gBAAL,EAAb,CAArH,KACK;AACD,UAAI,KAAKC,aAAL,IAAsB,CAAtB,EAAyB,KAAKA,aAAL,GAAqB,KAAKC,gBAAvD,EAAyE;AACrE,eAAO,KAAKnB,aAAL,GAAqB,CAAC,QAAD,EAAW,QAAX,EAAqB,QAArB,EAA+B,KAA/B,EAAsC,GAAtC,CAArB,EAAiE,KAAK,KAAKa,IAAL,EAA7E;AACH;;AACDxE,MAAAA,qBAAqB,CAAC,MAAM,KAAK2B,cAAL,EAAP,CAArB;AACH;AACJ;AACD;AACJ;AACA;;;AACI8C,EAAAA,kBAAkB,GAAG;AACjB,SAAKd,aAAL,GAAqB,CAAC,oBAAD,EAAuB,oBAAvB,EAA6C,oBAA7C,EAAmE,oBAAnE,EAAyFhM,GAAzF,CAA6FoN,eAAe,IAAI;AACjI,UAAIC,GAAG,GAAG,KAAKvD,mBAAL,CAAyBkD,gBAAzB,CAA0CI,eAA1C,EAA2DE,IAA3D,EAAV,CADiI,CAEjI;;AACA,UAAI,MAAMD,GAAG,CAAC/O,MAAd,EAAsB;AAClB,cAAMiP,OAAO,GAAGF,GAAG,CAACG,MAAJ,CAAW,CAAX,EAAcC,KAAd,CAAoB,EAApB,EAAwBzN,GAAxB,CAA4BuN,OAAO,IAAIA,OAAO,GAAGA,OAAjD,EAA0DhP,IAA1D,CAA+D,EAA/D,CAAhB;AACA8O,QAAAA,GAAG,GAAI,IAAGE,OAAQ,EAAlB;AACH;;AACD,aAAOF,GAAG,IAAK,KAAIA,GAAG,CAACG,MAAJ,CAAW,CAAX,CAAc,EAAjC;AACH,KARoB,EAQlBpI,MARkB,CAQXsI,OARW,EAQF1N,GARE,CAQE7D,cARF,CAArB;AASH;;AA3NiB;AAiOtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["\n/*\n*   Stripe WebGl Gradient Animation\n*   All Credits to Stripe.com\n*   ScrollObserver functionality to disable animation when not scrolled into view has been disabled and \n*   commented out for now.\n*   https://kevinhufnagl.com\n*/\n\n\n//Converting colors to proper format\nfunction normalizeColor(hexCode) {\n    return [(hexCode >> 16 & 255) / 255, (hexCode >> 8 & 255) / 255, (255 & hexCode) / 255]\n} [\"SCREEN\", \"LINEAR_LIGHT\"].reduce((hexCode, t, n) => Object.assign(hexCode, {\n    [t]: n\n}), {});\n\n//Essential functionality of WebGl\n//t = width\n//n = height\nclass MiniGl {\n    constructor(canvas, width, height, debug = false) {\n        const _miniGl = this,\n            debug_output = -1 !== document.location.search.toLowerCase().indexOf(\"debug=webgl\");\n        _miniGl.canvas = canvas, _miniGl.gl = _miniGl.canvas.getContext(\"webgl\", {\n            antialias: true\n        }), _miniGl.meshes = [];\n        const context = _miniGl.gl;\n        width && height && this.setSize(width, height), _miniGl.lastDebugMsg, _miniGl.debug = debug && debug_output ? function (e) {\n            const t = new Date;\n            t - _miniGl.lastDebugMsg > 1e3 && console.log(\"---\"), console.log(t.toLocaleTimeString() + Array(Math.max(0, 32 - e.length)).join(\" \") + e + \": \", ...Array.from(arguments).slice(1)), _miniGl.lastDebugMsg = t\n        } : () => { }, Object.defineProperties(_miniGl, {\n            Material: {\n                enumerable: false,\n                value: class {\n                    constructor(vertexShaders, fragments, uniforms = {}) {\n                        const material = this;\n                        function getShaderByType(type, source) {\n                            const shader = context.createShader(type);\n                            return context.shaderSource(shader, source), context.compileShader(shader), context.getShaderParameter(shader, context.COMPILE_STATUS) || console.error(context.getShaderInfoLog(shader)), _miniGl.debug(\"Material.compileShaderSource\", {\n                                source: source\n                            }), shader\n                        }\n                        function getUniformVariableDeclarations(uniforms, type) {\n                            return Object.entries(uniforms).map(([uniform, value]) => value.getDeclaration(uniform, type)).join(\"\\n\")\n                        }\n                        material.uniforms = uniforms, material.uniformInstances = [];\n\n                        const prefix = \"\\n              precision highp float;\\n            \";\n                        material.vertexSource = `\\n              ${prefix}\\n              attribute vec4 position;\\n              attribute vec2 uv;\\n              attribute vec2 uvNorm;\\n              ${getUniformVariableDeclarations(_miniGl.commonUniforms, \"vertex\")}\\n              ${getUniformVariableDeclarations(uniforms, \"vertex\")}\\n              ${vertexShaders}\\n            `,\n                            material.Source = `\\n              ${prefix}\\n              ${getUniformVariableDeclarations(_miniGl.commonUniforms, \"fragment\")}\\n              ${getUniformVariableDeclarations(uniforms, \"fragment\")}\\n              ${fragments}\\n            `,\n                            material.vertexShader = getShaderByType(context.VERTEX_SHADER, material.vertexSource),\n                            material.fragmentShader = getShaderByType(context.FRAGMENT_SHADER, material.Source),\n                            material.program = context.createProgram(),\n                            context.attachShader(material.program, material.vertexShader),\n                            context.attachShader(material.program, material.fragmentShader),\n                            context.linkProgram(material.program),\n                            context.getProgramParameter(material.program, context.LINK_STATUS) || console.error(context.getProgramInfoLog(material.program)),\n                            context.useProgram(material.program),\n                            material.attachUniforms(void 0, _miniGl.commonUniforms),\n                            material.attachUniforms(void 0, material.uniforms)\n                    }\n                    //t = uniform\n                    attachUniforms(name, uniforms) {\n                        //n  = material\n                        const material = this;\n                        void 0 === name ? Object.entries(uniforms).forEach(([name, uniform]) => {\n                            material.attachUniforms(name, uniform)\n                        }) : \"array\" == uniforms.type ? uniforms.value.forEach((uniform, i) => material.attachUniforms(`${name}[${i}]`, uniform)) : \"struct\" == uniforms.type ? Object.entries(uniforms.value).forEach(([uniform, i]) => material.attachUniforms(`${name}.${uniform}`, i)) : (_miniGl.debug(\"Material.attachUniforms\", {\n                            name: name,\n                            uniform: uniforms\n                        }), material.uniformInstances.push({\n                            uniform: uniforms,\n                            location: context.getUniformLocation(material.program, name)\n                        }))\n                    }\n                }\n            },\n            Uniform: {\n                enumerable: !1,\n                value: class {\n                    constructor(e) {\n                        this.type = \"float\", Object.assign(this, e);\n                        this.typeFn = {\n                            float: \"1f\",\n                            int: \"1i\",\n                            vec2: \"2fv\",\n                            vec3: \"3fv\",\n                            vec4: \"4fv\",\n                            mat4: \"Matrix4fv\"\n                        }[this.type] || \"1f\", this.update()\n                    }\n                    update(value) {\n                        void 0 !== this.value && context[`uniform${this.typeFn}`](value, 0 === this.typeFn.indexOf(\"Matrix\") ? this.transpose : this.value, 0 === this.typeFn.indexOf(\"Matrix\") ? this.value : null)\n                    }\n                    //e - name\n                    //t - type\n                    //n - length\n                    getDeclaration(name, type, length) {\n                        const uniform = this;\n                        if (uniform.excludeFrom !== type) {\n                            if (\"array\" === uniform.type) return uniform.value[0].getDeclaration(name, type, uniform.value.length) + `\\nconst int ${name}_length = ${uniform.value.length};`;\n                            if (\"struct\" === uniform.type) {\n                                let name_no_prefix = name.replace(\"u_\", \"\");\n                                return name_no_prefix =\n                                    name_no_prefix.charAt(0).toUpperCase() +\n                                    name_no_prefix.slice(1),\n                                    `uniform struct ${name_no_prefix} \n                                  {\\n` +\n                                    Object.entries(uniform.value).map(([name, uniform]) =>\n                                        uniform.getDeclaration(name, type)\n                                            .replace(/^uniform/, \"\"))\n                                        .join(\"\")\n                                    + `\\n} ${name}${length > 0 ? `[${length}]` : \"\"};`\n                            }\n                            return `uniform ${uniform.type} ${name}${length > 0 ? `[${length}]` : \"\"};`\n                        }\n                    }\n                }\n            },\n            PlaneGeometry: {\n                enumerable: !1,\n                value: class {\n                    constructor(width, height, n, i, orientation) {\n                        context.createBuffer(), this.attributes = {\n                            position: new _miniGl.Attribute({\n                                target: context.ARRAY_BUFFER,\n                                size: 3\n                            }),\n                            uv: new _miniGl.Attribute({\n                                target: context.ARRAY_BUFFER,\n                                size: 2\n                            }),\n                            uvNorm: new _miniGl.Attribute({\n                                target: context.ARRAY_BUFFER,\n                                size: 2\n                            }),\n                            index: new _miniGl.Attribute({\n                                target: context.ELEMENT_ARRAY_BUFFER,\n                                size: 3,\n                                type: context.UNSIGNED_SHORT\n                            })\n                        }, this.setTopology(n, i), this.setSize(width, height, orientation)\n                    }\n                    setTopology(e = 1, t = 1) {\n                        const n = this;\n                        n.xSegCount = e, n.ySegCount = t, n.vertexCount = (n.xSegCount + 1) * (n.ySegCount + 1), n.quadCount = n.xSegCount * n.ySegCount * 2, n.attributes.uv.values = new Float32Array(2 * n.vertexCount), n.attributes.uvNorm.values = new Float32Array(2 * n.vertexCount), n.attributes.index.values = new Uint16Array(3 * n.quadCount);\n                        for (let e = 0; e <= n.ySegCount; e++)\n                            for (let t = 0; t <= n.xSegCount; t++) {\n                                const i = e * (n.xSegCount + 1) + t;\n                                if (n.attributes.uv.values[2 * i] = t / n.xSegCount, n.attributes.uv.values[2 * i + 1] = 1 - e / n.ySegCount, n.attributes.uvNorm.values[2 * i] = t / n.xSegCount * 2 - 1, n.attributes.uvNorm.values[2 * i + 1] = 1 - e / n.ySegCount * 2, t < n.xSegCount && e < n.ySegCount) {\n                                    const s = e * n.xSegCount + t;\n                                    n.attributes.index.values[6 * s] = i, n.attributes.index.values[6 * s + 1] = i + 1 + n.xSegCount, n.attributes.index.values[6 * s + 2] = i + 1, n.attributes.index.values[6 * s + 3] = i + 1, n.attributes.index.values[6 * s + 4] = i + 1 + n.xSegCount, n.attributes.index.values[6 * s + 5] = i + 2 + n.xSegCount\n                                }\n                            }\n                        n.attributes.uv.update(), n.attributes.uvNorm.update(), n.attributes.index.update(), _miniGl.debug(\"Geometry.setTopology\", {\n                            uv: n.attributes.uv,\n                            uvNorm: n.attributes.uvNorm,\n                            index: n.attributes.index\n                        })\n                    }\n                    setSize(width = 1, height = 1, orientation = \"xz\") {\n                        const geometry = this;\n                        geometry.width = width,\n                            geometry.height = height,\n                            geometry.orientation = orientation,\n                            geometry.attributes.position.values && geometry.attributes.position.values.length === 3 * geometry.vertexCount\n                            || (geometry.attributes.position.values = new Float32Array(3 * geometry.vertexCount));\n                        const o = width / -2,\n                            r = height / -2,\n                            segment_width = width / geometry.xSegCount,\n                            segment_height = height / geometry.ySegCount;\n                        for (let yIndex = 0; yIndex <= geometry.ySegCount; yIndex++) {\n                            const t = r + yIndex * segment_height;\n                            for (let xIndex = 0; xIndex <= geometry.xSegCount; xIndex++) {\n                                const r = o + xIndex * segment_width,\n                                    l = yIndex * (geometry.xSegCount + 1) + xIndex;\n                                geometry.attributes.position.values[3 * l + \"xyz\".indexOf(orientation[0])] = r,\n                                    geometry.attributes.position.values[-3 * l + \"xyz\".indexOf(orientation[1])] = -t\n                            }\n                        }\n                        geometry.attributes.position.update(), _miniGl.debug(\"Geometry.setSize\", {\n                            position: geometry.attributes.position\n                        })\n                    }\n                }\n            },\n            Mesh: {\n                enumerable: !1,\n                value: class {\n                    constructor(geometry, material) {\n                        const mesh = this;\n                        mesh.geometry = geometry, mesh.material = material, mesh.wireframe = !1, mesh.attributeInstances = [], Object.entries(mesh.geometry.attributes).forEach(([e, attribute]) => {\n                            mesh.attributeInstances.push({\n                                attribute: attribute,\n                                location: attribute.attach(e, mesh.material.program)\n                            })\n                        }), _miniGl.meshes.push(mesh), _miniGl.debug(\"Mesh.constructor\", {\n                            mesh: mesh\n                        })\n                    }\n                    draw() {\n                        context.useProgram(this.material.program), this.material.uniformInstances.forEach(({\n                            uniform: e,\n                            location: t\n                        }) => e.update(t)), this.attributeInstances.forEach(({\n                            attribute: e,\n                            location: t\n                        }) => e.use(t)), context.drawElements(this.wireframe ? context.LINES : context.TRIANGLES, this.geometry.attributes.index.values.length, context.UNSIGNED_SHORT, 0)\n                    }\n                    remove() {\n                        _miniGl.meshes = _miniGl.meshes.filter(e => e != this)\n                    }\n                }\n            },\n            Attribute: {\n                enumerable: !1,\n                value: class {\n                    constructor(e) {\n                        this.type = context.FLOAT, this.normalized = !1, this.buffer = context.createBuffer(), Object.assign(this, e), this.update()\n                    }\n                    update() {\n                        void 0 !== this.values && (context.bindBuffer(this.target, this.buffer), context.bufferData(this.target, this.values, context.STATIC_DRAW))\n                    }\n                    attach(e, t) {\n                        const n = context.getAttribLocation(t, e);\n                        return this.target === context.ARRAY_BUFFER && (context.enableVertexAttribArray(n), context.vertexAttribPointer(n, this.size, this.type, this.normalized, 0, 0)), n\n                    }\n                    use(e) {\n                        context.bindBuffer(this.target, this.buffer), this.target === context.ARRAY_BUFFER && (context.enableVertexAttribArray(e), context.vertexAttribPointer(e, this.size, this.type, this.normalized, 0, 0))\n                    }\n                }\n            }\n        });\n        const a = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n        _miniGl.commonUniforms = {\n            projectionMatrix: new _miniGl.Uniform({\n                type: \"mat4\",\n                value: a\n            }),\n            modelViewMatrix: new _miniGl.Uniform({\n                type: \"mat4\",\n                value: a\n            }),\n            resolution: new _miniGl.Uniform({\n                type: \"vec2\",\n                value: [1, 1]\n            }),\n            aspectRatio: new _miniGl.Uniform({\n                type: \"float\",\n                value: 1\n            })\n        }\n    }\n    setSize(e = 640, t = 480) {\n        this.width = e, this.height = t, this.canvas.width = e, this.canvas.height = t, this.gl.viewport(0, 0, e, t), this.commonUniforms.resolution.value = [e, t], this.commonUniforms.aspectRatio.value = e / t, this.debug(\"MiniGL.setSize\", {\n            width: e,\n            height: t\n        })\n    }\n    //left, right, top, bottom, near, far\n    setOrthographicCamera(e = 0, t = 0, n = 0, i = -2e3, s = 2e3) {\n        this.commonUniforms.projectionMatrix.value = [2 / this.width, 0, 0, 0, 0, 2 / this.height, 0, 0, 0, 0, 2 / (i - s), 0, e, t, n, 1], this.debug(\"setOrthographicCamera\", this.commonUniforms.projectionMatrix.value)\n    }\n    render() {\n        this.gl.clearColor(0, 0, 0, 0), this.gl.clearDepth(1), this.meshes.forEach(e => e.draw())\n    }\n}\n\n\n\n//Sets initial properties\nfunction e(object, propertyName, val) {\n    return propertyName in object ? Object.defineProperty(object, propertyName, {\n        value: val,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : object[propertyName] = val, object\n}\n\n//Gradient object\nexport class Gradient {\n    constructor(...t) {\n        e(this, \"el\", void 0), e(this, \"cssVarRetries\", 0), e(this, \"maxCssVarRetries\", 200), e(this, \"angle\", 0), e(this, \"isLoadedClass\", !1), e(this, \"isScrolling\", !1), /*e(this, \"isStatic\", o.disableAmbientAnimations()),*/ e(this, \"scrollingTimeout\", void 0), e(this, \"scrollingRefreshDelay\", 200), e(this, \"isIntersecting\", !1), e(this, \"shaderFiles\", void 0), e(this, \"vertexShader\", void 0), e(this, \"sectionColors\", void 0), e(this, \"computedCanvasStyle\", void 0), e(this, \"conf\", void 0), e(this, \"uniforms\", void 0), e(this, \"t\", 1253106), e(this, \"last\", 0), e(this, \"width\", void 0), e(this, \"minWidth\", 1111), e(this, \"height\", 600), e(this, \"xSegCount\", void 0), e(this, \"ySegCount\", void 0), e(this, \"mesh\", void 0), e(this, \"material\", void 0), e(this, \"geometry\", void 0), e(this, \"minigl\", void 0), e(this, \"scrollObserver\", void 0), e(this, \"amp\", 320), e(this, \"seed\", 5), e(this, \"freqX\", 14e-5), e(this, \"freqY\", 29e-5), e(this, \"freqDelta\", 1e-5), e(this, \"activeColors\", [1, 1, 1, 1]), e(this, \"isMetaKey\", !1), e(this, \"isGradientLegendVisible\", !1), e(this, \"isMouseDown\", !1), e(this, \"handleScroll\", () => {\n            clearTimeout(this.scrollingTimeout), this.scrollingTimeout = setTimeout(this.handleScrollEnd, this.scrollingRefreshDelay), this.isGradientLegendVisible && this.hideGradientLegend(), this.conf.playing && (this.isScrolling = !0, this.pause())\n        }), e(this, \"handleScrollEnd\", () => {\n            this.isScrolling = !1, this.isIntersecting && this.play()\n        }), e(this, \"resize\", () => {\n            this.width = window.innerWidth, this.minigl.setSize(this.width, this.height), this.minigl.setOrthographicCamera(), this.xSegCount = Math.ceil(this.width * this.conf.density[0]), this.ySegCount = Math.ceil(this.height * this.conf.density[1]), this.mesh.geometry.setTopology(this.xSegCount, this.ySegCount), this.mesh.geometry.setSize(this.width, this.height), this.mesh.material.uniforms.u_shadow_power.value = this.width < 600 ? 5 : 6\n        }), e(this, \"handleMouseDown\", e => {\n            this.isGradientLegendVisible && (this.isMetaKey = e.metaKey, this.isMouseDown = !0, !1 === this.conf.playing && requestAnimationFrame(this.animate))\n        }), e(this, \"handleMouseUp\", () => {\n            this.isMouseDown = !1\n        }), e(this, \"animate\", e => {\n            if (!this.shouldSkipFrame(e) || this.isMouseDown) {\n                if (this.t += Math.min(e - this.last, 1e3 / 15), this.last = e, this.isMouseDown) {\n                    let e = 160;\n                    this.isMetaKey && (e = -160), this.t += e\n                }\n                this.mesh.material.uniforms.u_time.value = this.t, this.minigl.render()\n\n            }\n            if (0 !== this.last && this.isStatic) return this.minigl.render(), void this.disconnect();\n            (/*this.isIntersecting && */this.conf.playing || this.isMouseDown) && requestAnimationFrame(this.animate)\n        }), e(this, \"addIsLoadedClass\", () => {\n            /*this.isIntersecting && */!this.isLoadedClass && (this.isLoadedClass = !0, this.el.classList.add(\"isLoaded\"), setTimeout(() => {\n            this.el.parentElement.classList.add(\"isLoaded\")\n        }, 3e3))\n        }), e(this, \"pause\", () => {\n            this.conf.playing = false\n        }), e(this, \"play\", () => {\n            requestAnimationFrame(this.animate), this.conf.playing = true\n        }), e(this, \"initGradient\", (selector) => {\n            this.el = document.querySelector(selector);\n            this.connect();\n            return this;\n        })\n    }\n    async connect() {\n        this.shaderFiles = {\n            vertex: \"varying vec3 v_color;\\n\\nvoid main() {\\n  float time = u_time * u_global.noiseSpeed;\\n\\n  vec2 noiseCoord = resolution * uvNorm * u_global.noiseFreq;\\n\\n  vec2 st = 1. - uvNorm.xy;\\n\\n  //\\n  // Tilting the plane\\n  //\\n\\n  // Front-to-back tilt\\n  float tilt = resolution.y / 2.0 * uvNorm.y;\\n\\n  // Left-to-right angle\\n  float incline = resolution.x * uvNorm.x / 2.0 * u_vertDeform.incline;\\n\\n  // Up-down shift to offset incline\\n  float offset = resolution.x / 2.0 * u_vertDeform.incline * mix(u_vertDeform.offsetBottom, u_vertDeform.offsetTop, uv.y);\\n\\n  //\\n  // Vertex noise\\n  //\\n\\n  float noise = snoise(vec3(\\n    noiseCoord.x * u_vertDeform.noiseFreq.x + time * u_vertDeform.noiseFlow,\\n    noiseCoord.y * u_vertDeform.noiseFreq.y,\\n    time * u_vertDeform.noiseSpeed + u_vertDeform.noiseSeed\\n  )) * u_vertDeform.noiseAmp;\\n\\n  // Fade noise to zero at edges\\n  noise *= 1.0 - pow(abs(uvNorm.y), 2.0);\\n\\n  // Clamp to 0\\n  noise = max(0.0, noise);\\n\\n  vec3 pos = vec3(\\n    position.x,\\n    position.y + tilt + incline + noise - offset,\\n    position.z\\n  );\\n\\n  //\\n  // Vertex color, to be passed to fragment shader\\n  //\\n\\n  if (u_active_colors[0] == 1.) {\\n    v_color = u_baseColor;\\n  }\\n\\n  for (int i = 0; i < u_waveLayers_length; i++) {\\n    if (u_active_colors[i + 1] == 1.) {\\n      WaveLayers layer = u_waveLayers[i];\\n\\n      float noise = smoothstep(\\n        layer.noiseFloor,\\n        layer.noiseCeil,\\n        snoise(vec3(\\n          noiseCoord.x * layer.noiseFreq.x + time * layer.noiseFlow,\\n          noiseCoord.y * layer.noiseFreq.y,\\n          time * layer.noiseSpeed + layer.noiseSeed\\n        )) / 2.0 + 0.5\\n      );\\n\\n      v_color = blendNormal(v_color, layer.color, pow(noise, 4.));\\n    }\\n  }\\n\\n  //\\n  // Finish\\n  //\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\\n}\",\n            noise: \"//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : stegu\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//               https://github.com/stegu/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n    return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n{\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n          + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n}\",\n            blend: \"//\\n// https://github.com/jamieowen/glsl-blend\\n//\\n\\n// Normal\\n\\nvec3 blendNormal(vec3 base, vec3 blend) {\\n\\treturn blend;\\n}\\n\\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Screen\\n\\nfloat blendScreen(float base, float blend) {\\n\\treturn 1.0-((1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendScreen(vec3 base, vec3 blend) {\\n\\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\\n}\\n\\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Multiply\\n\\nvec3 blendMultiply(vec3 base, vec3 blend) {\\n\\treturn base*blend;\\n}\\n\\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Overlay\\n\\nfloat blendOverlay(float base, float blend) {\\n\\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendOverlay(vec3 base, vec3 blend) {\\n\\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\\n}\\n\\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Hard light\\n\\nvec3 blendHardLight(vec3 base, vec3 blend) {\\n\\treturn blendOverlay(blend,base);\\n}\\n\\nvec3 blendHardLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendHardLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Soft light\\n\\nfloat blendSoftLight(float base, float blend) {\\n\\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\\n}\\n\\nvec3 blendSoftLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\\n}\\n\\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Color dodge\\n\\nfloat blendColorDodge(float base, float blend) {\\n\\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\\n}\\n\\nvec3 blendColorDodge(vec3 base, vec3 blend) {\\n\\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\\n}\\n\\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Color burn\\n\\nfloat blendColorBurn(float base, float blend) {\\n\\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\\n}\\n\\nvec3 blendColorBurn(vec3 base, vec3 blend) {\\n\\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\\n}\\n\\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Vivid Light\\n\\nfloat blendVividLight(float base, float blend) {\\n\\treturn (blend<0.5)?blendColorBurn(base,(2.0*blend)):blendColorDodge(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendVividLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendVividLight(base.r,blend.r),blendVividLight(base.g,blend.g),blendVividLight(base.b,blend.b));\\n}\\n\\nvec3 blendVividLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendVividLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Lighten\\n\\nfloat blendLighten(float base, float blend) {\\n\\treturn max(blend,base);\\n}\\n\\nvec3 blendLighten(vec3 base, vec3 blend) {\\n\\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\\n}\\n\\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear burn\\n\\nfloat blendLinearBurn(float base, float blend) {\\n\\t// Note : Same implementation as BlendSubtractf\\n\\treturn max(base+blend-1.0,0.0);\\n}\\n\\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\\n\\t// Note : Same implementation as BlendSubtract\\n\\treturn max(base+blend-vec3(1.0),vec3(0.0));\\n}\\n\\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear dodge\\n\\nfloat blendLinearDodge(float base, float blend) {\\n\\t// Note : Same implementation as BlendAddf\\n\\treturn min(base+blend,1.0);\\n}\\n\\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\\n\\t// Note : Same implementation as BlendAdd\\n\\treturn min(base+blend,vec3(1.0));\\n}\\n\\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear light\\n\\nfloat blendLinearLight(float base, float blend) {\\n\\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendLinearLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\\n}\\n\\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\",\n            fragment: \"varying vec3 v_color;\\n\\nvoid main() {\\n  vec3 color = v_color;\\n  if (u_darken_top == 1.0) {\\n    vec2 st = gl_FragCoord.xy/resolution.xy;\\n    color.g -= pow(st.y + sin(-12.0) * st.x, u_shadow_power) * 0.4;\\n  }\\n  gl_FragColor = vec4(color, 1.0);\\n}\"\n        },\n            this.conf = {\n                presetName: \"\",\n                wireframe: false,\n                density: [.06, .16],\n                zoom: 1,\n                rotation: 0,\n                playing: true\n            },\n            document.querySelectorAll(\"canvas\").length < 1 ? console.log(\"DID NOT LOAD HERO STRIPE CANVAS\") : (\n\n                this.minigl = new MiniGl(this.el, null, null, !0),\n                requestAnimationFrame(() => {\n                    this.el && (this.computedCanvasStyle = getComputedStyle(this.el), this.waitForCssVars())\n                })\n                /*\n                this.scrollObserver = await s.create(.1, !1),\n                this.scrollObserver.observe(this.el),\n                this.scrollObserver.onSeparate(() => {\n                    window.removeEventListener(\"scroll\", this.handleScroll), window.removeEventListener(\"mousedown\", this.handleMouseDown), window.removeEventListener(\"mouseup\", this.handleMouseUp), window.removeEventListener(\"keydown\", this.handleKeyDown), this.isIntersecting = !1, this.conf.playing && this.pause()\n                }), \n                this.scrollObserver.onIntersect(() => {\n                    window.addEventListener(\"scroll\", this.handleScroll), window.addEventListener(\"mousedown\", this.handleMouseDown), window.addEventListener(\"mouseup\", this.handleMouseUp), window.addEventListener(\"keydown\", this.handleKeyDown), this.isIntersecting = !0, this.addIsLoadedClass(), this.play()\n                })*/\n\n            )\n    }\n    disconnect() {\n        this.scrollObserver && (window.removeEventListener(\"scroll\", this.handleScroll), window.removeEventListener(\"mousedown\", this.handleMouseDown), window.removeEventListener(\"mouseup\", this.handleMouseUp), window.removeEventListener(\"keydown\", this.handleKeyDown), this.scrollObserver.disconnect()), window.removeEventListener(\"resize\", this.resize)\n    }\n    initMaterial() {\n        this.uniforms = {\n            u_time: new this.minigl.Uniform({\n                value: 0\n            }),\n            u_shadow_power: new this.minigl.Uniform({\n                value: 5\n            }),\n            u_darken_top: new this.minigl.Uniform({\n                value: \"\" === this.el.dataset.jsDarkenTop ? 1 : 0\n            }),\n            u_active_colors: new this.minigl.Uniform({\n                value: this.activeColors,\n                type: \"vec4\"\n            }),\n            u_global: new this.minigl.Uniform({\n                value: {\n                    noiseFreq: new this.minigl.Uniform({\n                        value: [this.freqX, this.freqY],\n                        type: \"vec2\"\n                    }),\n                    noiseSpeed: new this.minigl.Uniform({\n                        value: 5e-6\n                    })\n                },\n                type: \"struct\"\n            }),\n            u_vertDeform: new this.minigl.Uniform({\n                value: {\n                    incline: new this.minigl.Uniform({\n                        value: Math.sin(this.angle) / Math.cos(this.angle)\n                    }),\n                    offsetTop: new this.minigl.Uniform({\n                        value: -.5\n                    }),\n                    offsetBottom: new this.minigl.Uniform({\n                        value: -.5\n                    }),\n                    noiseFreq: new this.minigl.Uniform({\n                        value: [3, 4],\n                        type: \"vec2\"\n                    }),\n                    noiseAmp: new this.minigl.Uniform({\n                        value: this.amp\n                    }),\n                    noiseSpeed: new this.minigl.Uniform({\n                        value: 10\n                    }),\n                    noiseFlow: new this.minigl.Uniform({\n                        value: 3\n                    }),\n                    noiseSeed: new this.minigl.Uniform({\n                        value: this.seed\n                    })\n                },\n                type: \"struct\",\n                excludeFrom: \"fragment\"\n            }),\n            u_baseColor: new this.minigl.Uniform({\n                value: this.sectionColors[0],\n                type: \"vec3\",\n                excludeFrom: \"fragment\"\n            }),\n            u_waveLayers: new this.minigl.Uniform({\n                value: [],\n                excludeFrom: \"fragment\",\n                type: \"array\"\n            })\n        };\n        for (let e = 1; e < this.sectionColors.length; e += 1) this.uniforms.u_waveLayers.value.push(new this.minigl.Uniform({\n            value: {\n                color: new this.minigl.Uniform({\n                    value: this.sectionColors[e],\n                    type: \"vec3\"\n                }),\n                noiseFreq: new this.minigl.Uniform({\n                    value: [2 + e / this.sectionColors.length, 3 + e / this.sectionColors.length],\n                    type: \"vec2\"\n                }),\n                noiseSpeed: new this.minigl.Uniform({\n                    value: 11 + .3 * e\n                }),\n                noiseFlow: new this.minigl.Uniform({\n                    value: 6.5 + .3 * e\n                }),\n                noiseSeed: new this.minigl.Uniform({\n                    value: this.seed + 10 * e\n                }),\n                noiseFloor: new this.minigl.Uniform({\n                    value: .1\n                }),\n                noiseCeil: new this.minigl.Uniform({\n                    value: .63 + .07 * e\n                })\n            },\n            type: \"struct\"\n        }));\n        return this.vertexShader = [this.shaderFiles.noise, this.shaderFiles.blend, this.shaderFiles.vertex].join(\"\\n\\n\"), new this.minigl.Material(this.vertexShader, this.shaderFiles.fragment, this.uniforms)\n    }\n    initMesh() {\n        this.material = this.initMaterial(), this.geometry = new this.minigl.PlaneGeometry, this.mesh = new this.minigl.Mesh(this.geometry, this.material)\n    }\n    shouldSkipFrame(e) {\n        return !!window.document.hidden || (!this.conf.playing || (parseInt(e, 10) % 2 == 0 || void 0))\n    }\n    updateFrequency(e) {\n        this.freqX += e, this.freqY += e\n    }\n    toggleColor(index) {\n        this.activeColors[index] = 0 === this.activeColors[index] ? 1 : 0\n    }\n    showGradientLegend() {\n        this.width > this.minWidth && (this.isGradientLegendVisible = !0, document.body.classList.add(\"isGradientLegendVisible\"))\n    }\n    hideGradientLegend() {\n        this.isGradientLegendVisible = !1, document.body.classList.remove(\"isGradientLegendVisible\")\n    }\n    init() {\n        this.initGradientColors(), this.initMesh(), this.resize(), requestAnimationFrame(this.animate), window.addEventListener(\"resize\", this.resize)\n    }\n    /*\n    * Waiting for the css variables to become available, usually on page load before we can continue.\n    * Using default colors assigned below if no variables have been found after maxCssVarRetries\n    */\n    waitForCssVars() {\n        if (this.computedCanvasStyle && -1 !== this.computedCanvasStyle.getPropertyValue(\"--gradient-color-1\").indexOf(\"#\")) this.init(), this.addIsLoadedClass();\n        else {\n            if (this.cssVarRetries += 1, this.cssVarRetries > this.maxCssVarRetries) {\n                return this.sectionColors = [16711680, 16711680, 16711935, 65280, 255], void this.init();\n            }\n            requestAnimationFrame(() => this.waitForCssVars())\n        }\n    }\n    /*\n    * Initializes the four section colors by retrieving them from css variables.\n    */\n    initGradientColors() {\n        this.sectionColors = [\"--gradient-color-1\", \"--gradient-color-2\", \"--gradient-color-3\", \"--gradient-color-4\"].map(cssPropertyName => {\n            let hex = this.computedCanvasStyle.getPropertyValue(cssPropertyName).trim();\n            //Check if shorthand hex value was used and double the length so the conversion in normalizeColor will work.\n            if (4 === hex.length) {\n                const hexTemp = hex.substr(1).split(\"\").map(hexTemp => hexTemp + hexTemp).join(\"\");\n                hex = `#${hexTemp}`\n            }\n            return hex && `0x${hex.substr(1)}`\n        }).filter(Boolean).map(normalizeColor)\n    }\n}\n\n\n\n\n/*\n*Finally initializing the Gradient class, assigning a canvas to it and calling Gradient.connect() which initializes everything,\n* Use Gradient.pause() and Gradient.play() for controls.\n*\n* Here are some default property values you can change anytime:\n* Amplitude:    Gradient.amp = 0\n* Colors:       Gradient.sectionColors (if you change colors, use normalizeColor(#hexValue)) before you assign it.\n*\n*\n* Useful functions\n* Gradient.toggleColor(index)\n* Gradient.updateFrequency(freq)\n*/"]},"metadata":{},"sourceType":"module"}