module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = require('../ssr-module-cache.js');
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete installedModules[moduleId];
/******/ 		}
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./pages/projects.jsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../next-server/lib/router-context":
/*!**************************************************************!*\
  !*** external "next/dist/next-server/lib/router-context.js" ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"next/dist/next-server/lib/router-context.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJuZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0LmpzXCI/NDEyNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyLWNvbnRleHQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0LmpzXCIpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../next-server/lib/router-context\n");

/***/ }),

/***/ "../next-server/lib/router/utils/get-asset-path-from-route":
/*!**************************************************************************************!*\
  !*** external "next/dist/next-server/lib/router/utils/get-asset-path-from-route.js" ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"next/dist/next-server/lib/router/utils/get-asset-path-from-route.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJuZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9nZXQtYXNzZXQtcGF0aC1mcm9tLXJvdXRlLmpzXCI/ODU0NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9nZXQtYXNzZXQtcGF0aC1mcm9tLXJvdXRlLmpzXCIpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../next-server/lib/router/utils/get-asset-path-from-route\n");

/***/ }),

/***/ "./api/gradient.js":
/*!*************************!*\
  !*** ./api/gradient.js ***!
  \*************************/
/*! exports provided: Gradient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Gradient\", function() { return Gradient; });\n/*\n*   Stripe WebGl Gradient Animation\n*   All Credits to Stripe.com\n*   ScrollObserver functionality to disable animation when not scrolled into view has been disabled and \n*   commented out for now.\n*   https://kevinhufnagl.com\n*/\n//Converting colors to proper format\nfunction normalizeColor(hexCode) {\n  return [(hexCode >> 16 & 255) / 255, (hexCode >> 8 & 255) / 255, (255 & hexCode) / 255];\n}\n\n[\"SCREEN\", \"LINEAR_LIGHT\"].reduce((hexCode, t, n) => Object.assign(hexCode, {\n  [t]: n\n}), {}); //Essential functionality of WebGl\n//t = width\n//n = height\n\nclass MiniGl {\n  constructor(canvas, width, height, debug = false) {\n    const _miniGl = this,\n          debug_output = -1 !== document.location.search.toLowerCase().indexOf(\"debug=webgl\");\n\n    _miniGl.canvas = canvas, _miniGl.gl = _miniGl.canvas.getContext(\"webgl\", {\n      antialias: true\n    }), _miniGl.meshes = [];\n    const context = _miniGl.gl;\n    width && height && this.setSize(width, height), _miniGl.lastDebugMsg, _miniGl.debug = debug && debug_output ? function (e) {\n      const t = new Date();\n      t - _miniGl.lastDebugMsg > 1e3 && console.log(\"---\"), console.log(t.toLocaleTimeString() + Array(Math.max(0, 32 - e.length)).join(\" \") + e + \": \", ...Array.from(arguments).slice(1)), _miniGl.lastDebugMsg = t;\n    } : () => {}, Object.defineProperties(_miniGl, {\n      Material: {\n        enumerable: false,\n        value: class {\n          constructor(vertexShaders, fragments, uniforms = {}) {\n            const material = this;\n\n            function getShaderByType(type, source) {\n              const shader = context.createShader(type);\n              return context.shaderSource(shader, source), context.compileShader(shader), context.getShaderParameter(shader, context.COMPILE_STATUS) || console.error(context.getShaderInfoLog(shader)), _miniGl.debug(\"Material.compileShaderSource\", {\n                source: source\n              }), shader;\n            }\n\n            function getUniformVariableDeclarations(uniforms, type) {\n              return Object.entries(uniforms).map(([uniform, value]) => value.getDeclaration(uniform, type)).join(\"\\n\");\n            }\n\n            material.uniforms = uniforms, material.uniformInstances = [];\n            const prefix = \"\\n              precision highp float;\\n            \";\n            material.vertexSource = `\\n              ${prefix}\\n              attribute vec4 position;\\n              attribute vec2 uv;\\n              attribute vec2 uvNorm;\\n              ${getUniformVariableDeclarations(_miniGl.commonUniforms, \"vertex\")}\\n              ${getUniformVariableDeclarations(uniforms, \"vertex\")}\\n              ${vertexShaders}\\n            `, material.Source = `\\n              ${prefix}\\n              ${getUniformVariableDeclarations(_miniGl.commonUniforms, \"fragment\")}\\n              ${getUniformVariableDeclarations(uniforms, \"fragment\")}\\n              ${fragments}\\n            `, material.vertexShader = getShaderByType(context.VERTEX_SHADER, material.vertexSource), material.fragmentShader = getShaderByType(context.FRAGMENT_SHADER, material.Source), material.program = context.createProgram(), context.attachShader(material.program, material.vertexShader), context.attachShader(material.program, material.fragmentShader), context.linkProgram(material.program), context.getProgramParameter(material.program, context.LINK_STATUS) || console.error(context.getProgramInfoLog(material.program)), context.useProgram(material.program), material.attachUniforms(void 0, _miniGl.commonUniforms), material.attachUniforms(void 0, material.uniforms);\n          } //t = uniform\n\n\n          attachUniforms(name, uniforms) {\n            //n  = material\n            const material = this;\n            void 0 === name ? Object.entries(uniforms).forEach(([name, uniform]) => {\n              material.attachUniforms(name, uniform);\n            }) : \"array\" == uniforms.type ? uniforms.value.forEach((uniform, i) => material.attachUniforms(`${name}[${i}]`, uniform)) : \"struct\" == uniforms.type ? Object.entries(uniforms.value).forEach(([uniform, i]) => material.attachUniforms(`${name}.${uniform}`, i)) : (_miniGl.debug(\"Material.attachUniforms\", {\n              name: name,\n              uniform: uniforms\n            }), material.uniformInstances.push({\n              uniform: uniforms,\n              location: context.getUniformLocation(material.program, name)\n            }));\n          }\n\n        }\n      },\n      Uniform: {\n        enumerable: !1,\n        value: class {\n          constructor(e) {\n            this.type = \"float\", Object.assign(this, e);\n            this.typeFn = {\n              float: \"1f\",\n              int: \"1i\",\n              vec2: \"2fv\",\n              vec3: \"3fv\",\n              vec4: \"4fv\",\n              mat4: \"Matrix4fv\"\n            }[this.type] || \"1f\", this.update();\n          }\n\n          update(value) {\n            void 0 !== this.value && context[`uniform${this.typeFn}`](value, 0 === this.typeFn.indexOf(\"Matrix\") ? this.transpose : this.value, 0 === this.typeFn.indexOf(\"Matrix\") ? this.value : null);\n          } //e - name\n          //t - type\n          //n - length\n\n\n          getDeclaration(name, type, length) {\n            const uniform = this;\n\n            if (uniform.excludeFrom !== type) {\n              if (\"array\" === uniform.type) return uniform.value[0].getDeclaration(name, type, uniform.value.length) + `\\nconst int ${name}_length = ${uniform.value.length};`;\n\n              if (\"struct\" === uniform.type) {\n                let name_no_prefix = name.replace(\"u_\", \"\");\n                return name_no_prefix = name_no_prefix.charAt(0).toUpperCase() + name_no_prefix.slice(1), `uniform struct ${name_no_prefix} \n                                  {\\n` + Object.entries(uniform.value).map(([name, uniform]) => uniform.getDeclaration(name, type).replace(/^uniform/, \"\")).join(\"\") + `\\n} ${name}${length > 0 ? `[${length}]` : \"\"};`;\n              }\n\n              return `uniform ${uniform.type} ${name}${length > 0 ? `[${length}]` : \"\"};`;\n            }\n          }\n\n        }\n      },\n      PlaneGeometry: {\n        enumerable: !1,\n        value: class {\n          constructor(width, height, n, i, orientation) {\n            context.createBuffer(), this.attributes = {\n              position: new _miniGl.Attribute({\n                target: context.ARRAY_BUFFER,\n                size: 3\n              }),\n              uv: new _miniGl.Attribute({\n                target: context.ARRAY_BUFFER,\n                size: 2\n              }),\n              uvNorm: new _miniGl.Attribute({\n                target: context.ARRAY_BUFFER,\n                size: 2\n              }),\n              index: new _miniGl.Attribute({\n                target: context.ELEMENT_ARRAY_BUFFER,\n                size: 3,\n                type: context.UNSIGNED_SHORT\n              })\n            }, this.setTopology(n, i), this.setSize(width, height, orientation);\n          }\n\n          setTopology(e = 1, t = 1) {\n            const n = this;\n            n.xSegCount = e, n.ySegCount = t, n.vertexCount = (n.xSegCount + 1) * (n.ySegCount + 1), n.quadCount = n.xSegCount * n.ySegCount * 2, n.attributes.uv.values = new Float32Array(2 * n.vertexCount), n.attributes.uvNorm.values = new Float32Array(2 * n.vertexCount), n.attributes.index.values = new Uint16Array(3 * n.quadCount);\n\n            for (let e = 0; e <= n.ySegCount; e++) for (let t = 0; t <= n.xSegCount; t++) {\n              const i = e * (n.xSegCount + 1) + t;\n\n              if (n.attributes.uv.values[2 * i] = t / n.xSegCount, n.attributes.uv.values[2 * i + 1] = 1 - e / n.ySegCount, n.attributes.uvNorm.values[2 * i] = t / n.xSegCount * 2 - 1, n.attributes.uvNorm.values[2 * i + 1] = 1 - e / n.ySegCount * 2, t < n.xSegCount && e < n.ySegCount) {\n                const s = e * n.xSegCount + t;\n                n.attributes.index.values[6 * s] = i, n.attributes.index.values[6 * s + 1] = i + 1 + n.xSegCount, n.attributes.index.values[6 * s + 2] = i + 1, n.attributes.index.values[6 * s + 3] = i + 1, n.attributes.index.values[6 * s + 4] = i + 1 + n.xSegCount, n.attributes.index.values[6 * s + 5] = i + 2 + n.xSegCount;\n              }\n            }\n\n            n.attributes.uv.update(), n.attributes.uvNorm.update(), n.attributes.index.update(), _miniGl.debug(\"Geometry.setTopology\", {\n              uv: n.attributes.uv,\n              uvNorm: n.attributes.uvNorm,\n              index: n.attributes.index\n            });\n          }\n\n          setSize(width = 1, height = 1, orientation = \"xz\") {\n            const geometry = this;\n            geometry.width = width, geometry.height = height, geometry.orientation = orientation, geometry.attributes.position.values && geometry.attributes.position.values.length === 3 * geometry.vertexCount || (geometry.attributes.position.values = new Float32Array(3 * geometry.vertexCount));\n            const o = width / -2,\n                  r = height / -2,\n                  segment_width = width / geometry.xSegCount,\n                  segment_height = height / geometry.ySegCount;\n\n            for (let yIndex = 0; yIndex <= geometry.ySegCount; yIndex++) {\n              const t = r + yIndex * segment_height;\n\n              for (let xIndex = 0; xIndex <= geometry.xSegCount; xIndex++) {\n                const r = o + xIndex * segment_width,\n                      l = yIndex * (geometry.xSegCount + 1) + xIndex;\n                geometry.attributes.position.values[3 * l + \"xyz\".indexOf(orientation[0])] = r, geometry.attributes.position.values[3 * l + \"xyz\".indexOf(orientation[1])] = -t;\n              }\n            }\n\n            geometry.attributes.position.update(), _miniGl.debug(\"Geometry.setSize\", {\n              position: geometry.attributes.position\n            });\n          }\n\n        }\n      },\n      Mesh: {\n        enumerable: !1,\n        value: class {\n          constructor(geometry, material) {\n            const mesh = this;\n            mesh.geometry = geometry, mesh.material = material, mesh.wireframe = !1, mesh.attributeInstances = [], Object.entries(mesh.geometry.attributes).forEach(([e, attribute]) => {\n              mesh.attributeInstances.push({\n                attribute: attribute,\n                location: attribute.attach(e, mesh.material.program)\n              });\n            }), _miniGl.meshes.push(mesh), _miniGl.debug(\"Mesh.constructor\", {\n              mesh: mesh\n            });\n          }\n\n          draw() {\n            context.useProgram(this.material.program), this.material.uniformInstances.forEach(({\n              uniform: e,\n              location: t\n            }) => e.update(t)), this.attributeInstances.forEach(({\n              attribute: e,\n              location: t\n            }) => e.use(t)), context.drawElements(this.wireframe ? context.LINES : context.TRIANGLES, this.geometry.attributes.index.values.length, context.UNSIGNED_SHORT, 0);\n          }\n\n          remove() {\n            _miniGl.meshes = _miniGl.meshes.filter(e => e != this);\n          }\n\n        }\n      },\n      Attribute: {\n        enumerable: !1,\n        value: class {\n          constructor(e) {\n            this.type = context.FLOAT, this.normalized = !1, this.buffer = context.createBuffer(), Object.assign(this, e), this.update();\n          }\n\n          update() {\n            void 0 !== this.values && (context.bindBuffer(this.target, this.buffer), context.bufferData(this.target, this.values, context.STATIC_DRAW));\n          }\n\n          attach(e, t) {\n            const n = context.getAttribLocation(t, e);\n            return this.target === context.ARRAY_BUFFER && (context.enableVertexAttribArray(n), context.vertexAttribPointer(n, this.size, this.type, this.normalized, 0, 0)), n;\n          }\n\n          use(e) {\n            context.bindBuffer(this.target, this.buffer), this.target === context.ARRAY_BUFFER && (context.enableVertexAttribArray(e), context.vertexAttribPointer(e, this.size, this.type, this.normalized, 0, 0));\n          }\n\n        }\n      }\n    });\n    const a = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n    _miniGl.commonUniforms = {\n      projectionMatrix: new _miniGl.Uniform({\n        type: \"mat4\",\n        value: a\n      }),\n      modelViewMatrix: new _miniGl.Uniform({\n        type: \"mat4\",\n        value: a\n      }),\n      resolution: new _miniGl.Uniform({\n        type: \"vec2\",\n        value: [1, 1]\n      }),\n      aspectRatio: new _miniGl.Uniform({\n        type: \"float\",\n        value: 1\n      })\n    };\n  }\n\n  setSize(e = 640, t = 480) {\n    this.width = e, this.height = t, this.canvas.width = e, this.canvas.height = t, this.gl.viewport(0, 0, e, t), this.commonUniforms.resolution.value = [e, t], this.commonUniforms.aspectRatio.value = e / t, this.debug(\"MiniGL.setSize\", {\n      width: e,\n      height: t\n    });\n  } //left, right, top, bottom, near, far\n\n\n  setOrthographicCamera(e = 0, t = 0, n = 0, i = -2e3, s = 2e3) {\n    this.commonUniforms.projectionMatrix.value = [2 / this.width, 0, 0, 0, 0, 2 / this.height, 0, 0, 0, 0, 2 / (i - s), 0, e, t, n, 1], this.debug(\"setOrthographicCamera\", this.commonUniforms.projectionMatrix.value);\n  }\n\n  render() {\n    this.gl.clearColor(0, 0, 0, 0), this.gl.clearDepth(1), this.meshes.forEach(e => e.draw());\n  }\n\n} //Sets initial properties\n\n\nfunction e(object, propertyName, val) {\n  return propertyName in object ? Object.defineProperty(object, propertyName, {\n    value: val,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : object[propertyName] = val, object;\n} //Gradient object\n\n\nclass Gradient {\n  constructor(...t) {\n    e(this, \"el\", void 0), e(this, \"cssVarRetries\", 0), e(this, \"maxCssVarRetries\", 200), e(this, \"angle\", 0), e(this, \"isLoadedClass\", !1), e(this, \"isScrolling\", !1),\n    /*e(this, \"isStatic\", o.disableAmbientAnimations()),*/\n    e(this, \"scrollingTimeout\", void 0), e(this, \"scrollingRefreshDelay\", 200), e(this, \"isIntersecting\", !1), e(this, \"shaderFiles\", void 0), e(this, \"vertexShader\", void 0), e(this, \"sectionColors\", void 0), e(this, \"computedCanvasStyle\", void 0), e(this, \"conf\", void 0), e(this, \"uniforms\", void 0), e(this, \"t\", 1253106), e(this, \"last\", 0), e(this, \"width\", void 0), e(this, \"minWidth\", 1111), e(this, \"height\", 600), e(this, \"xSegCount\", void 0), e(this, \"ySegCount\", void 0), e(this, \"mesh\", void 0), e(this, \"material\", void 0), e(this, \"geometry\", void 0), e(this, \"minigl\", void 0), e(this, \"scrollObserver\", void 0), e(this, \"amp\", 320), e(this, \"seed\", 5), e(this, \"freqX\", 14e-5), e(this, \"freqY\", 29e-5), e(this, \"freqDelta\", 1e-5), e(this, \"activeColors\", [1, 1, 1, 1]), e(this, \"isMetaKey\", !1), e(this, \"isGradientLegendVisible\", !1), e(this, \"isMouseDown\", !1), e(this, \"handleScroll\", () => {\n      clearTimeout(this.scrollingTimeout), this.scrollingTimeout = setTimeout(this.handleScrollEnd, this.scrollingRefreshDelay), this.isGradientLegendVisible && this.hideGradientLegend(), this.conf.playing && (this.isScrolling = !0, this.pause());\n    }), e(this, \"handleScrollEnd\", () => {\n      this.isScrolling = !1, this.isIntersecting && this.play();\n    }), e(this, \"resize\", () => {\n      this.width = window.innerWidth, this.minigl.setSize(this.width, this.height), this.minigl.setOrthographicCamera(), this.xSegCount = Math.ceil(this.width * this.conf.density[0]), this.ySegCount = Math.ceil(this.height * this.conf.density[1]), this.mesh.geometry.setTopology(this.xSegCount, this.ySegCount), this.mesh.geometry.setSize(this.width, this.height), this.mesh.material.uniforms.u_shadow_power.value = this.width < 600 ? 5 : 6;\n    }), e(this, \"handleMouseDown\", e => {\n      this.isGradientLegendVisible && (this.isMetaKey = e.metaKey, this.isMouseDown = !0, !1 === this.conf.playing && requestAnimationFrame(this.animate));\n    }), e(this, \"handleMouseUp\", () => {\n      this.isMouseDown = !1;\n    }), e(this, \"animate\", e => {\n      if (!this.shouldSkipFrame(e) || this.isMouseDown) {\n        if (this.t += Math.min(e - this.last, 1e3 / 15), this.last = e, this.isMouseDown) {\n          let e = 160;\n          this.isMetaKey && (e = -160), this.t += e;\n        }\n\n        this.mesh.material.uniforms.u_time.value = this.t, this.minigl.render();\n      }\n\n      if (0 !== this.last && this.isStatic) return this.minigl.render(), void this.disconnect();\n      (\n      /*this.isIntersecting && */\n      this.conf.playing || this.isMouseDown) && requestAnimationFrame(this.animate);\n    }), e(this, \"addIsLoadedClass\", () => {\n      /*this.isIntersecting && */\n      !this.isLoadedClass && (this.isLoadedClass = !0, this.el.classList.add(\"isLoaded\"), setTimeout(() => {\n        this.el.parentElement.classList.add(\"isLoaded\");\n      }, 3e3));\n    }), e(this, \"pause\", () => {\n      this.conf.playing = false;\n    }), e(this, \"play\", () => {\n      requestAnimationFrame(this.animate), this.conf.playing = true;\n    }), e(this, \"initGradient\", selector => {\n      this.el = document.querySelector(selector);\n      this.connect();\n      return this;\n    });\n  }\n\n  async connect() {\n    this.shaderFiles = {\n      vertex: \"varying vec3 v_color;\\n\\nvoid main() {\\n  float time = u_time * u_global.noiseSpeed;\\n\\n  vec2 noiseCoord = resolution * uvNorm * u_global.noiseFreq;\\n\\n  vec2 st = 1. - uvNorm.xy;\\n\\n  //\\n  // Tilting the plane\\n  //\\n\\n  // Front-to-back tilt\\n  float tilt = resolution.y / 2.0 * uvNorm.y;\\n\\n  // Left-to-right angle\\n  float incline = resolution.x * uvNorm.x / 2.0 * u_vertDeform.incline;\\n\\n  // Up-down shift to offset incline\\n  float offset = resolution.x / 2.0 * u_vertDeform.incline * mix(u_vertDeform.offsetBottom, u_vertDeform.offsetTop, uv.y);\\n\\n  //\\n  // Vertex noise\\n  //\\n\\n  float noise = snoise(vec3(\\n    noiseCoord.x * u_vertDeform.noiseFreq.x + time * u_vertDeform.noiseFlow,\\n    noiseCoord.y * u_vertDeform.noiseFreq.y,\\n    time * u_vertDeform.noiseSpeed + u_vertDeform.noiseSeed\\n  )) * u_vertDeform.noiseAmp;\\n\\n  // Fade noise to zero at edges\\n  noise *= 1.0 - pow(abs(uvNorm.y), 2.0);\\n\\n  // Clamp to 0\\n  noise = max(0.0, noise);\\n\\n  vec3 pos = vec3(\\n    position.x,\\n    position.y + tilt + incline + noise - offset,\\n    position.z\\n  );\\n\\n  //\\n  // Vertex color, to be passed to fragment shader\\n  //\\n\\n  if (u_active_colors[0] == 1.) {\\n    v_color = u_baseColor;\\n  }\\n\\n  for (int i = 0; i < u_waveLayers_length; i++) {\\n    if (u_active_colors[i + 1] == 1.) {\\n      WaveLayers layer = u_waveLayers[i];\\n\\n      float noise = smoothstep(\\n        layer.noiseFloor,\\n        layer.noiseCeil,\\n        snoise(vec3(\\n          noiseCoord.x * layer.noiseFreq.x + time * layer.noiseFlow,\\n          noiseCoord.y * layer.noiseFreq.y,\\n          time * layer.noiseSpeed + layer.noiseSeed\\n        )) / 2.0 + 0.5\\n      );\\n\\n      v_color = blendNormal(v_color, layer.color, pow(noise, 4.));\\n    }\\n  }\\n\\n  //\\n  // Finish\\n  //\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\\n}\",\n      noise: \"//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : stegu\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//               https://github.com/stegu/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n    return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n{\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n          + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n}\",\n      blend: \"//\\n// https://github.com/jamieowen/glsl-blend\\n//\\n\\n// Normal\\n\\nvec3 blendNormal(vec3 base, vec3 blend) {\\n\\treturn blend;\\n}\\n\\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Screen\\n\\nfloat blendScreen(float base, float blend) {\\n\\treturn 1.0-((1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendScreen(vec3 base, vec3 blend) {\\n\\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\\n}\\n\\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Multiply\\n\\nvec3 blendMultiply(vec3 base, vec3 blend) {\\n\\treturn base*blend;\\n}\\n\\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Overlay\\n\\nfloat blendOverlay(float base, float blend) {\\n\\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendOverlay(vec3 base, vec3 blend) {\\n\\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\\n}\\n\\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Hard light\\n\\nvec3 blendHardLight(vec3 base, vec3 blend) {\\n\\treturn blendOverlay(blend,base);\\n}\\n\\nvec3 blendHardLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendHardLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Soft light\\n\\nfloat blendSoftLight(float base, float blend) {\\n\\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\\n}\\n\\nvec3 blendSoftLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\\n}\\n\\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Color dodge\\n\\nfloat blendColorDodge(float base, float blend) {\\n\\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\\n}\\n\\nvec3 blendColorDodge(vec3 base, vec3 blend) {\\n\\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\\n}\\n\\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Color burn\\n\\nfloat blendColorBurn(float base, float blend) {\\n\\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\\n}\\n\\nvec3 blendColorBurn(vec3 base, vec3 blend) {\\n\\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\\n}\\n\\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Vivid Light\\n\\nfloat blendVividLight(float base, float blend) {\\n\\treturn (blend<0.5)?blendColorBurn(base,(2.0*blend)):blendColorDodge(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendVividLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendVividLight(base.r,blend.r),blendVividLight(base.g,blend.g),blendVividLight(base.b,blend.b));\\n}\\n\\nvec3 blendVividLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendVividLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Lighten\\n\\nfloat blendLighten(float base, float blend) {\\n\\treturn max(blend,base);\\n}\\n\\nvec3 blendLighten(vec3 base, vec3 blend) {\\n\\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\\n}\\n\\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear burn\\n\\nfloat blendLinearBurn(float base, float blend) {\\n\\t// Note : Same implementation as BlendSubtractf\\n\\treturn max(base+blend-1.0,0.0);\\n}\\n\\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\\n\\t// Note : Same implementation as BlendSubtract\\n\\treturn max(base+blend-vec3(1.0),vec3(0.0));\\n}\\n\\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear dodge\\n\\nfloat blendLinearDodge(float base, float blend) {\\n\\t// Note : Same implementation as BlendAddf\\n\\treturn min(base+blend,1.0);\\n}\\n\\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\\n\\t// Note : Same implementation as BlendAdd\\n\\treturn min(base+blend,vec3(1.0));\\n}\\n\\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear light\\n\\nfloat blendLinearLight(float base, float blend) {\\n\\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendLinearLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\\n}\\n\\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\",\n      fragment: \"varying vec3 v_color;\\n\\nvoid main() {\\n  vec3 color = v_color;\\n  if (u_darken_top == 1.0) {\\n    vec2 st = gl_FragCoord.xy/resolution.xy;\\n    color.g -= pow(st.y + sin(-12.0) * st.x, u_shadow_power) * 0.4;\\n  }\\n  gl_FragColor = vec4(color, 1.0);\\n}\"\n    }, this.conf = {\n      presetName: \"\",\n      wireframe: false,\n      density: [.06, .16],\n      zoom: 1,\n      rotation: 0,\n      playing: true\n    }, document.querySelectorAll(\"canvas\").length < 1 ? console.log(\"DID NOT LOAD HERO STRIPE CANVAS\") : (this.minigl = new MiniGl(this.el, null, null, !0), requestAnimationFrame(() => {\n      this.el && (this.computedCanvasStyle = getComputedStyle(this.el), this.waitForCssVars());\n    })\n    /*\n    this.scrollObserver = await s.create(.1, !1),\n    this.scrollObserver.observe(this.el),\n    this.scrollObserver.onSeparate(() => {\n        window.removeEventListener(\"scroll\", this.handleScroll), window.removeEventListener(\"mousedown\", this.handleMouseDown), window.removeEventListener(\"mouseup\", this.handleMouseUp), window.removeEventListener(\"keydown\", this.handleKeyDown), this.isIntersecting = !1, this.conf.playing && this.pause()\n    }), \n    this.scrollObserver.onIntersect(() => {\n        window.addEventListener(\"scroll\", this.handleScroll), window.addEventListener(\"mousedown\", this.handleMouseDown), window.addEventListener(\"mouseup\", this.handleMouseUp), window.addEventListener(\"keydown\", this.handleKeyDown), this.isIntersecting = !0, this.addIsLoadedClass(), this.play()\n    })*/\n    );\n  }\n\n  disconnect() {\n    this.scrollObserver && (window.removeEventListener(\"scroll\", this.handleScroll), window.removeEventListener(\"mousedown\", this.handleMouseDown), window.removeEventListener(\"mouseup\", this.handleMouseUp), window.removeEventListener(\"keydown\", this.handleKeyDown), this.scrollObserver.disconnect()), window.removeEventListener(\"resize\", this.resize);\n  }\n\n  initMaterial() {\n    this.uniforms = {\n      u_time: new this.minigl.Uniform({\n        value: 0\n      }),\n      u_shadow_power: new this.minigl.Uniform({\n        value: 5\n      }),\n      u_darken_top: new this.minigl.Uniform({\n        value: \"\" === this.el.dataset.jsDarkenTop ? 1 : 0\n      }),\n      u_active_colors: new this.minigl.Uniform({\n        value: this.activeColors,\n        type: \"vec4\"\n      }),\n      u_global: new this.minigl.Uniform({\n        value: {\n          noiseFreq: new this.minigl.Uniform({\n            value: [this.freqX, this.freqY],\n            type: \"vec2\"\n          }),\n          noiseSpeed: new this.minigl.Uniform({\n            value: 5e-6\n          })\n        },\n        type: \"struct\"\n      }),\n      u_vertDeform: new this.minigl.Uniform({\n        value: {\n          incline: new this.minigl.Uniform({\n            value: Math.sin(this.angle) / Math.cos(this.angle)\n          }),\n          offsetTop: new this.minigl.Uniform({\n            value: -.5\n          }),\n          offsetBottom: new this.minigl.Uniform({\n            value: -.5\n          }),\n          noiseFreq: new this.minigl.Uniform({\n            value: [3, 4],\n            type: \"vec2\"\n          }),\n          noiseAmp: new this.minigl.Uniform({\n            value: this.amp\n          }),\n          noiseSpeed: new this.minigl.Uniform({\n            value: 10\n          }),\n          noiseFlow: new this.minigl.Uniform({\n            value: 3\n          }),\n          noiseSeed: new this.minigl.Uniform({\n            value: this.seed\n          })\n        },\n        type: \"struct\",\n        excludeFrom: \"fragment\"\n      }),\n      u_baseColor: new this.minigl.Uniform({\n        value: this.sectionColors[0],\n        type: \"vec3\",\n        excludeFrom: \"fragment\"\n      }),\n      u_waveLayers: new this.minigl.Uniform({\n        value: [],\n        excludeFrom: \"fragment\",\n        type: \"array\"\n      })\n    };\n\n    for (let e = 1; e < this.sectionColors.length; e += 1) this.uniforms.u_waveLayers.value.push(new this.minigl.Uniform({\n      value: {\n        color: new this.minigl.Uniform({\n          value: this.sectionColors[e],\n          type: \"vec3\"\n        }),\n        noiseFreq: new this.minigl.Uniform({\n          value: [2 + e / this.sectionColors.length, 3 + e / this.sectionColors.length],\n          type: \"vec2\"\n        }),\n        noiseSpeed: new this.minigl.Uniform({\n          value: 11 + .3 * e\n        }),\n        noiseFlow: new this.minigl.Uniform({\n          value: 6.5 + .3 * e\n        }),\n        noiseSeed: new this.minigl.Uniform({\n          value: this.seed + 10 * e\n        }),\n        noiseFloor: new this.minigl.Uniform({\n          value: .1\n        }),\n        noiseCeil: new this.minigl.Uniform({\n          value: .63 + .07 * e\n        })\n      },\n      type: \"struct\"\n    }));\n\n    return this.vertexShader = [this.shaderFiles.noise, this.shaderFiles.blend, this.shaderFiles.vertex].join(\"\\n\\n\"), new this.minigl.Material(this.vertexShader, this.shaderFiles.fragment, this.uniforms);\n  }\n\n  initMesh() {\n    this.material = this.initMaterial(), this.geometry = new this.minigl.PlaneGeometry(), this.mesh = new this.minigl.Mesh(this.geometry, this.material);\n  }\n\n  shouldSkipFrame(e) {\n    return !!window.document.hidden || !this.conf.playing || parseInt(e, 10) % 2 == 0 || void 0;\n  }\n\n  updateFrequency(e) {\n    this.freqX += e, this.freqY += e;\n  }\n\n  toggleColor(index) {\n    this.activeColors[index] = 0 === this.activeColors[index] ? 1 : 0;\n  }\n\n  showGradientLegend() {\n    this.width > this.minWidth && (this.isGradientLegendVisible = !0, document.body.classList.add(\"isGradientLegendVisible\"));\n  }\n\n  hideGradientLegend() {\n    this.isGradientLegendVisible = !1, document.body.classList.remove(\"isGradientLegendVisible\");\n  }\n\n  init() {\n    this.initGradientColors(), this.initMesh(), this.resize(), requestAnimationFrame(this.animate), window.addEventListener(\"resize\", this.resize);\n  }\n  /*\n  * Waiting for the css variables to become available, usually on page load before we can continue.\n  * Using default colors assigned below if no variables have been found after maxCssVarRetries\n  */\n\n\n  waitForCssVars() {\n    if (this.computedCanvasStyle && -1 !== this.computedCanvasStyle.getPropertyValue(\"--gradient-color-1\").indexOf(\"#\")) this.init(), this.addIsLoadedClass();else {\n      if (this.cssVarRetries += 1, this.cssVarRetries > this.maxCssVarRetries) {\n        return this.sectionColors = [16711680, 16711680, 16711935, 65280, 255], void this.init();\n      }\n\n      requestAnimationFrame(() => this.waitForCssVars());\n    }\n  }\n  /*\n  * Initializes the four section colors by retrieving them from css variables.\n  */\n\n\n  initGradientColors() {\n    this.sectionColors = [\"--gradient-color-1\", \"--gradient-color-2\", \"--gradient-color-3\", \"--gradient-color-4\"].map(cssPropertyName => {\n      let hex = this.computedCanvasStyle.getPropertyValue(cssPropertyName).trim(); //Check if shorthand hex value was used and double the length so the conversion in normalizeColor will work.\n\n      if (4 === hex.length) {\n        const hexTemp = hex.substr(1).split(\"\").map(hexTemp => hexTemp + hexTemp).join(\"\");\n        hex = `#${hexTemp}`;\n      }\n\n      return hex && `0x${hex.substr(1)}`;\n    }).filter(Boolean).map(normalizeColor);\n  }\n\n}\n/*\n*Finally initializing the Gradient class, assigning a canvas to it and calling Gradient.connect() which initializes everything,\n* Use Gradient.pause() and Gradient.play() for controls.\n*\n* Here are some default property values you can change anytime:\n* Amplitude:    Gradient.amp = 0\n* Colors:       Gradient.sectionColors (if you change colors, use normalizeColor(#hexValue)) before you assign it.\n*\n*\n* Useful functions\n* Gradient.toggleColor(index)\n* Gradient.updateFrequency(freq)\n*///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcGkvZ3JhZGllbnQuanM/OGJhZCJdLCJuYW1lcyI6WyJub3JtYWxpemVDb2xvciIsImhleENvZGUiLCJyZWR1Y2UiLCJ0IiwibiIsIk9iamVjdCIsImFzc2lnbiIsIk1pbmlHbCIsImNvbnN0cnVjdG9yIiwiY2FudmFzIiwid2lkdGgiLCJoZWlnaHQiLCJkZWJ1ZyIsIl9taW5pR2wiLCJkZWJ1Z19vdXRwdXQiLCJkb2N1bWVudCIsImxvY2F0aW9uIiwic2VhcmNoIiwidG9Mb3dlckNhc2UiLCJpbmRleE9mIiwiZ2wiLCJnZXRDb250ZXh0IiwiYW50aWFsaWFzIiwibWVzaGVzIiwiY29udGV4dCIsInNldFNpemUiLCJsYXN0RGVidWdNc2ciLCJlIiwiRGF0ZSIsImNvbnNvbGUiLCJsb2ciLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJBcnJheSIsIk1hdGgiLCJtYXgiLCJsZW5ndGgiLCJqb2luIiwiZnJvbSIsImFyZ3VtZW50cyIsInNsaWNlIiwiZGVmaW5lUHJvcGVydGllcyIsIk1hdGVyaWFsIiwiZW51bWVyYWJsZSIsInZhbHVlIiwidmVydGV4U2hhZGVycyIsImZyYWdtZW50cyIsInVuaWZvcm1zIiwibWF0ZXJpYWwiLCJnZXRTaGFkZXJCeVR5cGUiLCJ0eXBlIiwic291cmNlIiwic2hhZGVyIiwiY3JlYXRlU2hhZGVyIiwic2hhZGVyU291cmNlIiwiY29tcGlsZVNoYWRlciIsImdldFNoYWRlclBhcmFtZXRlciIsIkNPTVBJTEVfU1RBVFVTIiwiZXJyb3IiLCJnZXRTaGFkZXJJbmZvTG9nIiwiZ2V0VW5pZm9ybVZhcmlhYmxlRGVjbGFyYXRpb25zIiwiZW50cmllcyIsIm1hcCIsInVuaWZvcm0iLCJnZXREZWNsYXJhdGlvbiIsInVuaWZvcm1JbnN0YW5jZXMiLCJwcmVmaXgiLCJ2ZXJ0ZXhTb3VyY2UiLCJjb21tb25Vbmlmb3JtcyIsIlNvdXJjZSIsInZlcnRleFNoYWRlciIsIlZFUlRFWF9TSEFERVIiLCJmcmFnbWVudFNoYWRlciIsIkZSQUdNRU5UX1NIQURFUiIsInByb2dyYW0iLCJjcmVhdGVQcm9ncmFtIiwiYXR0YWNoU2hhZGVyIiwibGlua1Byb2dyYW0iLCJnZXRQcm9ncmFtUGFyYW1ldGVyIiwiTElOS19TVEFUVVMiLCJnZXRQcm9ncmFtSW5mb0xvZyIsInVzZVByb2dyYW0iLCJhdHRhY2hVbmlmb3JtcyIsIm5hbWUiLCJmb3JFYWNoIiwiaSIsInB1c2giLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJVbmlmb3JtIiwidHlwZUZuIiwiZmxvYXQiLCJpbnQiLCJ2ZWMyIiwidmVjMyIsInZlYzQiLCJtYXQ0IiwidXBkYXRlIiwidHJhbnNwb3NlIiwiZXhjbHVkZUZyb20iLCJuYW1lX25vX3ByZWZpeCIsInJlcGxhY2UiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsIlBsYW5lR2VvbWV0cnkiLCJvcmllbnRhdGlvbiIsImNyZWF0ZUJ1ZmZlciIsImF0dHJpYnV0ZXMiLCJwb3NpdGlvbiIsIkF0dHJpYnV0ZSIsInRhcmdldCIsIkFSUkFZX0JVRkZFUiIsInNpemUiLCJ1diIsInV2Tm9ybSIsImluZGV4IiwiRUxFTUVOVF9BUlJBWV9CVUZGRVIiLCJVTlNJR05FRF9TSE9SVCIsInNldFRvcG9sb2d5IiwieFNlZ0NvdW50IiwieVNlZ0NvdW50IiwidmVydGV4Q291bnQiLCJxdWFkQ291bnQiLCJ2YWx1ZXMiLCJGbG9hdDMyQXJyYXkiLCJVaW50MTZBcnJheSIsInMiLCJnZW9tZXRyeSIsIm8iLCJyIiwic2VnbWVudF93aWR0aCIsInNlZ21lbnRfaGVpZ2h0IiwieUluZGV4IiwieEluZGV4IiwibCIsIk1lc2giLCJtZXNoIiwid2lyZWZyYW1lIiwiYXR0cmlidXRlSW5zdGFuY2VzIiwiYXR0cmlidXRlIiwiYXR0YWNoIiwiZHJhdyIsInVzZSIsImRyYXdFbGVtZW50cyIsIkxJTkVTIiwiVFJJQU5HTEVTIiwicmVtb3ZlIiwiZmlsdGVyIiwiRkxPQVQiLCJub3JtYWxpemVkIiwiYnVmZmVyIiwiYmluZEJ1ZmZlciIsImJ1ZmZlckRhdGEiLCJTVEFUSUNfRFJBVyIsImdldEF0dHJpYkxvY2F0aW9uIiwiZW5hYmxlVmVydGV4QXR0cmliQXJyYXkiLCJ2ZXJ0ZXhBdHRyaWJQb2ludGVyIiwiYSIsInByb2plY3Rpb25NYXRyaXgiLCJtb2RlbFZpZXdNYXRyaXgiLCJyZXNvbHV0aW9uIiwiYXNwZWN0UmF0aW8iLCJ2aWV3cG9ydCIsInNldE9ydGhvZ3JhcGhpY0NhbWVyYSIsInJlbmRlciIsImNsZWFyQ29sb3IiLCJjbGVhckRlcHRoIiwib2JqZWN0IiwicHJvcGVydHlOYW1lIiwidmFsIiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIkdyYWRpZW50IiwiY2xlYXJUaW1lb3V0Iiwic2Nyb2xsaW5nVGltZW91dCIsInNldFRpbWVvdXQiLCJoYW5kbGVTY3JvbGxFbmQiLCJzY3JvbGxpbmdSZWZyZXNoRGVsYXkiLCJpc0dyYWRpZW50TGVnZW5kVmlzaWJsZSIsImhpZGVHcmFkaWVudExlZ2VuZCIsImNvbmYiLCJwbGF5aW5nIiwiaXNTY3JvbGxpbmciLCJwYXVzZSIsImlzSW50ZXJzZWN0aW5nIiwicGxheSIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJtaW5pZ2wiLCJjZWlsIiwiZGVuc2l0eSIsInVfc2hhZG93X3Bvd2VyIiwiaXNNZXRhS2V5IiwibWV0YUtleSIsImlzTW91c2VEb3duIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYW5pbWF0ZSIsInNob3VsZFNraXBGcmFtZSIsIm1pbiIsImxhc3QiLCJ1X3RpbWUiLCJpc1N0YXRpYyIsImRpc2Nvbm5lY3QiLCJpc0xvYWRlZENsYXNzIiwiZWwiLCJjbGFzc0xpc3QiLCJhZGQiLCJwYXJlbnRFbGVtZW50Iiwic2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yIiwiY29ubmVjdCIsInNoYWRlckZpbGVzIiwidmVydGV4Iiwibm9pc2UiLCJibGVuZCIsImZyYWdtZW50IiwicHJlc2V0TmFtZSIsInpvb20iLCJyb3RhdGlvbiIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJjb21wdXRlZENhbnZhc1N0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIndhaXRGb3JDc3NWYXJzIiwic2Nyb2xsT2JzZXJ2ZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlU2Nyb2xsIiwiaGFuZGxlTW91c2VEb3duIiwiaGFuZGxlTW91c2VVcCIsImhhbmRsZUtleURvd24iLCJyZXNpemUiLCJpbml0TWF0ZXJpYWwiLCJ1X2Rhcmtlbl90b3AiLCJkYXRhc2V0IiwianNEYXJrZW5Ub3AiLCJ1X2FjdGl2ZV9jb2xvcnMiLCJhY3RpdmVDb2xvcnMiLCJ1X2dsb2JhbCIsIm5vaXNlRnJlcSIsImZyZXFYIiwiZnJlcVkiLCJub2lzZVNwZWVkIiwidV92ZXJ0RGVmb3JtIiwiaW5jbGluZSIsInNpbiIsImFuZ2xlIiwiY29zIiwib2Zmc2V0VG9wIiwib2Zmc2V0Qm90dG9tIiwibm9pc2VBbXAiLCJhbXAiLCJub2lzZUZsb3ciLCJub2lzZVNlZWQiLCJzZWVkIiwidV9iYXNlQ29sb3IiLCJzZWN0aW9uQ29sb3JzIiwidV93YXZlTGF5ZXJzIiwiY29sb3IiLCJub2lzZUZsb29yIiwibm9pc2VDZWlsIiwiaW5pdE1lc2giLCJoaWRkZW4iLCJwYXJzZUludCIsInVwZGF0ZUZyZXF1ZW5jeSIsInRvZ2dsZUNvbG9yIiwic2hvd0dyYWRpZW50TGVnZW5kIiwibWluV2lkdGgiLCJib2R5IiwiaW5pdCIsImluaXRHcmFkaWVudENvbG9ycyIsImFkZEV2ZW50TGlzdGVuZXIiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiYWRkSXNMb2FkZWRDbGFzcyIsImNzc1ZhclJldHJpZXMiLCJtYXhDc3NWYXJSZXRyaWVzIiwiY3NzUHJvcGVydHlOYW1lIiwiaGV4IiwidHJpbSIsImhleFRlbXAiLCJzdWJzdHIiLCJzcGxpdCIsIkJvb2xlYW4iXSwibWFwcGluZ3MiOiJBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0EsU0FBU0EsY0FBVCxDQUF3QkMsT0FBeEIsRUFBaUM7QUFDN0IsU0FB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QUExRCxDQUErRCxFQUEvRCxDQUFoQjtBQUNBOE8sV0FBRyxHQUFJLElBQUdFLE9BQVEsRUFBbEI7QUFDSDs7QUFDRCxhQUFPRixHQUFHLElBQUssS0FBSUEsR0FBRyxDQUFDRyxNQUFKLENBQVcsQ0FBWCxDQUFjLEVBQWpDO0FBQ0gsS0FSb0IsRUFRbEJwSSxNQVJrQixDQVFYc0ksT0FSVyxFQVFGMU4sR0FSRSxDQVFFN0QsY0FSRixDQUFyQjtBQVNIOztBQTNOaUI7QUFpT3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vYXBpL2dyYWRpZW50LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiAgIFN0cmlwZSBXZWJHbCBHcmFkaWVudCBBbmltYXRpb25cbiogICBBbGwgQ3JlZGl0cyB0byBTdHJpcGUuY29tXG4qICAgU2Nyb2xsT2JzZXJ2ZXIgZnVuY3Rpb25hbGl0eSB0byBkaXNhYmxlIGFuaW1hdGlvbiB3aGVuIG5vdCBzY3JvbGxlZCBpbnRvIHZpZXcgaGFzIGJlZW4gZGlzYWJsZWQgYW5kIFxuKiAgIGNvbW1lbnRlZCBvdXQgZm9yIG5vdy5cbiogICBodHRwczovL2tldmluaHVmbmFnbC5jb21cbiovXG5cblxuLy9Db252ZXJ0aW5nIGNvbG9ycyB0byBwcm9wZXIgZm9ybWF0XG5mdW5jdGlvbiBub3JtYWxpemVDb2xvcihoZXhDb2RlKSB7XG4gICAgcmV0dXJuIFsoaGV4Q29kZSA+PiAxNiAmIDI1NSkgLyAyNTUsIChoZXhDb2RlID4+IDggJiAyNTUpIC8gMjU1LCAoMjU1ICYgaGV4Q29kZSkgLyAyNTVdXG59IFtcIlNDUkVFTlwiLCBcIkxJTkVBUl9MSUdIVFwiXS5yZWR1Y2UoKGhleENvZGUsIHQsIG4pID0+IE9iamVjdC5hc3NpZ24oaGV4Q29kZSwge1xuICAgIFt0XTogblxufSksIHt9KTtcblxuLy9Fc3NlbnRpYWwgZnVuY3Rpb25hbGl0eSBvZiBXZWJHbFxuLy90ID0gd2lkdGhcbi8vbiA9IGhlaWdodFxuY2xhc3MgTWluaUdsIHtcbiAgICBjb25zdHJ1Y3RvcihjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGRlYnVnID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgX21pbmlHbCA9IHRoaXMsXG4gICAgICAgICAgICBkZWJ1Z19vdXRwdXQgPSAtMSAhPT0gZG9jdW1lbnQubG9jYXRpb24uc2VhcmNoLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImRlYnVnPXdlYmdsXCIpO1xuICAgICAgICBfbWluaUdsLmNhbnZhcyA9IGNhbnZhcywgX21pbmlHbC5nbCA9IF9taW5pR2wuY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCB7XG4gICAgICAgICAgICBhbnRpYWxpYXM6IHRydWVcbiAgICAgICAgfSksIF9taW5pR2wubWVzaGVzID0gW107XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBfbWluaUdsLmdsO1xuICAgICAgICB3aWR0aCAmJiBoZWlnaHQgJiYgdGhpcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpLCBfbWluaUdsLmxhc3REZWJ1Z01zZywgX21pbmlHbC5kZWJ1ZyA9IGRlYnVnICYmIGRlYnVnX291dHB1dCA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0gbmV3IERhdGU7XG4gICAgICAgICAgICB0IC0gX21pbmlHbC5sYXN0RGVidWdNc2cgPiAxZTMgJiYgY29uc29sZS5sb2coXCItLS1cIiksIGNvbnNvbGUubG9nKHQudG9Mb2NhbGVUaW1lU3RyaW5nKCkgKyBBcnJheShNYXRoLm1heCgwLCAzMiAtIGUubGVuZ3RoKSkuam9pbihcIiBcIikgKyBlICsgXCI6IFwiLCAuLi5BcnJheS5mcm9tKGFyZ3VtZW50cykuc2xpY2UoMSkpLCBfbWluaUdsLmxhc3REZWJ1Z01zZyA9IHRcbiAgICAgICAgfSA6ICgpID0+IHsgfSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX21pbmlHbCwge1xuICAgICAgICAgICAgTWF0ZXJpYWw6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2xhc3Mge1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhTaGFkZXJzLCBmcmFnbWVudHMsIHVuaWZvcm1zID0ge30pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNoYWRlckJ5VHlwZSh0eXBlLCBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGFkZXIgPSBjb250ZXh0LmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpLCBjb250ZXh0LmNvbXBpbGVTaGFkZXIoc2hhZGVyKSwgY29udGV4dC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBjb250ZXh0LkNPTVBJTEVfU1RBVFVTKSB8fCBjb25zb2xlLmVycm9yKGNvbnRleHQuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKSwgX21pbmlHbC5kZWJ1ZyhcIk1hdGVyaWFsLmNvbXBpbGVTaGFkZXJTb3VyY2VcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBzaGFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFVuaWZvcm1WYXJpYWJsZURlY2xhcmF0aW9ucyh1bmlmb3JtcywgdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyh1bmlmb3JtcykubWFwKChbdW5pZm9ybSwgdmFsdWVdKSA9PiB2YWx1ZS5nZXREZWNsYXJhdGlvbih1bmlmb3JtLCB0eXBlKSkuam9pbihcIlxcblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwudW5pZm9ybXMgPSB1bmlmb3JtcywgbWF0ZXJpYWwudW5pZm9ybUluc3RhbmNlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBcIlxcbiAgICAgICAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgICAgICAgICAgIFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwudmVydGV4U291cmNlID0gYFxcbiAgICAgICAgICAgICAgJHtwcmVmaXh9XFxuICAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjNCBwb3NpdGlvbjtcXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIHV2O1xcbiAgICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgdXZOb3JtO1xcbiAgICAgICAgICAgICAgJHtnZXRVbmlmb3JtVmFyaWFibGVEZWNsYXJhdGlvbnMoX21pbmlHbC5jb21tb25Vbmlmb3JtcywgXCJ2ZXJ0ZXhcIil9XFxuICAgICAgICAgICAgICAke2dldFVuaWZvcm1WYXJpYWJsZURlY2xhcmF0aW9ucyh1bmlmb3JtcywgXCJ2ZXJ0ZXhcIil9XFxuICAgICAgICAgICAgICAke3ZlcnRleFNoYWRlcnN9XFxuICAgICAgICAgICAgYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5Tb3VyY2UgPSBgXFxuICAgICAgICAgICAgICAke3ByZWZpeH1cXG4gICAgICAgICAgICAgICR7Z2V0VW5pZm9ybVZhcmlhYmxlRGVjbGFyYXRpb25zKF9taW5pR2wuY29tbW9uVW5pZm9ybXMsIFwiZnJhZ21lbnRcIil9XFxuICAgICAgICAgICAgICAke2dldFVuaWZvcm1WYXJpYWJsZURlY2xhcmF0aW9ucyh1bmlmb3JtcywgXCJmcmFnbWVudFwiKX1cXG4gICAgICAgICAgICAgICR7ZnJhZ21lbnRzfVxcbiAgICAgICAgICAgIGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwudmVydGV4U2hhZGVyID0gZ2V0U2hhZGVyQnlUeXBlKGNvbnRleHQuVkVSVEVYX1NIQURFUiwgbWF0ZXJpYWwudmVydGV4U291cmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciA9IGdldFNoYWRlckJ5VHlwZShjb250ZXh0LkZSQUdNRU5UX1NIQURFUiwgbWF0ZXJpYWwuU291cmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5wcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hdHRhY2hTaGFkZXIobWF0ZXJpYWwucHJvZ3JhbSwgbWF0ZXJpYWwudmVydGV4U2hhZGVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmF0dGFjaFNoYWRlcihtYXRlcmlhbC5wcm9ncmFtLCBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5rUHJvZ3JhbShtYXRlcmlhbC5wcm9ncmFtKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmdldFByb2dyYW1QYXJhbWV0ZXIobWF0ZXJpYWwucHJvZ3JhbSwgY29udGV4dC5MSU5LX1NUQVRVUykgfHwgY29uc29sZS5lcnJvcihjb250ZXh0LmdldFByb2dyYW1JbmZvTG9nKG1hdGVyaWFsLnByb2dyYW0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnVzZVByb2dyYW0obWF0ZXJpYWwucHJvZ3JhbSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwuYXR0YWNoVW5pZm9ybXModm9pZCAwLCBfbWluaUdsLmNvbW1vblVuaWZvcm1zKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5hdHRhY2hVbmlmb3Jtcyh2b2lkIDAsIG1hdGVyaWFsLnVuaWZvcm1zKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vdCA9IHVuaWZvcm1cbiAgICAgICAgICAgICAgICAgICAgYXR0YWNoVW5pZm9ybXMobmFtZSwgdW5pZm9ybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbiAgPSBtYXRlcmlhbFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBuYW1lID8gT2JqZWN0LmVudHJpZXModW5pZm9ybXMpLmZvckVhY2goKFtuYW1lLCB1bmlmb3JtXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLmF0dGFjaFVuaWZvcm1zKG5hbWUsIHVuaWZvcm0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSA6IFwiYXJyYXlcIiA9PSB1bmlmb3Jtcy50eXBlID8gdW5pZm9ybXMudmFsdWUuZm9yRWFjaCgodW5pZm9ybSwgaSkgPT4gbWF0ZXJpYWwuYXR0YWNoVW5pZm9ybXMoYCR7bmFtZX1bJHtpfV1gLCB1bmlmb3JtKSkgOiBcInN0cnVjdFwiID09IHVuaWZvcm1zLnR5cGUgPyBPYmplY3QuZW50cmllcyh1bmlmb3Jtcy52YWx1ZSkuZm9yRWFjaCgoW3VuaWZvcm0sIGldKSA9PiBtYXRlcmlhbC5hdHRhY2hVbmlmb3JtcyhgJHtuYW1lfS4ke3VuaWZvcm19YCwgaSkpIDogKF9taW5pR2wuZGVidWcoXCJNYXRlcmlhbC5hdHRhY2hVbmlmb3Jtc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtOiB1bmlmb3Jtc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksIG1hdGVyaWFsLnVuaWZvcm1JbnN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybTogdW5pZm9ybXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGNvbnRleHQuZ2V0VW5pZm9ybUxvY2F0aW9uKG1hdGVyaWFsLnByb2dyYW0sIG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBVbmlmb3JtOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNsYXNzIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJmbG9hdFwiLCBPYmplY3QuYXNzaWduKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlRm4gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQ6IFwiMWZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQ6IFwiMWlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyOiBcIjJmdlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzM6IFwiM2Z2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjNDogXCI0ZnZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXQ0OiBcIk1hdHJpeDRmdlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9W3RoaXMudHlwZV0gfHwgXCIxZlwiLCB0aGlzLnVwZGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHRoaXMudmFsdWUgJiYgY29udGV4dFtgdW5pZm9ybSR7dGhpcy50eXBlRm59YF0odmFsdWUsIDAgPT09IHRoaXMudHlwZUZuLmluZGV4T2YoXCJNYXRyaXhcIikgPyB0aGlzLnRyYW5zcG9zZSA6IHRoaXMudmFsdWUsIDAgPT09IHRoaXMudHlwZUZuLmluZGV4T2YoXCJNYXRyaXhcIikgPyB0aGlzLnZhbHVlIDogbnVsbClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2UgLSBuYW1lXG4gICAgICAgICAgICAgICAgICAgIC8vdCAtIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgLy9uIC0gbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIGdldERlY2xhcmF0aW9uKG5hbWUsIHR5cGUsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5pZm9ybSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5pZm9ybS5leGNsdWRlRnJvbSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImFycmF5XCIgPT09IHVuaWZvcm0udHlwZSkgcmV0dXJuIHVuaWZvcm0udmFsdWVbMF0uZ2V0RGVjbGFyYXRpb24obmFtZSwgdHlwZSwgdW5pZm9ybS52YWx1ZS5sZW5ndGgpICsgYFxcbmNvbnN0IGludCAke25hbWV9X2xlbmd0aCA9ICR7dW5pZm9ybS52YWx1ZS5sZW5ndGh9O2A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RydWN0XCIgPT09IHVuaWZvcm0udHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZV9ub19wcmVmaXggPSBuYW1lLnJlcGxhY2UoXCJ1X1wiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWVfbm9fcHJlZml4ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVfbm9fcHJlZml4LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVfbm9fcHJlZml4LnNsaWNlKDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYHVuaWZvcm0gc3RydWN0ICR7bmFtZV9ub19wcmVmaXh9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHVuaWZvcm0udmFsdWUpLm1hcCgoW25hbWUsIHVuaWZvcm1dKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uZ2V0RGVjbGFyYXRpb24obmFtZSwgdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL151bmlmb3JtLywgXCJcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgYFxcbn0gJHtuYW1lfSR7bGVuZ3RoID4gMCA/IGBbJHtsZW5ndGh9XWAgOiBcIlwifTtgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgdW5pZm9ybSAke3VuaWZvcm0udHlwZX0gJHtuYW1lfSR7bGVuZ3RoID4gMCA/IGBbJHtsZW5ndGh9XWAgOiBcIlwifTtgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgUGxhbmVHZW9tZXRyeToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjbGFzcyB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIG4sIGksIG9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNyZWF0ZUJ1ZmZlcigpLCB0aGlzLmF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG5ldyBfbWluaUdsLkF0dHJpYnV0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogY29udGV4dC5BUlJBWV9CVUZGRVIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1djogbmV3IF9taW5pR2wuQXR0cmlidXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBjb250ZXh0LkFSUkFZX0JVRkZFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2Tm9ybTogbmV3IF9taW5pR2wuQXR0cmlidXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBjb250ZXh0LkFSUkFZX0JVRkZFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBuZXcgX21pbmlHbC5BdHRyaWJ1dGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGNvbnRleHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGNvbnRleHQuVU5TSUdORURfU0hPUlRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5zZXRUb3BvbG9neShuLCBpKSwgdGhpcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQsIG9yaWVudGF0aW9uKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFRvcG9sb2d5KGUgPSAxLCB0ID0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLnhTZWdDb3VudCA9IGUsIG4ueVNlZ0NvdW50ID0gdCwgbi52ZXJ0ZXhDb3VudCA9IChuLnhTZWdDb3VudCArIDEpICogKG4ueVNlZ0NvdW50ICsgMSksIG4ucXVhZENvdW50ID0gbi54U2VnQ291bnQgKiBuLnlTZWdDb3VudCAqIDIsIG4uYXR0cmlidXRlcy51di52YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KDIgKiBuLnZlcnRleENvdW50KSwgbi5hdHRyaWJ1dGVzLnV2Tm9ybS52YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KDIgKiBuLnZlcnRleENvdW50KSwgbi5hdHRyaWJ1dGVzLmluZGV4LnZhbHVlcyA9IG5ldyBVaW50MTZBcnJheSgzICogbi5xdWFkQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPD0gbi55U2VnQ291bnQ7IGUrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8PSBuLnhTZWdDb3VudDsgdCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBlICogKG4ueFNlZ0NvdW50ICsgMSkgKyB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobi5hdHRyaWJ1dGVzLnV2LnZhbHVlc1syICogaV0gPSB0IC8gbi54U2VnQ291bnQsIG4uYXR0cmlidXRlcy51di52YWx1ZXNbMiAqIGkgKyAxXSA9IDEgLSBlIC8gbi55U2VnQ291bnQsIG4uYXR0cmlidXRlcy51dk5vcm0udmFsdWVzWzIgKiBpXSA9IHQgLyBuLnhTZWdDb3VudCAqIDIgLSAxLCBuLmF0dHJpYnV0ZXMudXZOb3JtLnZhbHVlc1syICogaSArIDFdID0gMSAtIGUgLyBuLnlTZWdDb3VudCAqIDIsIHQgPCBuLnhTZWdDb3VudCAmJiBlIDwgbi55U2VnQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBlICogbi54U2VnQ291bnQgKyB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbi5hdHRyaWJ1dGVzLmluZGV4LnZhbHVlc1s2ICogc10gPSBpLCBuLmF0dHJpYnV0ZXMuaW5kZXgudmFsdWVzWzYgKiBzICsgMV0gPSBpICsgMSArIG4ueFNlZ0NvdW50LCBuLmF0dHJpYnV0ZXMuaW5kZXgudmFsdWVzWzYgKiBzICsgMl0gPSBpICsgMSwgbi5hdHRyaWJ1dGVzLmluZGV4LnZhbHVlc1s2ICogcyArIDNdID0gaSArIDEsIG4uYXR0cmlidXRlcy5pbmRleC52YWx1ZXNbNiAqIHMgKyA0XSA9IGkgKyAxICsgbi54U2VnQ291bnQsIG4uYXR0cmlidXRlcy5pbmRleC52YWx1ZXNbNiAqIHMgKyA1XSA9IGkgKyAyICsgbi54U2VnQ291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG4uYXR0cmlidXRlcy51di51cGRhdGUoKSwgbi5hdHRyaWJ1dGVzLnV2Tm9ybS51cGRhdGUoKSwgbi5hdHRyaWJ1dGVzLmluZGV4LnVwZGF0ZSgpLCBfbWluaUdsLmRlYnVnKFwiR2VvbWV0cnkuc2V0VG9wb2xvZ3lcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2OiBuLmF0dHJpYnV0ZXMudXYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXZOb3JtOiBuLmF0dHJpYnV0ZXMudXZOb3JtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBuLmF0dHJpYnV0ZXMuaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0U2l6ZSh3aWR0aCA9IDEsIGhlaWdodCA9IDEsIG9yaWVudGF0aW9uID0gXCJ4elwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS53aWR0aCA9IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmhlaWdodCA9IGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24udmFsdWVzICYmIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24udmFsdWVzLmxlbmd0aCA9PT0gMyAqIGdlb21ldHJ5LnZlcnRleENvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24udmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSgzICogZ2VvbWV0cnkudmVydGV4Q291bnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG8gPSB3aWR0aCAvIC0yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBoZWlnaHQgLyAtMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50X3dpZHRoID0gd2lkdGggLyBnZW9tZXRyeS54U2VnQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBnZW9tZXRyeS55U2VnQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB5SW5kZXggPSAwOyB5SW5kZXggPD0gZ2VvbWV0cnkueVNlZ0NvdW50OyB5SW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSByICsgeUluZGV4ICogc2VnbWVudF9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeEluZGV4ID0gMDsgeEluZGV4IDw9IGdlb21ldHJ5LnhTZWdDb3VudDsgeEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IG8gKyB4SW5kZXggKiBzZWdtZW50X3dpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHlJbmRleCAqIChnZW9tZXRyeS54U2VnQ291bnQgKyAxKSArIHhJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi52YWx1ZXNbMyAqIGwgKyBcInh5elwiLmluZGV4T2Yob3JpZW50YXRpb25bMF0pXSA9IHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLnZhbHVlc1szICogbCArIFwieHl6XCIuaW5kZXhPZihvcmllbnRhdGlvblsxXSldID0gLXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLnVwZGF0ZSgpLCBfbWluaUdsLmRlYnVnKFwiR2VvbWV0cnkuc2V0U2l6ZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTWVzaDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjbGFzcyB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKGdlb21ldHJ5LCBtYXRlcmlhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzaCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoLmdlb21ldHJ5ID0gZ2VvbWV0cnksIG1lc2gubWF0ZXJpYWwgPSBtYXRlcmlhbCwgbWVzaC53aXJlZnJhbWUgPSAhMSwgbWVzaC5hdHRyaWJ1dGVJbnN0YW5jZXMgPSBbXSwgT2JqZWN0LmVudHJpZXMobWVzaC5nZW9tZXRyeS5hdHRyaWJ1dGVzKS5mb3JFYWNoKChbZSwgYXR0cmlidXRlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc2guYXR0cmlidXRlSW5zdGFuY2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6IGF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGF0dHJpYnV0ZS5hdHRhY2goZSwgbWVzaC5tYXRlcmlhbC5wcm9ncmFtKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgX21pbmlHbC5tZXNoZXMucHVzaChtZXNoKSwgX21pbmlHbC5kZWJ1ZyhcIk1lc2guY29uc3RydWN0b3JcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc2g6IG1lc2hcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZHJhdygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQudXNlUHJvZ3JhbSh0aGlzLm1hdGVyaWFsLnByb2dyYW0pLCB0aGlzLm1hdGVyaWFsLnVuaWZvcm1JbnN0YW5jZXMuZm9yRWFjaCgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm06IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pID0+IGUudXBkYXRlKHQpKSwgdGhpcy5hdHRyaWJ1dGVJbnN0YW5jZXMuZm9yRWFjaCgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkgPT4gZS51c2UodCkpLCBjb250ZXh0LmRyYXdFbGVtZW50cyh0aGlzLndpcmVmcmFtZSA/IGNvbnRleHQuTElORVMgOiBjb250ZXh0LlRSSUFOR0xFUywgdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLmluZGV4LnZhbHVlcy5sZW5ndGgsIGNvbnRleHQuVU5TSUdORURfU0hPUlQsIDApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX21pbmlHbC5tZXNoZXMgPSBfbWluaUdsLm1lc2hlcy5maWx0ZXIoZSA9PiBlICE9IHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQXR0cmlidXRlOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNsYXNzIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5GTE9BVCwgdGhpcy5ub3JtYWxpemVkID0gITEsIHRoaXMuYnVmZmVyID0gY29udGV4dC5jcmVhdGVCdWZmZXIoKSwgT2JqZWN0LmFzc2lnbih0aGlzLCBlKSwgdGhpcy51cGRhdGUoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gdGhpcy52YWx1ZXMgJiYgKGNvbnRleHQuYmluZEJ1ZmZlcih0aGlzLnRhcmdldCwgdGhpcy5idWZmZXIpLCBjb250ZXh0LmJ1ZmZlckRhdGEodGhpcy50YXJnZXQsIHRoaXMudmFsdWVzLCBjb250ZXh0LlNUQVRJQ19EUkFXKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhdHRhY2goZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbiA9IGNvbnRleHQuZ2V0QXR0cmliTG9jYXRpb24odCwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXQgPT09IGNvbnRleHQuQVJSQVlfQlVGRkVSICYmIChjb250ZXh0LmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KG4pLCBjb250ZXh0LnZlcnRleEF0dHJpYlBvaW50ZXIobiwgdGhpcy5zaXplLCB0aGlzLnR5cGUsIHRoaXMubm9ybWFsaXplZCwgMCwgMCkpLCBuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXNlKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYmluZEJ1ZmZlcih0aGlzLnRhcmdldCwgdGhpcy5idWZmZXIpLCB0aGlzLnRhcmdldCA9PT0gY29udGV4dC5BUlJBWV9CVUZGRVIgJiYgKGNvbnRleHQuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoZSksIGNvbnRleHQudmVydGV4QXR0cmliUG9pbnRlcihlLCB0aGlzLnNpemUsIHRoaXMudHlwZSwgdGhpcy5ub3JtYWxpemVkLCAwLCAwKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGEgPSBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XG4gICAgICAgIF9taW5pR2wuY29tbW9uVW5pZm9ybXMgPSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uTWF0cml4OiBuZXcgX21pbmlHbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm1hdDRcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogYVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtb2RlbFZpZXdNYXRyaXg6IG5ldyBfbWluaUdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibWF0NFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHJlc29sdXRpb246IG5ldyBfbWluaUdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidmVjMlwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBbMSwgMV1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYXNwZWN0UmF0aW86IG5ldyBfbWluaUdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogMVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRTaXplKGUgPSA2NDAsIHQgPSA0ODApIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IGUsIHRoaXMuaGVpZ2h0ID0gdCwgdGhpcy5jYW52YXMud2lkdGggPSBlLCB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0LCB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIGUsIHQpLCB0aGlzLmNvbW1vblVuaWZvcm1zLnJlc29sdXRpb24udmFsdWUgPSBbZSwgdF0sIHRoaXMuY29tbW9uVW5pZm9ybXMuYXNwZWN0UmF0aW8udmFsdWUgPSBlIC8gdCwgdGhpcy5kZWJ1ZyhcIk1pbmlHTC5zZXRTaXplXCIsIHtcbiAgICAgICAgICAgIHdpZHRoOiBlLFxuICAgICAgICAgICAgaGVpZ2h0OiB0XG4gICAgICAgIH0pXG4gICAgfVxuICAgIC8vbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXJcbiAgICBzZXRPcnRob2dyYXBoaWNDYW1lcmEoZSA9IDAsIHQgPSAwLCBuID0gMCwgaSA9IC0yZTMsIHMgPSAyZTMpIHtcbiAgICAgICAgdGhpcy5jb21tb25Vbmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LnZhbHVlID0gWzIgLyB0aGlzLndpZHRoLCAwLCAwLCAwLCAwLCAyIC8gdGhpcy5oZWlnaHQsIDAsIDAsIDAsIDAsIDIgLyAoaSAtIHMpLCAwLCBlLCB0LCBuLCAxXSwgdGhpcy5kZWJ1ZyhcInNldE9ydGhvZ3JhcGhpY0NhbWVyYVwiLCB0aGlzLmNvbW1vblVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXgudmFsdWUpXG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5nbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApLCB0aGlzLmdsLmNsZWFyRGVwdGgoMSksIHRoaXMubWVzaGVzLmZvckVhY2goZSA9PiBlLmRyYXcoKSlcbiAgICB9XG59XG5cblxuXG4vL1NldHMgaW5pdGlhbCBwcm9wZXJ0aWVzXG5mdW5jdGlvbiBlKG9iamVjdCwgcHJvcGVydHlOYW1lLCB2YWwpIHtcbiAgICByZXR1cm4gcHJvcGVydHlOYW1lIGluIG9iamVjdCA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgfSkgOiBvYmplY3RbcHJvcGVydHlOYW1lXSA9IHZhbCwgb2JqZWN0XG59XG5cbi8vR3JhZGllbnQgb2JqZWN0XG5leHBvcnQgY2xhc3MgR3JhZGllbnQge1xuICAgIGNvbnN0cnVjdG9yKC4uLnQpIHtcbiAgICAgICAgZSh0aGlzLCBcImVsXCIsIHZvaWQgMCksIGUodGhpcywgXCJjc3NWYXJSZXRyaWVzXCIsIDApLCBlKHRoaXMsIFwibWF4Q3NzVmFyUmV0cmllc1wiLCAyMDApLCBlKHRoaXMsIFwiYW5nbGVcIiwgMCksIGUodGhpcywgXCJpc0xvYWRlZENsYXNzXCIsICExKSwgZSh0aGlzLCBcImlzU2Nyb2xsaW5nXCIsICExKSwgLyplKHRoaXMsIFwiaXNTdGF0aWNcIiwgby5kaXNhYmxlQW1iaWVudEFuaW1hdGlvbnMoKSksKi8gZSh0aGlzLCBcInNjcm9sbGluZ1RpbWVvdXRcIiwgdm9pZCAwKSwgZSh0aGlzLCBcInNjcm9sbGluZ1JlZnJlc2hEZWxheVwiLCAyMDApLCBlKHRoaXMsIFwiaXNJbnRlcnNlY3RpbmdcIiwgITEpLCBlKHRoaXMsIFwic2hhZGVyRmlsZXNcIiwgdm9pZCAwKSwgZSh0aGlzLCBcInZlcnRleFNoYWRlclwiLCB2b2lkIDApLCBlKHRoaXMsIFwic2VjdGlvbkNvbG9yc1wiLCB2b2lkIDApLCBlKHRoaXMsIFwiY29tcHV0ZWRDYW52YXNTdHlsZVwiLCB2b2lkIDApLCBlKHRoaXMsIFwiY29uZlwiLCB2b2lkIDApLCBlKHRoaXMsIFwidW5pZm9ybXNcIiwgdm9pZCAwKSwgZSh0aGlzLCBcInRcIiwgMTI1MzEwNiksIGUodGhpcywgXCJsYXN0XCIsIDApLCBlKHRoaXMsIFwid2lkdGhcIiwgdm9pZCAwKSwgZSh0aGlzLCBcIm1pbldpZHRoXCIsIDExMTEpLCBlKHRoaXMsIFwiaGVpZ2h0XCIsIDYwMCksIGUodGhpcywgXCJ4U2VnQ291bnRcIiwgdm9pZCAwKSwgZSh0aGlzLCBcInlTZWdDb3VudFwiLCB2b2lkIDApLCBlKHRoaXMsIFwibWVzaFwiLCB2b2lkIDApLCBlKHRoaXMsIFwibWF0ZXJpYWxcIiwgdm9pZCAwKSwgZSh0aGlzLCBcImdlb21ldHJ5XCIsIHZvaWQgMCksIGUodGhpcywgXCJtaW5pZ2xcIiwgdm9pZCAwKSwgZSh0aGlzLCBcInNjcm9sbE9ic2VydmVyXCIsIHZvaWQgMCksIGUodGhpcywgXCJhbXBcIiwgMzIwKSwgZSh0aGlzLCBcInNlZWRcIiwgNSksIGUodGhpcywgXCJmcmVxWFwiLCAxNGUtNSksIGUodGhpcywgXCJmcmVxWVwiLCAyOWUtNSksIGUodGhpcywgXCJmcmVxRGVsdGFcIiwgMWUtNSksIGUodGhpcywgXCJhY3RpdmVDb2xvcnNcIiwgWzEsIDEsIDEsIDFdKSwgZSh0aGlzLCBcImlzTWV0YUtleVwiLCAhMSksIGUodGhpcywgXCJpc0dyYWRpZW50TGVnZW5kVmlzaWJsZVwiLCAhMSksIGUodGhpcywgXCJpc01vdXNlRG93blwiLCAhMSksIGUodGhpcywgXCJoYW5kbGVTY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2Nyb2xsaW5nVGltZW91dCksIHRoaXMuc2Nyb2xsaW5nVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5oYW5kbGVTY3JvbGxFbmQsIHRoaXMuc2Nyb2xsaW5nUmVmcmVzaERlbGF5KSwgdGhpcy5pc0dyYWRpZW50TGVnZW5kVmlzaWJsZSAmJiB0aGlzLmhpZGVHcmFkaWVudExlZ2VuZCgpLCB0aGlzLmNvbmYucGxheWluZyAmJiAodGhpcy5pc1Njcm9sbGluZyA9ICEwLCB0aGlzLnBhdXNlKCkpXG4gICAgICAgIH0pLCBlKHRoaXMsIFwiaGFuZGxlU2Nyb2xsRW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSAhMSwgdGhpcy5pc0ludGVyc2VjdGluZyAmJiB0aGlzLnBsYXkoKVxuICAgICAgICB9KSwgZSh0aGlzLCBcInJlc2l6ZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGgsIHRoaXMubWluaWdsLnNldFNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpLCB0aGlzLm1pbmlnbC5zZXRPcnRob2dyYXBoaWNDYW1lcmEoKSwgdGhpcy54U2VnQ291bnQgPSBNYXRoLmNlaWwodGhpcy53aWR0aCAqIHRoaXMuY29uZi5kZW5zaXR5WzBdKSwgdGhpcy55U2VnQ291bnQgPSBNYXRoLmNlaWwodGhpcy5oZWlnaHQgKiB0aGlzLmNvbmYuZGVuc2l0eVsxXSksIHRoaXMubWVzaC5nZW9tZXRyeS5zZXRUb3BvbG9neSh0aGlzLnhTZWdDb3VudCwgdGhpcy55U2VnQ291bnQpLCB0aGlzLm1lc2guZ2VvbWV0cnkuc2V0U2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCksIHRoaXMubWVzaC5tYXRlcmlhbC51bmlmb3Jtcy51X3NoYWRvd19wb3dlci52YWx1ZSA9IHRoaXMud2lkdGggPCA2MDAgPyA1IDogNlxuICAgICAgICB9KSwgZSh0aGlzLCBcImhhbmRsZU1vdXNlRG93blwiLCBlID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNHcmFkaWVudExlZ2VuZFZpc2libGUgJiYgKHRoaXMuaXNNZXRhS2V5ID0gZS5tZXRhS2V5LCB0aGlzLmlzTW91c2VEb3duID0gITAsICExID09PSB0aGlzLmNvbmYucGxheWluZyAmJiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlKSlcbiAgICAgICAgfSksIGUodGhpcywgXCJoYW5kbGVNb3VzZVVwXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNNb3VzZURvd24gPSAhMVxuICAgICAgICB9KSwgZSh0aGlzLCBcImFuaW1hdGVcIiwgZSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkU2tpcEZyYW1lKGUpIHx8IHRoaXMuaXNNb3VzZURvd24pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50ICs9IE1hdGgubWluKGUgLSB0aGlzLmxhc3QsIDFlMyAvIDE1KSwgdGhpcy5sYXN0ID0gZSwgdGhpcy5pc01vdXNlRG93bikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZSA9IDE2MDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc01ldGFLZXkgJiYgKGUgPSAtMTYwKSwgdGhpcy50ICs9IGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNoLm1hdGVyaWFsLnVuaWZvcm1zLnVfdGltZS52YWx1ZSA9IHRoaXMudCwgdGhpcy5taW5pZ2wucmVuZGVyKClcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKDAgIT09IHRoaXMubGFzdCAmJiB0aGlzLmlzU3RhdGljKSByZXR1cm4gdGhpcy5taW5pZ2wucmVuZGVyKCksIHZvaWQgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAoLyp0aGlzLmlzSW50ZXJzZWN0aW5nICYmICovdGhpcy5jb25mLnBsYXlpbmcgfHwgdGhpcy5pc01vdXNlRG93bikgJiYgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZSlcbiAgICAgICAgfSksIGUodGhpcywgXCJhZGRJc0xvYWRlZENsYXNzXCIsICgpID0+IHtcbiAgICAgICAgICAgIC8qdGhpcy5pc0ludGVyc2VjdGluZyAmJiAqLyF0aGlzLmlzTG9hZGVkQ2xhc3MgJiYgKHRoaXMuaXNMb2FkZWRDbGFzcyA9ICEwLCB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoXCJpc0xvYWRlZFwiKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVsLnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImlzTG9hZGVkXCIpXG4gICAgICAgIH0sIDNlMykpXG4gICAgICAgIH0pLCBlKHRoaXMsIFwicGF1c2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25mLnBsYXlpbmcgPSBmYWxzZVxuICAgICAgICB9KSwgZSh0aGlzLCBcInBsYXlcIiwgKCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZSksIHRoaXMuY29uZi5wbGF5aW5nID0gdHJ1ZVxuICAgICAgICB9KSwgZSh0aGlzLCBcImluaXRHcmFkaWVudFwiLCAoc2VsZWN0b3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pXG4gICAgfVxuICAgIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuc2hhZGVyRmlsZXMgPSB7XG4gICAgICAgICAgICB2ZXJ0ZXg6IFwidmFyeWluZyB2ZWMzIHZfY29sb3I7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgZmxvYXQgdGltZSA9IHVfdGltZSAqIHVfZ2xvYmFsLm5vaXNlU3BlZWQ7XFxuXFxuICB2ZWMyIG5vaXNlQ29vcmQgPSByZXNvbHV0aW9uICogdXZOb3JtICogdV9nbG9iYWwubm9pc2VGcmVxO1xcblxcbiAgdmVjMiBzdCA9IDEuIC0gdXZOb3JtLnh5O1xcblxcbiAgLy9cXG4gIC8vIFRpbHRpbmcgdGhlIHBsYW5lXFxuICAvL1xcblxcbiAgLy8gRnJvbnQtdG8tYmFjayB0aWx0XFxuICBmbG9hdCB0aWx0ID0gcmVzb2x1dGlvbi55IC8gMi4wICogdXZOb3JtLnk7XFxuXFxuICAvLyBMZWZ0LXRvLXJpZ2h0IGFuZ2xlXFxuICBmbG9hdCBpbmNsaW5lID0gcmVzb2x1dGlvbi54ICogdXZOb3JtLnggLyAyLjAgKiB1X3ZlcnREZWZvcm0uaW5jbGluZTtcXG5cXG4gIC8vIFVwLWRvd24gc2hpZnQgdG8gb2Zmc2V0IGluY2xpbmVcXG4gIGZsb2F0IG9mZnNldCA9IHJlc29sdXRpb24ueCAvIDIuMCAqIHVfdmVydERlZm9ybS5pbmNsaW5lICogbWl4KHVfdmVydERlZm9ybS5vZmZzZXRCb3R0b20sIHVfdmVydERlZm9ybS5vZmZzZXRUb3AsIHV2LnkpO1xcblxcbiAgLy9cXG4gIC8vIFZlcnRleCBub2lzZVxcbiAgLy9cXG5cXG4gIGZsb2F0IG5vaXNlID0gc25vaXNlKHZlYzMoXFxuICAgIG5vaXNlQ29vcmQueCAqIHVfdmVydERlZm9ybS5ub2lzZUZyZXEueCArIHRpbWUgKiB1X3ZlcnREZWZvcm0ubm9pc2VGbG93LFxcbiAgICBub2lzZUNvb3JkLnkgKiB1X3ZlcnREZWZvcm0ubm9pc2VGcmVxLnksXFxuICAgIHRpbWUgKiB1X3ZlcnREZWZvcm0ubm9pc2VTcGVlZCArIHVfdmVydERlZm9ybS5ub2lzZVNlZWRcXG4gICkpICogdV92ZXJ0RGVmb3JtLm5vaXNlQW1wO1xcblxcbiAgLy8gRmFkZSBub2lzZSB0byB6ZXJvIGF0IGVkZ2VzXFxuICBub2lzZSAqPSAxLjAgLSBwb3coYWJzKHV2Tm9ybS55KSwgMi4wKTtcXG5cXG4gIC8vIENsYW1wIHRvIDBcXG4gIG5vaXNlID0gbWF4KDAuMCwgbm9pc2UpO1xcblxcbiAgdmVjMyBwb3MgPSB2ZWMzKFxcbiAgICBwb3NpdGlvbi54LFxcbiAgICBwb3NpdGlvbi55ICsgdGlsdCArIGluY2xpbmUgKyBub2lzZSAtIG9mZnNldCxcXG4gICAgcG9zaXRpb24uelxcbiAgKTtcXG5cXG4gIC8vXFxuICAvLyBWZXJ0ZXggY29sb3IsIHRvIGJlIHBhc3NlZCB0byBmcmFnbWVudCBzaGFkZXJcXG4gIC8vXFxuXFxuICBpZiAodV9hY3RpdmVfY29sb3JzWzBdID09IDEuKSB7XFxuICAgIHZfY29sb3IgPSB1X2Jhc2VDb2xvcjtcXG4gIH1cXG5cXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgdV93YXZlTGF5ZXJzX2xlbmd0aDsgaSsrKSB7XFxuICAgIGlmICh1X2FjdGl2ZV9jb2xvcnNbaSArIDFdID09IDEuKSB7XFxuICAgICAgV2F2ZUxheWVycyBsYXllciA9IHVfd2F2ZUxheWVyc1tpXTtcXG5cXG4gICAgICBmbG9hdCBub2lzZSA9IHNtb290aHN0ZXAoXFxuICAgICAgICBsYXllci5ub2lzZUZsb29yLFxcbiAgICAgICAgbGF5ZXIubm9pc2VDZWlsLFxcbiAgICAgICAgc25vaXNlKHZlYzMoXFxuICAgICAgICAgIG5vaXNlQ29vcmQueCAqIGxheWVyLm5vaXNlRnJlcS54ICsgdGltZSAqIGxheWVyLm5vaXNlRmxvdyxcXG4gICAgICAgICAgbm9pc2VDb29yZC55ICogbGF5ZXIubm9pc2VGcmVxLnksXFxuICAgICAgICAgIHRpbWUgKiBsYXllci5ub2lzZVNwZWVkICsgbGF5ZXIubm9pc2VTZWVkXFxuICAgICAgICApKSAvIDIuMCArIDAuNVxcbiAgICAgICk7XFxuXFxuICAgICAgdl9jb2xvciA9IGJsZW5kTm9ybWFsKHZfY29sb3IsIGxheWVyLmNvbG9yLCBwb3cobm9pc2UsIDQuKSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vXFxuICAvLyBGaW5pc2hcXG4gIC8vXFxuXFxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvcywgMS4wKTtcXG59XCIsXG4gICAgICAgICAgICBub2lzZTogXCIvL1xcbi8vIERlc2NyaXB0aW9uIDogQXJyYXkgYW5kIHRleHR1cmVsZXNzIEdMU0wgMkQvM0QvNEQgc2ltcGxleFxcbi8vICAgICAgICAgICAgICAgbm9pc2UgZnVuY3Rpb25zLlxcbi8vICAgICAgQXV0aG9yIDogSWFuIE1jRXdhbiwgQXNoaW1hIEFydHMuXFxuLy8gIE1haW50YWluZXIgOiBzdGVndVxcbi8vICAgICBMYXN0bW9kIDogMjAxMTA4MjIgKGlqbSlcXG4vLyAgICAgTGljZW5zZSA6IENvcHlyaWdodCAoQykgMjAxMSBBc2hpbWEgQXJ0cy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4vLyAgICAgICAgICAgICAgIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZS5cXG4vLyAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hc2hpbWEvd2ViZ2wtbm9pc2VcXG4vLyAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9zdGVndS93ZWJnbC1ub2lzZVxcbi8vXFxuXFxudmVjMyBtb2QyODkodmVjMyB4KSB7XFxuICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wO1xcbn1cXG5cXG52ZWM0IG1vZDI4OSh2ZWM0IHgpIHtcXG4gIHJldHVybiB4IC0gZmxvb3IoeCAqICgxLjAgLyAyODkuMCkpICogMjg5LjA7XFxufVxcblxcbnZlYzQgcGVybXV0ZSh2ZWM0IHgpIHtcXG4gICAgcmV0dXJuIG1vZDI4OSgoKHgqMzQuMCkrMS4wKSp4KTtcXG59XFxuXFxudmVjNCB0YXlsb3JJbnZTcXJ0KHZlYzQgcilcXG57XFxuICByZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO1xcbn1cXG5cXG5mbG9hdCBzbm9pc2UodmVjMyB2KVxcbntcXG4gIGNvbnN0IHZlYzIgIEMgPSB2ZWMyKDEuMC82LjAsIDEuMC8zLjApIDtcXG4gIGNvbnN0IHZlYzQgIEQgPSB2ZWM0KDAuMCwgMC41LCAxLjAsIDIuMCk7XFxuXFxuLy8gRmlyc3QgY29ybmVyXFxuICB2ZWMzIGkgID0gZmxvb3IodiArIGRvdCh2LCBDLnl5eSkgKTtcXG4gIHZlYzMgeDAgPSAgIHYgLSBpICsgZG90KGksIEMueHh4KSA7XFxuXFxuLy8gT3RoZXIgY29ybmVyc1xcbiAgdmVjMyBnID0gc3RlcCh4MC55engsIHgwLnh5eik7XFxuICB2ZWMzIGwgPSAxLjAgLSBnO1xcbiAgdmVjMyBpMSA9IG1pbiggZy54eXosIGwuenh5ICk7XFxuICB2ZWMzIGkyID0gbWF4KCBnLnh5eiwgbC56eHkgKTtcXG5cXG4gIC8vICAgeDAgPSB4MCAtIDAuMCArIDAuMCAqIEMueHh4O1xcbiAgLy8gICB4MSA9IHgwIC0gaTEgICsgMS4wICogQy54eHg7XFxuICAvLyAgIHgyID0geDAgLSBpMiAgKyAyLjAgKiBDLnh4eDtcXG4gIC8vICAgeDMgPSB4MCAtIDEuMCArIDMuMCAqIEMueHh4O1xcbiAgdmVjMyB4MSA9IHgwIC0gaTEgKyBDLnh4eDtcXG4gIHZlYzMgeDIgPSB4MCAtIGkyICsgQy55eXk7IC8vIDIuMCpDLnggPSAxLzMgPSBDLnlcXG4gIHZlYzMgeDMgPSB4MCAtIEQueXl5OyAgICAgIC8vIC0xLjArMy4wKkMueCA9IC0wLjUgPSAtRC55XFxuXFxuLy8gUGVybXV0YXRpb25zXFxuICBpID0gbW9kMjg5KGkpO1xcbiAgdmVjNCBwID0gcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZShcXG4gICAgICAgICAgICBpLnogKyB2ZWM0KDAuMCwgaTEueiwgaTIueiwgMS4wICkpXFxuICAgICAgICAgICsgaS55ICsgdmVjNCgwLjAsIGkxLnksIGkyLnksIDEuMCApKVxcbiAgICAgICAgICArIGkueCArIHZlYzQoMC4wLCBpMS54LCBpMi54LCAxLjAgKSk7XFxuXFxuLy8gR3JhZGllbnRzOiA3eDcgcG9pbnRzIG92ZXIgYSBzcXVhcmUsIG1hcHBlZCBvbnRvIGFuIG9jdGFoZWRyb24uXFxuLy8gVGhlIHJpbmcgc2l6ZSAxNyoxNyA9IDI4OSBpcyBjbG9zZSB0byBhIG11bHRpcGxlIG9mIDQ5ICg0OSo2ID0gMjk0KVxcbiAgZmxvYXQgbl8gPSAwLjE0Mjg1NzE0Mjg1NzsgLy8gMS4wLzcuMFxcbiAgdmVjMyAgbnMgPSBuXyAqIEQud3l6IC0gRC54eng7XFxuXFxuICB2ZWM0IGogPSBwIC0gNDkuMCAqIGZsb29yKHAgKiBucy56ICogbnMueik7ICAvLyAgbW9kKHAsNyo3KVxcblxcbiAgdmVjNCB4XyA9IGZsb29yKGogKiBucy56KTtcXG4gIHZlYzQgeV8gPSBmbG9vcihqIC0gNy4wICogeF8gKTsgICAgLy8gbW9kKGosTilcXG5cXG4gIHZlYzQgeCA9IHhfICpucy54ICsgbnMueXl5eTtcXG4gIHZlYzQgeSA9IHlfICpucy54ICsgbnMueXl5eTtcXG4gIHZlYzQgaCA9IDEuMCAtIGFicyh4KSAtIGFicyh5KTtcXG5cXG4gIHZlYzQgYjAgPSB2ZWM0KCB4Lnh5LCB5Lnh5ICk7XFxuICB2ZWM0IGIxID0gdmVjNCggeC56dywgeS56dyApO1xcblxcbiAgLy92ZWM0IHMwID0gdmVjNChsZXNzVGhhbihiMCwwLjApKSoyLjAgLSAxLjA7XFxuICAvL3ZlYzQgczEgPSB2ZWM0KGxlc3NUaGFuKGIxLDAuMCkpKjIuMCAtIDEuMDtcXG4gIHZlYzQgczAgPSBmbG9vcihiMCkqMi4wICsgMS4wO1xcbiAgdmVjNCBzMSA9IGZsb29yKGIxKSoyLjAgKyAxLjA7XFxuICB2ZWM0IHNoID0gLXN0ZXAoaCwgdmVjNCgwLjApKTtcXG5cXG4gIHZlYzQgYTAgPSBiMC54enl3ICsgczAueHp5dypzaC54eHl5IDtcXG4gIHZlYzQgYTEgPSBiMS54enl3ICsgczEueHp5dypzaC56end3IDtcXG5cXG4gIHZlYzMgcDAgPSB2ZWMzKGEwLnh5LGgueCk7XFxuICB2ZWMzIHAxID0gdmVjMyhhMC56dyxoLnkpO1xcbiAgdmVjMyBwMiA9IHZlYzMoYTEueHksaC56KTtcXG4gIHZlYzMgcDMgPSB2ZWMzKGExLnp3LGgudyk7XFxuXFxuLy9Ob3JtYWxpc2UgZ3JhZGllbnRzXFxuICB2ZWM0IG5vcm0gPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KHAwLHAwKSwgZG90KHAxLHAxKSwgZG90KHAyLCBwMiksIGRvdChwMyxwMykpKTtcXG4gIHAwICo9IG5vcm0ueDtcXG4gIHAxICo9IG5vcm0ueTtcXG4gIHAyICo9IG5vcm0uejtcXG4gIHAzICo9IG5vcm0udztcXG5cXG4vLyBNaXggZmluYWwgbm9pc2UgdmFsdWVcXG4gIHZlYzQgbSA9IG1heCgwLjYgLSB2ZWM0KGRvdCh4MCx4MCksIGRvdCh4MSx4MSksIGRvdCh4Mix4MiksIGRvdCh4Myx4MykpLCAwLjApO1xcbiAgbSA9IG0gKiBtO1xcbiAgcmV0dXJuIDQyLjAgKiBkb3QoIG0qbSwgdmVjNCggZG90KHAwLHgwKSwgZG90KHAxLHgxKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdChwMix4MiksIGRvdChwMyx4MykgKSApO1xcbn1cIixcbiAgICAgICAgICAgIGJsZW5kOiBcIi8vXFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2phbWllb3dlbi9nbHNsLWJsZW5kXFxuLy9cXG5cXG4vLyBOb3JtYWxcXG5cXG52ZWMzIGJsZW5kTm9ybWFsKHZlYzMgYmFzZSwgdmVjMyBibGVuZCkge1xcblxcdHJldHVybiBibGVuZDtcXG59XFxuXFxudmVjMyBibGVuZE5vcm1hbCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kTm9ybWFsKGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gU2NyZWVuXFxuXFxuZmxvYXQgYmxlbmRTY3JlZW4oZmxvYXQgYmFzZSwgZmxvYXQgYmxlbmQpIHtcXG5cXHRyZXR1cm4gMS4wLSgoMS4wLWJhc2UpKigxLjAtYmxlbmQpKTtcXG59XFxuXFxudmVjMyBibGVuZFNjcmVlbih2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHRyZXR1cm4gdmVjMyhibGVuZFNjcmVlbihiYXNlLnIsYmxlbmQuciksYmxlbmRTY3JlZW4oYmFzZS5nLGJsZW5kLmcpLGJsZW5kU2NyZWVuKGJhc2UuYixibGVuZC5iKSk7XFxufVxcblxcbnZlYzMgYmxlbmRTY3JlZW4odmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZFNjcmVlbihiYXNlLCBibGVuZCkgKiBvcGFjaXR5ICsgYmFzZSAqICgxLjAgLSBvcGFjaXR5KSk7XFxufVxcblxcbi8vIE11bHRpcGx5XFxuXFxudmVjMyBibGVuZE11bHRpcGx5KHZlYzMgYmFzZSwgdmVjMyBibGVuZCkge1xcblxcdHJldHVybiBiYXNlKmJsZW5kO1xcbn1cXG5cXG52ZWMzIGJsZW5kTXVsdGlwbHkodmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZE11bHRpcGx5KGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gT3ZlcmxheVxcblxcbmZsb2F0IGJsZW5kT3ZlcmxheShmbG9hdCBiYXNlLCBmbG9hdCBibGVuZCkge1xcblxcdHJldHVybiBiYXNlPDAuNT8oMi4wKmJhc2UqYmxlbmQpOigxLjAtMi4wKigxLjAtYmFzZSkqKDEuMC1ibGVuZCkpO1xcbn1cXG5cXG52ZWMzIGJsZW5kT3ZlcmxheSh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHRyZXR1cm4gdmVjMyhibGVuZE92ZXJsYXkoYmFzZS5yLGJsZW5kLnIpLGJsZW5kT3ZlcmxheShiYXNlLmcsYmxlbmQuZyksYmxlbmRPdmVybGF5KGJhc2UuYixibGVuZC5iKSk7XFxufVxcblxcbnZlYzMgYmxlbmRPdmVybGF5KHZlYzMgYmFzZSwgdmVjMyBibGVuZCwgZmxvYXQgb3BhY2l0eSkge1xcblxcdHJldHVybiAoYmxlbmRPdmVybGF5KGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gSGFyZCBsaWdodFxcblxcbnZlYzMgYmxlbmRIYXJkTGlnaHQodmVjMyBiYXNlLCB2ZWMzIGJsZW5kKSB7XFxuXFx0cmV0dXJuIGJsZW5kT3ZlcmxheShibGVuZCxiYXNlKTtcXG59XFxuXFxudmVjMyBibGVuZEhhcmRMaWdodCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kSGFyZExpZ2h0KGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gU29mdCBsaWdodFxcblxcbmZsb2F0IGJsZW5kU29mdExpZ2h0KGZsb2F0IGJhc2UsIGZsb2F0IGJsZW5kKSB7XFxuXFx0cmV0dXJuIChibGVuZDwwLjUpPygyLjAqYmFzZSpibGVuZCtiYXNlKmJhc2UqKDEuMC0yLjAqYmxlbmQpKTooc3FydChiYXNlKSooMi4wKmJsZW5kLTEuMCkrMi4wKmJhc2UqKDEuMC1ibGVuZCkpO1xcbn1cXG5cXG52ZWMzIGJsZW5kU29mdExpZ2h0KHZlYzMgYmFzZSwgdmVjMyBibGVuZCkge1xcblxcdHJldHVybiB2ZWMzKGJsZW5kU29mdExpZ2h0KGJhc2UucixibGVuZC5yKSxibGVuZFNvZnRMaWdodChiYXNlLmcsYmxlbmQuZyksYmxlbmRTb2Z0TGlnaHQoYmFzZS5iLGJsZW5kLmIpKTtcXG59XFxuXFxudmVjMyBibGVuZFNvZnRMaWdodCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kU29mdExpZ2h0KGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gQ29sb3IgZG9kZ2VcXG5cXG5mbG9hdCBibGVuZENvbG9yRG9kZ2UoZmxvYXQgYmFzZSwgZmxvYXQgYmxlbmQpIHtcXG5cXHRyZXR1cm4gKGJsZW5kPT0xLjApP2JsZW5kOm1pbihiYXNlLygxLjAtYmxlbmQpLDEuMCk7XFxufVxcblxcbnZlYzMgYmxlbmRDb2xvckRvZGdlKHZlYzMgYmFzZSwgdmVjMyBibGVuZCkge1xcblxcdHJldHVybiB2ZWMzKGJsZW5kQ29sb3JEb2RnZShiYXNlLnIsYmxlbmQuciksYmxlbmRDb2xvckRvZGdlKGJhc2UuZyxibGVuZC5nKSxibGVuZENvbG9yRG9kZ2UoYmFzZS5iLGJsZW5kLmIpKTtcXG59XFxuXFxudmVjMyBibGVuZENvbG9yRG9kZ2UodmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZENvbG9yRG9kZ2UoYmFzZSwgYmxlbmQpICogb3BhY2l0eSArIGJhc2UgKiAoMS4wIC0gb3BhY2l0eSkpO1xcbn1cXG5cXG4vLyBDb2xvciBidXJuXFxuXFxuZmxvYXQgYmxlbmRDb2xvckJ1cm4oZmxvYXQgYmFzZSwgZmxvYXQgYmxlbmQpIHtcXG5cXHRyZXR1cm4gKGJsZW5kPT0wLjApP2JsZW5kOm1heCgoMS4wLSgoMS4wLWJhc2UpL2JsZW5kKSksMC4wKTtcXG59XFxuXFxudmVjMyBibGVuZENvbG9yQnVybih2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHRyZXR1cm4gdmVjMyhibGVuZENvbG9yQnVybihiYXNlLnIsYmxlbmQuciksYmxlbmRDb2xvckJ1cm4oYmFzZS5nLGJsZW5kLmcpLGJsZW5kQ29sb3JCdXJuKGJhc2UuYixibGVuZC5iKSk7XFxufVxcblxcbnZlYzMgYmxlbmRDb2xvckJ1cm4odmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZENvbG9yQnVybihiYXNlLCBibGVuZCkgKiBvcGFjaXR5ICsgYmFzZSAqICgxLjAgLSBvcGFjaXR5KSk7XFxufVxcblxcbi8vIFZpdmlkIExpZ2h0XFxuXFxuZmxvYXQgYmxlbmRWaXZpZExpZ2h0KGZsb2F0IGJhc2UsIGZsb2F0IGJsZW5kKSB7XFxuXFx0cmV0dXJuIChibGVuZDwwLjUpP2JsZW5kQ29sb3JCdXJuKGJhc2UsKDIuMCpibGVuZCkpOmJsZW5kQ29sb3JEb2RnZShiYXNlLCgyLjAqKGJsZW5kLTAuNSkpKTtcXG59XFxuXFxudmVjMyBibGVuZFZpdmlkTGlnaHQodmVjMyBiYXNlLCB2ZWMzIGJsZW5kKSB7XFxuXFx0cmV0dXJuIHZlYzMoYmxlbmRWaXZpZExpZ2h0KGJhc2UucixibGVuZC5yKSxibGVuZFZpdmlkTGlnaHQoYmFzZS5nLGJsZW5kLmcpLGJsZW5kVml2aWRMaWdodChiYXNlLmIsYmxlbmQuYikpO1xcbn1cXG5cXG52ZWMzIGJsZW5kVml2aWRMaWdodCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kVml2aWRMaWdodChiYXNlLCBibGVuZCkgKiBvcGFjaXR5ICsgYmFzZSAqICgxLjAgLSBvcGFjaXR5KSk7XFxufVxcblxcbi8vIExpZ2h0ZW5cXG5cXG5mbG9hdCBibGVuZExpZ2h0ZW4oZmxvYXQgYmFzZSwgZmxvYXQgYmxlbmQpIHtcXG5cXHRyZXR1cm4gbWF4KGJsZW5kLGJhc2UpO1xcbn1cXG5cXG52ZWMzIGJsZW5kTGlnaHRlbih2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHRyZXR1cm4gdmVjMyhibGVuZExpZ2h0ZW4oYmFzZS5yLGJsZW5kLnIpLGJsZW5kTGlnaHRlbihiYXNlLmcsYmxlbmQuZyksYmxlbmRMaWdodGVuKGJhc2UuYixibGVuZC5iKSk7XFxufVxcblxcbnZlYzMgYmxlbmRMaWdodGVuKHZlYzMgYmFzZSwgdmVjMyBibGVuZCwgZmxvYXQgb3BhY2l0eSkge1xcblxcdHJldHVybiAoYmxlbmRMaWdodGVuKGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gTGluZWFyIGJ1cm5cXG5cXG5mbG9hdCBibGVuZExpbmVhckJ1cm4oZmxvYXQgYmFzZSwgZmxvYXQgYmxlbmQpIHtcXG5cXHQvLyBOb3RlIDogU2FtZSBpbXBsZW1lbnRhdGlvbiBhcyBCbGVuZFN1YnRyYWN0ZlxcblxcdHJldHVybiBtYXgoYmFzZStibGVuZC0xLjAsMC4wKTtcXG59XFxuXFxudmVjMyBibGVuZExpbmVhckJ1cm4odmVjMyBiYXNlLCB2ZWMzIGJsZW5kKSB7XFxuXFx0Ly8gTm90ZSA6IFNhbWUgaW1wbGVtZW50YXRpb24gYXMgQmxlbmRTdWJ0cmFjdFxcblxcdHJldHVybiBtYXgoYmFzZStibGVuZC12ZWMzKDEuMCksdmVjMygwLjApKTtcXG59XFxuXFxudmVjMyBibGVuZExpbmVhckJ1cm4odmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZExpbmVhckJ1cm4oYmFzZSwgYmxlbmQpICogb3BhY2l0eSArIGJhc2UgKiAoMS4wIC0gb3BhY2l0eSkpO1xcbn1cXG5cXG4vLyBMaW5lYXIgZG9kZ2VcXG5cXG5mbG9hdCBibGVuZExpbmVhckRvZGdlKGZsb2F0IGJhc2UsIGZsb2F0IGJsZW5kKSB7XFxuXFx0Ly8gTm90ZSA6IFNhbWUgaW1wbGVtZW50YXRpb24gYXMgQmxlbmRBZGRmXFxuXFx0cmV0dXJuIG1pbihiYXNlK2JsZW5kLDEuMCk7XFxufVxcblxcbnZlYzMgYmxlbmRMaW5lYXJEb2RnZSh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHQvLyBOb3RlIDogU2FtZSBpbXBsZW1lbnRhdGlvbiBhcyBCbGVuZEFkZFxcblxcdHJldHVybiBtaW4oYmFzZStibGVuZCx2ZWMzKDEuMCkpO1xcbn1cXG5cXG52ZWMzIGJsZW5kTGluZWFyRG9kZ2UodmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZExpbmVhckRvZGdlKGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gTGluZWFyIGxpZ2h0XFxuXFxuZmxvYXQgYmxlbmRMaW5lYXJMaWdodChmbG9hdCBiYXNlLCBmbG9hdCBibGVuZCkge1xcblxcdHJldHVybiBibGVuZDwwLjU/YmxlbmRMaW5lYXJCdXJuKGJhc2UsKDIuMCpibGVuZCkpOmJsZW5kTGluZWFyRG9kZ2UoYmFzZSwoMi4wKihibGVuZC0wLjUpKSk7XFxufVxcblxcbnZlYzMgYmxlbmRMaW5lYXJMaWdodCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHRyZXR1cm4gdmVjMyhibGVuZExpbmVhckxpZ2h0KGJhc2UucixibGVuZC5yKSxibGVuZExpbmVhckxpZ2h0KGJhc2UuZyxibGVuZC5nKSxibGVuZExpbmVhckxpZ2h0KGJhc2UuYixibGVuZC5iKSk7XFxufVxcblxcbnZlYzMgYmxlbmRMaW5lYXJMaWdodCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kTGluZWFyTGlnaHQoYmFzZSwgYmxlbmQpICogb3BhY2l0eSArIGJhc2UgKiAoMS4wIC0gb3BhY2l0eSkpO1xcbn1cIixcbiAgICAgICAgICAgIGZyYWdtZW50OiBcInZhcnlpbmcgdmVjMyB2X2NvbG9yO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzMgY29sb3IgPSB2X2NvbG9yO1xcbiAgaWYgKHVfZGFya2VuX3RvcCA9PSAxLjApIHtcXG4gICAgdmVjMiBzdCA9IGdsX0ZyYWdDb29yZC54eS9yZXNvbHV0aW9uLnh5O1xcbiAgICBjb2xvci5nIC09IHBvdyhzdC55ICsgc2luKC0xMi4wKSAqIHN0LngsIHVfc2hhZG93X3Bvd2VyKSAqIDAuNDtcXG4gIH1cXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIDEuMCk7XFxufVwiXG4gICAgICAgIH0sXG4gICAgICAgICAgICB0aGlzLmNvbmYgPSB7XG4gICAgICAgICAgICAgICAgcHJlc2V0TmFtZTogXCJcIixcbiAgICAgICAgICAgICAgICB3aXJlZnJhbWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRlbnNpdHk6IFsuMDYsIC4xNl0sXG4gICAgICAgICAgICAgICAgem9vbTogMSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogMCxcbiAgICAgICAgICAgICAgICBwbGF5aW5nOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImNhbnZhc1wiKS5sZW5ndGggPCAxID8gY29uc29sZS5sb2coXCJESUQgTk9UIExPQUQgSEVSTyBTVFJJUEUgQ0FOVkFTXCIpIDogKFxuXG4gICAgICAgICAgICAgICAgdGhpcy5taW5pZ2wgPSBuZXcgTWluaUdsKHRoaXMuZWwsIG51bGwsIG51bGwsICEwKSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsICYmICh0aGlzLmNvbXB1dGVkQ2FudmFzU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuZWwpLCB0aGlzLndhaXRGb3JDc3NWYXJzKCkpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsT2JzZXJ2ZXIgPSBhd2FpdCBzLmNyZWF0ZSguMSwgITEpLFxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmVsKSxcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbE9ic2VydmVyLm9uU2VwYXJhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLmhhbmRsZVNjcm9sbCksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuaGFuZGxlTW91c2VEb3duKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuaGFuZGxlTW91c2VVcCksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmhhbmRsZUtleURvd24pLCB0aGlzLmlzSW50ZXJzZWN0aW5nID0gITEsIHRoaXMuY29uZi5wbGF5aW5nICYmIHRoaXMucGF1c2UoKVxuICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbE9ic2VydmVyLm9uSW50ZXJzZWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5oYW5kbGVTY3JvbGwpLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLmhhbmRsZU1vdXNlRG93biksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLmhhbmRsZU1vdXNlVXApLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5oYW5kbGVLZXlEb3duKSwgdGhpcy5pc0ludGVyc2VjdGluZyA9ICEwLCB0aGlzLmFkZElzTG9hZGVkQ2xhc3MoKSwgdGhpcy5wbGF5KClcbiAgICAgICAgICAgICAgICB9KSovXG5cbiAgICAgICAgICAgIClcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxPYnNlcnZlciAmJiAod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5oYW5kbGVTY3JvbGwpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLmhhbmRsZU1vdXNlRG93biksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLmhhbmRsZU1vdXNlVXApLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5oYW5kbGVLZXlEb3duKSwgdGhpcy5zY3JvbGxPYnNlcnZlci5kaXNjb25uZWN0KCkpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLnJlc2l6ZSlcbiAgICB9XG4gICAgaW5pdE1hdGVyaWFsKCkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgICAgICAgdV90aW1lOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdV9zaGFkb3dfcG93ZXI6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogNVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB1X2Rhcmtlbl90b3A6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIiA9PT0gdGhpcy5lbC5kYXRhc2V0LmpzRGFya2VuVG9wID8gMSA6IDBcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdV9hY3RpdmVfY29sb3JzOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuYWN0aXZlQ29sb3JzLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidmVjNFwiXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHVfZ2xvYmFsOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgbm9pc2VGcmVxOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW3RoaXMuZnJlcVgsIHRoaXMuZnJlcVldLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ2ZWMyXCJcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIG5vaXNlU3BlZWQ6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiA1ZS02XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cnVjdFwiXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHVfdmVydERlZm9ybTogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIGluY2xpbmU6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBNYXRoLnNpbih0aGlzLmFuZ2xlKSAvIE1hdGguY29zKHRoaXMuYW5nbGUpXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRUb3A6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAtLjVcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEJvdHRvbTogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IC0uNVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgbm9pc2VGcmVxOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogWzMsIDRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ2ZWMyXCJcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIG5vaXNlQW1wOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5hbXBcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIG5vaXNlU3BlZWQ6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAxMFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgbm9pc2VGbG93OiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogM1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgbm9pc2VTZWVkOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zZWVkXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cnVjdFwiLFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVGcm9tOiBcImZyYWdtZW50XCJcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdV9iYXNlQ29sb3I6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zZWN0aW9uQ29sb3JzWzBdLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidmVjM1wiLFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVGcm9tOiBcImZyYWdtZW50XCJcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdV93YXZlTGF5ZXJzOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVGcm9tOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiXG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBlID0gMTsgZSA8IHRoaXMuc2VjdGlvbkNvbG9ycy5sZW5ndGg7IGUgKz0gMSkgdGhpcy51bmlmb3Jtcy51X3dhdmVMYXllcnMudmFsdWUucHVzaChuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNlY3Rpb25Db2xvcnNbZV0sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidmVjM1wiXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbm9pc2VGcmVxOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbMiArIGUgLyB0aGlzLnNlY3Rpb25Db2xvcnMubGVuZ3RoLCAzICsgZSAvIHRoaXMuc2VjdGlvbkNvbG9ycy5sZW5ndGhdLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInZlYzJcIlxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG5vaXNlU3BlZWQ6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDExICsgLjMgKiBlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbm9pc2VGbG93OiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiA2LjUgKyAuMyAqIGVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBub2lzZVNlZWQ6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc2VlZCArIDEwICogZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG5vaXNlRmxvb3I6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IC4xXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbm9pc2VDZWlsOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAuNjMgKyAuMDcgKiBlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiBcInN0cnVjdFwiXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGV4U2hhZGVyID0gW3RoaXMuc2hhZGVyRmlsZXMubm9pc2UsIHRoaXMuc2hhZGVyRmlsZXMuYmxlbmQsIHRoaXMuc2hhZGVyRmlsZXMudmVydGV4XS5qb2luKFwiXFxuXFxuXCIpLCBuZXcgdGhpcy5taW5pZ2wuTWF0ZXJpYWwodGhpcy52ZXJ0ZXhTaGFkZXIsIHRoaXMuc2hhZGVyRmlsZXMuZnJhZ21lbnQsIHRoaXMudW5pZm9ybXMpXG4gICAgfVxuICAgIGluaXRNZXNoKCkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsID0gdGhpcy5pbml0TWF0ZXJpYWwoKSwgdGhpcy5nZW9tZXRyeSA9IG5ldyB0aGlzLm1pbmlnbC5QbGFuZUdlb21ldHJ5LCB0aGlzLm1lc2ggPSBuZXcgdGhpcy5taW5pZ2wuTWVzaCh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKVxuICAgIH1cbiAgICBzaG91bGRTa2lwRnJhbWUoZSkge1xuICAgICAgICByZXR1cm4gISF3aW5kb3cuZG9jdW1lbnQuaGlkZGVuIHx8ICghdGhpcy5jb25mLnBsYXlpbmcgfHwgKHBhcnNlSW50KGUsIDEwKSAlIDIgPT0gMCB8fCB2b2lkIDApKVxuICAgIH1cbiAgICB1cGRhdGVGcmVxdWVuY3koZSkge1xuICAgICAgICB0aGlzLmZyZXFYICs9IGUsIHRoaXMuZnJlcVkgKz0gZVxuICAgIH1cbiAgICB0b2dnbGVDb2xvcihpbmRleCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUNvbG9yc1tpbmRleF0gPSAwID09PSB0aGlzLmFjdGl2ZUNvbG9yc1tpbmRleF0gPyAxIDogMFxuICAgIH1cbiAgICBzaG93R3JhZGllbnRMZWdlbmQoKSB7XG4gICAgICAgIHRoaXMud2lkdGggPiB0aGlzLm1pbldpZHRoICYmICh0aGlzLmlzR3JhZGllbnRMZWdlbmRWaXNpYmxlID0gITAsIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChcImlzR3JhZGllbnRMZWdlbmRWaXNpYmxlXCIpKVxuICAgIH1cbiAgICBoaWRlR3JhZGllbnRMZWdlbmQoKSB7XG4gICAgICAgIHRoaXMuaXNHcmFkaWVudExlZ2VuZFZpc2libGUgPSAhMSwgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKFwiaXNHcmFkaWVudExlZ2VuZFZpc2libGVcIilcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5pbml0R3JhZGllbnRDb2xvcnMoKSwgdGhpcy5pbml0TWVzaCgpLCB0aGlzLnJlc2l6ZSgpLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5yZXNpemUpXG4gICAgfVxuICAgIC8qXG4gICAgKiBXYWl0aW5nIGZvciB0aGUgY3NzIHZhcmlhYmxlcyB0byBiZWNvbWUgYXZhaWxhYmxlLCB1c3VhbGx5IG9uIHBhZ2UgbG9hZCBiZWZvcmUgd2UgY2FuIGNvbnRpbnVlLlxuICAgICogVXNpbmcgZGVmYXVsdCBjb2xvcnMgYXNzaWduZWQgYmVsb3cgaWYgbm8gdmFyaWFibGVzIGhhdmUgYmVlbiBmb3VuZCBhZnRlciBtYXhDc3NWYXJSZXRyaWVzXG4gICAgKi9cbiAgICB3YWl0Rm9yQ3NzVmFycygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcHV0ZWRDYW52YXNTdHlsZSAmJiAtMSAhPT0gdGhpcy5jb21wdXRlZENhbnZhc1N0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLWdyYWRpZW50LWNvbG9yLTFcIikuaW5kZXhPZihcIiNcIikpIHRoaXMuaW5pdCgpLCB0aGlzLmFkZElzTG9hZGVkQ2xhc3MoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jc3NWYXJSZXRyaWVzICs9IDEsIHRoaXMuY3NzVmFyUmV0cmllcyA+IHRoaXMubWF4Q3NzVmFyUmV0cmllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlY3Rpb25Db2xvcnMgPSBbMTY3MTE2ODAsIDE2NzExNjgwLCAxNjcxMTkzNSwgNjUyODAsIDI1NV0sIHZvaWQgdGhpcy5pbml0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy53YWl0Rm9yQ3NzVmFycygpKVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgKiBJbml0aWFsaXplcyB0aGUgZm91ciBzZWN0aW9uIGNvbG9ycyBieSByZXRyaWV2aW5nIHRoZW0gZnJvbSBjc3MgdmFyaWFibGVzLlxuICAgICovXG4gICAgaW5pdEdyYWRpZW50Q29sb3JzKCkge1xuICAgICAgICB0aGlzLnNlY3Rpb25Db2xvcnMgPSBbXCItLWdyYWRpZW50LWNvbG9yLTFcIiwgXCItLWdyYWRpZW50LWNvbG9yLTJcIiwgXCItLWdyYWRpZW50LWNvbG9yLTNcIiwgXCItLWdyYWRpZW50LWNvbG9yLTRcIl0ubWFwKGNzc1Byb3BlcnR5TmFtZSA9PiB7XG4gICAgICAgICAgICBsZXQgaGV4ID0gdGhpcy5jb21wdXRlZENhbnZhc1N0eWxlLmdldFByb3BlcnR5VmFsdWUoY3NzUHJvcGVydHlOYW1lKS50cmltKCk7XG4gICAgICAgICAgICAvL0NoZWNrIGlmIHNob3J0aGFuZCBoZXggdmFsdWUgd2FzIHVzZWQgYW5kIGRvdWJsZSB0aGUgbGVuZ3RoIHNvIHRoZSBjb252ZXJzaW9uIGluIG5vcm1hbGl6ZUNvbG9yIHdpbGwgd29yay5cbiAgICAgICAgICAgIGlmICg0ID09PSBoZXgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGV4VGVtcCA9IGhleC5zdWJzdHIoMSkuc3BsaXQoXCJcIikubWFwKGhleFRlbXAgPT4gaGV4VGVtcCArIGhleFRlbXApLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgaGV4ID0gYCMke2hleFRlbXB9YFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhleCAmJiBgMHgke2hleC5zdWJzdHIoMSl9YFxuICAgICAgICB9KS5maWx0ZXIoQm9vbGVhbikubWFwKG5vcm1hbGl6ZUNvbG9yKVxuICAgIH1cbn1cblxuXG5cblxuLypcbipGaW5hbGx5IGluaXRpYWxpemluZyB0aGUgR3JhZGllbnQgY2xhc3MsIGFzc2lnbmluZyBhIGNhbnZhcyB0byBpdCBhbmQgY2FsbGluZyBHcmFkaWVudC5jb25uZWN0KCkgd2hpY2ggaW5pdGlhbGl6ZXMgZXZlcnl0aGluZyxcbiogVXNlIEdyYWRpZW50LnBhdXNlKCkgYW5kIEdyYWRpZW50LnBsYXkoKSBmb3IgY29udHJvbHMuXG4qXG4qIEhlcmUgYXJlIHNvbWUgZGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZXMgeW91IGNhbiBjaGFuZ2UgYW55dGltZTpcbiogQW1wbGl0dWRlOiAgICBHcmFkaWVudC5hbXAgPSAwXG4qIENvbG9yczogICAgICAgR3JhZGllbnQuc2VjdGlvbkNvbG9ycyAoaWYgeW91IGNoYW5nZSBjb2xvcnMsIHVzZSBub3JtYWxpemVDb2xvcigjaGV4VmFsdWUpKSBiZWZvcmUgeW91IGFzc2lnbiBpdC5cbipcbipcbiogVXNlZnVsIGZ1bmN0aW9uc1xuKiBHcmFkaWVudC50b2dnbGVDb2xvcihpbmRleClcbiogR3JhZGllbnQudXBkYXRlRnJlcXVlbmN5KGZyZXEpXG4qLyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./api/gradient.js\n");

/***/ }),

/***/ "./api/rightGradient.js":
/*!******************************!*\
  !*** ./api/rightGradient.js ***!
  \******************************/
/*! exports provided: RightGradient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RightGradient\", function() { return RightGradient; });\n/*\n*   Stripe WebGl Gradient Animation\n*   All Credits to Stripe.com\n*   ScrollObserver functionality to disable animation when not scrolled into view has been disabled and \n*   commented out for now.\n*   https://kevinhufnagl.com\n*/\n//Converting colors to proper format\nfunction normalizeColor(hexCode) {\n  return [(hexCode >> 16 & 255) / 255, (hexCode >> 8 & 255) / 255, (255 & hexCode) / 255];\n}\n\n[\"SCREEN\", \"LINEAR_LIGHT\"].reduce((hexCode, t, n) => Object.assign(hexCode, {\n  [t]: n\n}), {}); //Essential functionality of WebGl\n//t = width\n//n = height\n\nclass MiniGl {\n  constructor(canvas, width, height, debug = false) {\n    const _miniGl = this,\n          debug_output = -1 !== document.location.search.toLowerCase().indexOf(\"debug=webgl\");\n\n    _miniGl.canvas = canvas, _miniGl.gl = _miniGl.canvas.getContext(\"webgl\", {\n      antialias: true\n    }), _miniGl.meshes = [];\n    const context = _miniGl.gl;\n    width && height && this.setSize(width, height), _miniGl.lastDebugMsg, _miniGl.debug = debug && debug_output ? function (e) {\n      const t = new Date();\n      t - _miniGl.lastDebugMsg > 1e3 && console.log(\"---\"), console.log(t.toLocaleTimeString() + Array(Math.max(0, 32 - e.length)).join(\" \") + e + \": \", ...Array.from(arguments).slice(1)), _miniGl.lastDebugMsg = t;\n    } : () => {}, Object.defineProperties(_miniGl, {\n      Material: {\n        enumerable: false,\n        value: class {\n          constructor(vertexShaders, fragments, uniforms = {}) {\n            const material = this;\n\n            function getShaderByType(type, source) {\n              const shader = context.createShader(type);\n              return context.shaderSource(shader, source), context.compileShader(shader), context.getShaderParameter(shader, context.COMPILE_STATUS) || console.error(context.getShaderInfoLog(shader)), _miniGl.debug(\"Material.compileShaderSource\", {\n                source: source\n              }), shader;\n            }\n\n            function getUniformVariableDeclarations(uniforms, type) {\n              return Object.entries(uniforms).map(([uniform, value]) => value.getDeclaration(uniform, type)).join(\"\\n\");\n            }\n\n            material.uniforms = uniforms, material.uniformInstances = [];\n            const prefix = \"\\n              precision highp float;\\n            \";\n            material.vertexSource = `\\n              ${prefix}\\n              attribute vec4 position;\\n              attribute vec2 uv;\\n              attribute vec2 uvNorm;\\n              ${getUniformVariableDeclarations(_miniGl.commonUniforms, \"vertex\")}\\n              ${getUniformVariableDeclarations(uniforms, \"vertex\")}\\n              ${vertexShaders}\\n            `, material.Source = `\\n              ${prefix}\\n              ${getUniformVariableDeclarations(_miniGl.commonUniforms, \"fragment\")}\\n              ${getUniformVariableDeclarations(uniforms, \"fragment\")}\\n              ${fragments}\\n            `, material.vertexShader = getShaderByType(context.VERTEX_SHADER, material.vertexSource), material.fragmentShader = getShaderByType(context.FRAGMENT_SHADER, material.Source), material.program = context.createProgram(), context.attachShader(material.program, material.vertexShader), context.attachShader(material.program, material.fragmentShader), context.linkProgram(material.program), context.getProgramParameter(material.program, context.LINK_STATUS) || console.error(context.getProgramInfoLog(material.program)), context.useProgram(material.program), material.attachUniforms(void 0, _miniGl.commonUniforms), material.attachUniforms(void 0, material.uniforms);\n          } //t = uniform\n\n\n          attachUniforms(name, uniforms) {\n            //n  = material\n            const material = this;\n            void 0 === name ? Object.entries(uniforms).forEach(([name, uniform]) => {\n              material.attachUniforms(name, uniform);\n            }) : \"array\" == uniforms.type ? uniforms.value.forEach((uniform, i) => material.attachUniforms(`${name}[${i}]`, uniform)) : \"struct\" == uniforms.type ? Object.entries(uniforms.value).forEach(([uniform, i]) => material.attachUniforms(`${name}.${uniform}`, i)) : (_miniGl.debug(\"Material.attachUniforms\", {\n              name: name,\n              uniform: uniforms\n            }), material.uniformInstances.push({\n              uniform: uniforms,\n              location: context.getUniformLocation(material.program, name)\n            }));\n          }\n\n        }\n      },\n      Uniform: {\n        enumerable: !1,\n        value: class {\n          constructor(e) {\n            this.type = \"float\", Object.assign(this, e);\n            this.typeFn = {\n              float: \"1f\",\n              int: \"1i\",\n              vec2: \"2fv\",\n              vec3: \"3fv\",\n              vec4: \"4fv\",\n              mat4: \"Matrix4fv\"\n            }[this.type] || \"1f\", this.update();\n          }\n\n          update(value) {\n            void 0 !== this.value && context[`uniform${this.typeFn}`](value, 0 === this.typeFn.indexOf(\"Matrix\") ? this.transpose : this.value, 0 === this.typeFn.indexOf(\"Matrix\") ? this.value : null);\n          } //e - name\n          //t - type\n          //n - length\n\n\n          getDeclaration(name, type, length) {\n            const uniform = this;\n\n            if (uniform.excludeFrom !== type) {\n              if (\"array\" === uniform.type) return uniform.value[0].getDeclaration(name, type, uniform.value.length) + `\\nconst int ${name}_length = ${uniform.value.length};`;\n\n              if (\"struct\" === uniform.type) {\n                let name_no_prefix = name.replace(\"u_\", \"\");\n                return name_no_prefix = name_no_prefix.charAt(0).toUpperCase() + name_no_prefix.slice(1), `uniform struct ${name_no_prefix} \n                                  {\\n` + Object.entries(uniform.value).map(([name, uniform]) => uniform.getDeclaration(name, type).replace(/^uniform/, \"\")).join(\"\") + `\\n} ${name}${length > 0 ? `[${length}]` : \"\"};`;\n              }\n\n              return `uniform ${uniform.type} ${name}${length > 0 ? `[${length}]` : \"\"};`;\n            }\n          }\n\n        }\n      },\n      PlaneGeometry: {\n        enumerable: !1,\n        value: class {\n          constructor(width, height, n, i, orientation) {\n            context.createBuffer(), this.attributes = {\n              position: new _miniGl.Attribute({\n                target: context.ARRAY_BUFFER,\n                size: 3\n              }),\n              uv: new _miniGl.Attribute({\n                target: context.ARRAY_BUFFER,\n                size: 2\n              }),\n              uvNorm: new _miniGl.Attribute({\n                target: context.ARRAY_BUFFER,\n                size: 2\n              }),\n              index: new _miniGl.Attribute({\n                target: context.ELEMENT_ARRAY_BUFFER,\n                size: 3,\n                type: context.UNSIGNED_SHORT\n              })\n            }, this.setTopology(n, i), this.setSize(width, height, orientation);\n          }\n\n          setTopology(e = 1, t = 1) {\n            const n = this;\n            n.xSegCount = e, n.ySegCount = t, n.vertexCount = (n.xSegCount + 1) * (n.ySegCount + 1), n.quadCount = n.xSegCount * n.ySegCount * 2, n.attributes.uv.values = new Float32Array(2 * n.vertexCount), n.attributes.uvNorm.values = new Float32Array(2 * n.vertexCount), n.attributes.index.values = new Uint16Array(3 * n.quadCount);\n\n            for (let e = 0; e <= n.ySegCount; e++) for (let t = 0; t <= n.xSegCount; t++) {\n              const i = e * (n.xSegCount + 1) + t;\n\n              if (n.attributes.uv.values[2 * i] = t / n.xSegCount, n.attributes.uv.values[2 * i + 1] = 1 - e / n.ySegCount, n.attributes.uvNorm.values[2 * i] = t / n.xSegCount * 2 - 1, n.attributes.uvNorm.values[2 * i + 1] = 1 - e / n.ySegCount * 2, t < n.xSegCount && e < n.ySegCount) {\n                const s = e * n.xSegCount + t;\n                n.attributes.index.values[6 * s] = i, n.attributes.index.values[6 * s + 1] = i + 1 + n.xSegCount, n.attributes.index.values[6 * s + 2] = i + 1, n.attributes.index.values[6 * s + 3] = i + 1, n.attributes.index.values[6 * s + 4] = i + 1 + n.xSegCount, n.attributes.index.values[6 * s + 5] = i + 2 + n.xSegCount;\n              }\n            }\n\n            n.attributes.uv.update(), n.attributes.uvNorm.update(), n.attributes.index.update(), _miniGl.debug(\"Geometry.setTopology\", {\n              uv: n.attributes.uv,\n              uvNorm: n.attributes.uvNorm,\n              index: n.attributes.index\n            });\n          }\n\n          setSize(width = 1, height = 1, orientation = \"xz\") {\n            const geometry = this;\n            geometry.width = width, geometry.height = height, geometry.orientation = orientation, geometry.attributes.position.values && geometry.attributes.position.values.length === 3 * geometry.vertexCount || (geometry.attributes.position.values = new Float32Array(3 * geometry.vertexCount));\n            const o = width / -2,\n                  r = height / -2,\n                  segment_width = width / geometry.xSegCount,\n                  segment_height = height / geometry.ySegCount;\n\n            for (let yIndex = 0; yIndex <= geometry.ySegCount; yIndex++) {\n              const t = r + yIndex * segment_height;\n\n              for (let xIndex = 0; xIndex <= geometry.xSegCount; xIndex++) {\n                const r = o + xIndex * segment_width,\n                      l = yIndex * (geometry.xSegCount + 1) + xIndex;\n                geometry.attributes.position.values[3 * l + \"xyz\".indexOf(orientation[0])] = -r, geometry.attributes.position.values[3 * l + \"xyz\".indexOf(orientation[1])] = -t;\n              }\n            }\n\n            geometry.attributes.position.update(), _miniGl.debug(\"Geometry.setSize\", {\n              position: geometry.attributes.position\n            });\n          }\n\n        }\n      },\n      Mesh: {\n        enumerable: !1,\n        value: class {\n          constructor(geometry, material) {\n            const mesh = this;\n            mesh.geometry = geometry, mesh.material = material, mesh.wireframe = !1, mesh.attributeInstances = [], Object.entries(mesh.geometry.attributes).forEach(([e, attribute]) => {\n              mesh.attributeInstances.push({\n                attribute: attribute,\n                location: attribute.attach(e, mesh.material.program)\n              });\n            }), _miniGl.meshes.push(mesh), _miniGl.debug(\"Mesh.constructor\", {\n              mesh: mesh\n            });\n          }\n\n          draw() {\n            context.useProgram(this.material.program), this.material.uniformInstances.forEach(({\n              uniform: e,\n              location: t\n            }) => e.update(t)), this.attributeInstances.forEach(({\n              attribute: e,\n              location: t\n            }) => e.use(t)), context.drawElements(this.wireframe ? context.LINES : context.TRIANGLES, this.geometry.attributes.index.values.length, context.UNSIGNED_SHORT, 0);\n          }\n\n          remove() {\n            _miniGl.meshes = _miniGl.meshes.filter(e => e != this);\n          }\n\n        }\n      },\n      Attribute: {\n        enumerable: !1,\n        value: class {\n          constructor(e) {\n            this.type = context.FLOAT, this.normalized = !1, this.buffer = context.createBuffer(), Object.assign(this, e), this.update();\n          }\n\n          update() {\n            void 0 !== this.values && (context.bindBuffer(this.target, this.buffer), context.bufferData(this.target, this.values, context.STATIC_DRAW));\n          }\n\n          attach(e, t) {\n            const n = context.getAttribLocation(t, e);\n            return this.target === context.ARRAY_BUFFER && (context.enableVertexAttribArray(n), context.vertexAttribPointer(n, this.size, this.type, this.normalized, 0, 0)), n;\n          }\n\n          use(e) {\n            context.bindBuffer(this.target, this.buffer), this.target === context.ARRAY_BUFFER && (context.enableVertexAttribArray(e), context.vertexAttribPointer(e, this.size, this.type, this.normalized, 0, 0));\n          }\n\n        }\n      }\n    });\n    const a = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n    _miniGl.commonUniforms = {\n      projectionMatrix: new _miniGl.Uniform({\n        type: \"mat4\",\n        value: a\n      }),\n      modelViewMatrix: new _miniGl.Uniform({\n        type: \"mat4\",\n        value: a\n      }),\n      resolution: new _miniGl.Uniform({\n        type: \"vec2\",\n        value: [1, 1]\n      }),\n      aspectRatio: new _miniGl.Uniform({\n        type: \"float\",\n        value: 1\n      })\n    };\n  }\n\n  setSize(e = 640, t = 480) {\n    this.width = e, this.height = t, this.canvas.width = e, this.canvas.height = t, this.gl.viewport(0, 0, e, t), this.commonUniforms.resolution.value = [e, t], this.commonUniforms.aspectRatio.value = e / t, this.debug(\"MiniGL.setSize\", {\n      width: e,\n      height: t\n    });\n  } //left, right, top, bottom, near, far\n\n\n  setOrthographicCamera(e = 0, t = 0, n = 0, i = -2e3, s = 2e3) {\n    this.commonUniforms.projectionMatrix.value = [2 / this.width, 0, 0, 0, 0, 2 / this.height, 0, 0, 0, 0, 2 / (i - s), 0, e, t, n, 1], this.debug(\"setOrthographicCamera\", this.commonUniforms.projectionMatrix.value);\n  }\n\n  render() {\n    this.gl.clearColor(0, 0, 0, 0), this.gl.clearDepth(1), this.meshes.forEach(e => e.draw());\n  }\n\n} //Sets initial properties\n\n\nfunction e(object, propertyName, val) {\n  return propertyName in object ? Object.defineProperty(object, propertyName, {\n    value: val,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : object[propertyName] = val, object;\n} //Gradient object\n\n\nclass RightGradient {\n  constructor(...t) {\n    e(this, \"el\", void 0), e(this, \"cssVarRetries\", 0), e(this, \"maxCssVarRetries\", 200), e(this, \"angle\", 0), e(this, \"isLoadedClass\", !1), e(this, \"isScrolling\", !1),\n    /*e(this, \"isStatic\", o.disableAmbientAnimations()),*/\n    e(this, \"scrollingTimeout\", void 0), e(this, \"scrollingRefreshDelay\", 200), e(this, \"isIntersecting\", !1), e(this, \"shaderFiles\", void 0), e(this, \"vertexShader\", void 0), e(this, \"sectionColors\", void 0), e(this, \"computedCanvasStyle\", void 0), e(this, \"conf\", void 0), e(this, \"uniforms\", void 0), e(this, \"t\", 1253106), e(this, \"last\", 0), e(this, \"width\", void 0), e(this, \"minWidth\", 1111), e(this, \"height\", 600), e(this, \"xSegCount\", void 0), e(this, \"ySegCount\", void 0), e(this, \"mesh\", void 0), e(this, \"material\", void 0), e(this, \"geometry\", void 0), e(this, \"minigl\", void 0), e(this, \"scrollObserver\", void 0), e(this, \"amp\", 320), e(this, \"seed\", 5), e(this, \"freqX\", 14e-5), e(this, \"freqY\", 29e-5), e(this, \"freqDelta\", 1e-5), e(this, \"activeColors\", [1, 1, 1, 1]), e(this, \"isMetaKey\", !1), e(this, \"isGradientLegendVisible\", !1), e(this, \"isMouseDown\", !1), e(this, \"handleScroll\", () => {\n      clearTimeout(this.scrollingTimeout), this.scrollingTimeout = setTimeout(this.handleScrollEnd, this.scrollingRefreshDelay), this.isGradientLegendVisible && this.hideGradientLegend(), this.conf.playing && (this.isScrolling = !0, this.pause());\n    }), e(this, \"handleScrollEnd\", () => {\n      this.isScrolling = !1, this.isIntersecting && this.play();\n    }), e(this, \"resize\", () => {\n      this.width = window.innerWidth, this.minigl.setSize(this.width, this.height), this.minigl.setOrthographicCamera(), this.xSegCount = Math.ceil(this.width * this.conf.density[0]), this.ySegCount = Math.ceil(this.height * this.conf.density[1]), this.mesh.geometry.setTopology(this.xSegCount, this.ySegCount), this.mesh.geometry.setSize(this.width, this.height), this.mesh.material.uniforms.u_shadow_power.value = this.width < 600 ? 5 : 6;\n    }), e(this, \"handleMouseDown\", e => {\n      this.isGradientLegendVisible && (this.isMetaKey = e.metaKey, this.isMouseDown = !0, !1 === this.conf.playing && requestAnimationFrame(this.animate));\n    }), e(this, \"handleMouseUp\", () => {\n      this.isMouseDown = !1;\n    }), e(this, \"animate\", e => {\n      if (!this.shouldSkipFrame(e) || this.isMouseDown) {\n        if (this.t += Math.min(e - this.last, 1e3 / 15), this.last = e, this.isMouseDown) {\n          let e = 160;\n          this.isMetaKey && (e = -160), this.t += e;\n        }\n\n        this.mesh.material.uniforms.u_time.value = this.t, this.minigl.render();\n      }\n\n      if (0 !== this.last && this.isStatic) return this.minigl.render(), void this.disconnect();\n      (\n      /*this.isIntersecting && */\n      this.conf.playing || this.isMouseDown) && requestAnimationFrame(this.animate);\n    }), e(this, \"addIsLoadedClass\", () => {\n      /*this.isIntersecting && */\n      !this.isLoadedClass && (this.isLoadedClass = !0, this.el.classList.add(\"isLoaded\"), setTimeout(() => {\n        this.el.parentElement.classList.add(\"isLoaded\");\n      }, 3e3));\n    }), e(this, \"pause\", () => {\n      this.conf.playing = false;\n    }), e(this, \"play\", () => {\n      requestAnimationFrame(this.animate), this.conf.playing = true;\n    }), e(this, \"initGradient\", selector => {\n      this.el = document.querySelector(selector);\n      this.connect();\n      return this;\n    });\n  }\n\n  async connect() {\n    this.shaderFiles = {\n      vertex: \"varying vec3 v_color;\\n\\nvoid main() {\\n  float time = u_time * u_global.noiseSpeed;\\n\\n  vec2 noiseCoord = resolution * uvNorm * u_global.noiseFreq;\\n\\n  vec2 st = 1. - uvNorm.xy;\\n\\n  //\\n  // Tilting the plane\\n  //\\n\\n  // Front-to-back tilt\\n  float tilt = resolution.y / 2.0 * uvNorm.y;\\n\\n  // Left-to-right angle\\n  float incline = resolution.x * uvNorm.x / 2.0 * u_vertDeform.incline;\\n\\n  // Up-down shift to offset incline\\n  float offset = resolution.x / 2.0 * u_vertDeform.incline * mix(u_vertDeform.offsetBottom, u_vertDeform.offsetTop, uv.y);\\n\\n  //\\n  // Vertex noise\\n  //\\n\\n  float noise = snoise(vec3(\\n    noiseCoord.x * u_vertDeform.noiseFreq.x + time * u_vertDeform.noiseFlow,\\n    noiseCoord.y * u_vertDeform.noiseFreq.y,\\n    time * u_vertDeform.noiseSpeed + u_vertDeform.noiseSeed\\n  )) * u_vertDeform.noiseAmp;\\n\\n  // Fade noise to zero at edges\\n  noise *= 1.0 - pow(abs(uvNorm.y), 2.0);\\n\\n  // Clamp to 0\\n  noise = max(0.0, noise);\\n\\n  vec3 pos = vec3(\\n    position.x,\\n    position.y + tilt + incline + noise - offset,\\n    position.z\\n  );\\n\\n  //\\n  // Vertex color, to be passed to fragment shader\\n  //\\n\\n  if (u_active_colors[0] == 1.) {\\n    v_color = u_baseColor;\\n  }\\n\\n  for (int i = 0; i < u_waveLayers_length; i++) {\\n    if (u_active_colors[i + 1] == 1.) {\\n      WaveLayers layer = u_waveLayers[i];\\n\\n      float noise = smoothstep(\\n        layer.noiseFloor,\\n        layer.noiseCeil,\\n        snoise(vec3(\\n          noiseCoord.x * layer.noiseFreq.x + time * layer.noiseFlow,\\n          noiseCoord.y * layer.noiseFreq.y,\\n          time * layer.noiseSpeed + layer.noiseSeed\\n        )) / 2.0 + 0.5\\n      );\\n\\n      v_color = blendNormal(v_color, layer.color, pow(noise, 4.));\\n    }\\n  }\\n\\n  //\\n  // Finish\\n  //\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\\n}\",\n      noise: \"//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : stegu\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//               https://github.com/stegu/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n    return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n{\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n          + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n}\",\n      blend: \"//\\n// https://github.com/jamieowen/glsl-blend\\n//\\n\\n// Normal\\n\\nvec3 blendNormal(vec3 base, vec3 blend) {\\n\\treturn blend;\\n}\\n\\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Screen\\n\\nfloat blendScreen(float base, float blend) {\\n\\treturn 1.0-((1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendScreen(vec3 base, vec3 blend) {\\n\\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\\n}\\n\\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Multiply\\n\\nvec3 blendMultiply(vec3 base, vec3 blend) {\\n\\treturn base*blend;\\n}\\n\\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Overlay\\n\\nfloat blendOverlay(float base, float blend) {\\n\\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendOverlay(vec3 base, vec3 blend) {\\n\\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\\n}\\n\\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Hard light\\n\\nvec3 blendHardLight(vec3 base, vec3 blend) {\\n\\treturn blendOverlay(blend,base);\\n}\\n\\nvec3 blendHardLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendHardLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Soft light\\n\\nfloat blendSoftLight(float base, float blend) {\\n\\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\\n}\\n\\nvec3 blendSoftLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\\n}\\n\\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Color dodge\\n\\nfloat blendColorDodge(float base, float blend) {\\n\\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\\n}\\n\\nvec3 blendColorDodge(vec3 base, vec3 blend) {\\n\\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\\n}\\n\\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Color burn\\n\\nfloat blendColorBurn(float base, float blend) {\\n\\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\\n}\\n\\nvec3 blendColorBurn(vec3 base, vec3 blend) {\\n\\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\\n}\\n\\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Vivid Light\\n\\nfloat blendVividLight(float base, float blend) {\\n\\treturn (blend<0.5)?blendColorBurn(base,(2.0*blend)):blendColorDodge(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendVividLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendVividLight(base.r,blend.r),blendVividLight(base.g,blend.g),blendVividLight(base.b,blend.b));\\n}\\n\\nvec3 blendVividLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendVividLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Lighten\\n\\nfloat blendLighten(float base, float blend) {\\n\\treturn max(blend,base);\\n}\\n\\nvec3 blendLighten(vec3 base, vec3 blend) {\\n\\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\\n}\\n\\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear burn\\n\\nfloat blendLinearBurn(float base, float blend) {\\n\\t// Note : Same implementation as BlendSubtractf\\n\\treturn max(base+blend-1.0,0.0);\\n}\\n\\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\\n\\t// Note : Same implementation as BlendSubtract\\n\\treturn max(base+blend-vec3(1.0),vec3(0.0));\\n}\\n\\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear dodge\\n\\nfloat blendLinearDodge(float base, float blend) {\\n\\t// Note : Same implementation as BlendAddf\\n\\treturn min(base+blend,1.0);\\n}\\n\\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\\n\\t// Note : Same implementation as BlendAdd\\n\\treturn min(base+blend,vec3(1.0));\\n}\\n\\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear light\\n\\nfloat blendLinearLight(float base, float blend) {\\n\\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendLinearLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\\n}\\n\\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\",\n      fragment: \"varying vec3 v_color;\\n\\nvoid main() {\\n  vec3 color = v_color;\\n  if (u_darken_top == 1.0) {\\n    vec2 st = gl_FragCoord.xy/resolution.xy;\\n    color.g -= pow(st.y + sin(-12.0) * st.x, u_shadow_power) * 0.4;\\n  }\\n  gl_FragColor = vec4(color, 1.0);\\n}\"\n    }, this.conf = {\n      presetName: \"\",\n      wireframe: false,\n      density: [.06, .16],\n      zoom: 1,\n      rotation: 0,\n      playing: true\n    }, document.querySelectorAll(\"canvas\").length < 1 ? console.log(\"DID NOT LOAD HERO STRIPE CANVAS\") : (this.minigl = new MiniGl(this.el, null, null, !0), requestAnimationFrame(() => {\n      this.el && (this.computedCanvasStyle = getComputedStyle(this.el), this.waitForCssVars());\n    })\n    /*\n    this.scrollObserver = await s.create(.1, !1),\n    this.scrollObserver.observe(this.el),\n    this.scrollObserver.onSeparate(() => {\n        window.removeEventListener(\"scroll\", this.handleScroll), window.removeEventListener(\"mousedown\", this.handleMouseDown), window.removeEventListener(\"mouseup\", this.handleMouseUp), window.removeEventListener(\"keydown\", this.handleKeyDown), this.isIntersecting = !1, this.conf.playing && this.pause()\n    }), \n    this.scrollObserver.onIntersect(() => {\n        window.addEventListener(\"scroll\", this.handleScroll), window.addEventListener(\"mousedown\", this.handleMouseDown), window.addEventListener(\"mouseup\", this.handleMouseUp), window.addEventListener(\"keydown\", this.handleKeyDown), this.isIntersecting = !0, this.addIsLoadedClass(), this.play()\n    })*/\n    );\n  }\n\n  disconnect() {\n    this.scrollObserver && (window.removeEventListener(\"scroll\", this.handleScroll), window.removeEventListener(\"mousedown\", this.handleMouseDown), window.removeEventListener(\"mouseup\", this.handleMouseUp), window.removeEventListener(\"keydown\", this.handleKeyDown), this.scrollObserver.disconnect()), window.removeEventListener(\"resize\", this.resize);\n  }\n\n  initMaterial() {\n    this.uniforms = {\n      u_time: new this.minigl.Uniform({\n        value: 0\n      }),\n      u_shadow_power: new this.minigl.Uniform({\n        value: 5\n      }),\n      u_darken_top: new this.minigl.Uniform({\n        value: \"\" === this.el.dataset.jsDarkenTop ? 1 : 0\n      }),\n      u_active_colors: new this.minigl.Uniform({\n        value: this.activeColors,\n        type: \"vec4\"\n      }),\n      u_global: new this.minigl.Uniform({\n        value: {\n          noiseFreq: new this.minigl.Uniform({\n            value: [this.freqX, this.freqY],\n            type: \"vec2\"\n          }),\n          noiseSpeed: new this.minigl.Uniform({\n            value: 5e-6\n          })\n        },\n        type: \"struct\"\n      }),\n      u_vertDeform: new this.minigl.Uniform({\n        value: {\n          incline: new this.minigl.Uniform({\n            value: Math.sin(this.angle) / Math.cos(this.angle)\n          }),\n          offsetTop: new this.minigl.Uniform({\n            value: -.5\n          }),\n          offsetBottom: new this.minigl.Uniform({\n            value: -.5\n          }),\n          noiseFreq: new this.minigl.Uniform({\n            value: [3, 4],\n            type: \"vec2\"\n          }),\n          noiseAmp: new this.minigl.Uniform({\n            value: this.amp\n          }),\n          noiseSpeed: new this.minigl.Uniform({\n            value: 10\n          }),\n          noiseFlow: new this.minigl.Uniform({\n            value: 3\n          }),\n          noiseSeed: new this.minigl.Uniform({\n            value: this.seed\n          })\n        },\n        type: \"struct\",\n        excludeFrom: \"fragment\"\n      }),\n      u_baseColor: new this.minigl.Uniform({\n        value: this.sectionColors[0],\n        type: \"vec3\",\n        excludeFrom: \"fragment\"\n      }),\n      u_waveLayers: new this.minigl.Uniform({\n        value: [],\n        excludeFrom: \"fragment\",\n        type: \"array\"\n      })\n    };\n\n    for (let e = 1; e < this.sectionColors.length; e += 1) this.uniforms.u_waveLayers.value.push(new this.minigl.Uniform({\n      value: {\n        color: new this.minigl.Uniform({\n          value: this.sectionColors[e],\n          type: \"vec3\"\n        }),\n        noiseFreq: new this.minigl.Uniform({\n          value: [2 + e / this.sectionColors.length, 3 + e / this.sectionColors.length],\n          type: \"vec2\"\n        }),\n        noiseSpeed: new this.minigl.Uniform({\n          value: 11 + .3 * e\n        }),\n        noiseFlow: new this.minigl.Uniform({\n          value: 6.5 + .3 * e\n        }),\n        noiseSeed: new this.minigl.Uniform({\n          value: this.seed + 10 * e\n        }),\n        noiseFloor: new this.minigl.Uniform({\n          value: .1\n        }),\n        noiseCeil: new this.minigl.Uniform({\n          value: .63 + .07 * e\n        })\n      },\n      type: \"struct\"\n    }));\n\n    return this.vertexShader = [this.shaderFiles.noise, this.shaderFiles.blend, this.shaderFiles.vertex].join(\"\\n\\n\"), new this.minigl.Material(this.vertexShader, this.shaderFiles.fragment, this.uniforms);\n  }\n\n  initMesh() {\n    this.material = this.initMaterial(), this.geometry = new this.minigl.PlaneGeometry(), this.mesh = new this.minigl.Mesh(this.geometry, this.material);\n  }\n\n  shouldSkipFrame(e) {\n    return !!window.document.hidden || !this.conf.playing || parseInt(e, 10) % 2 == 0 || void 0;\n  }\n\n  updateFrequency(e) {\n    this.freqX += e, this.freqY += e;\n  }\n\n  toggleColor(index) {\n    this.activeColors[index] = 0 === this.activeColors[index] ? 1 : 0;\n  }\n\n  showGradientLegend() {\n    this.width > this.minWidth && (this.isGradientLegendVisible = !0, document.body.classList.add(\"isGradientLegendVisible\"));\n  }\n\n  hideGradientLegend() {\n    this.isGradientLegendVisible = !1, document.body.classList.remove(\"isGradientLegendVisible\");\n  }\n\n  init() {\n    this.initGradientColors(), this.initMesh(), this.resize(), requestAnimationFrame(this.animate), window.addEventListener(\"resize\", this.resize);\n  }\n  /*\n  * Waiting for the css variables to become available, usually on page load before we can continue.\n  * Using default colors assigned below if no variables have been found after maxCssVarRetries\n  */\n\n\n  waitForCssVars() {\n    if (this.computedCanvasStyle && -1 !== this.computedCanvasStyle.getPropertyValue(\"--gradient-color-1\").indexOf(\"#\")) this.init(), this.addIsLoadedClass();else {\n      if (this.cssVarRetries += 1, this.cssVarRetries > this.maxCssVarRetries) {\n        return this.sectionColors = [16711680, 16711680, 16711935, 65280, 255], void this.init();\n      }\n\n      requestAnimationFrame(() => this.waitForCssVars());\n    }\n  }\n  /*\n  * Initializes the four section colors by retrieving them from css variables.\n  */\n\n\n  initGradientColors() {\n    this.sectionColors = [\"--gradient-color-1\", \"--gradient-color-2\", \"--gradient-color-3\", \"--gradient-color-4\"].map(cssPropertyName => {\n      let hex = this.computedCanvasStyle.getPropertyValue(cssPropertyName).trim(); //Check if shorthand hex value was used and double the length so the conversion in normalizeColor will work.\n\n      if (4 === hex.length) {\n        const hexTemp = hex.substr(1).split(\"\").map(hexTemp => hexTemp + hexTemp).join(\"\");\n        hex = `#${hexTemp}`;\n      }\n\n      return hex && `0x${hex.substr(1)}`;\n    }).filter(Boolean).map(normalizeColor);\n  }\n\n}\n/*\n*Finally initializing the Gradient class, assigning a canvas to it and calling Gradient.connect() which initializes everything,\n* Use Gradient.pause() and Gradient.play() for controls.\n*\n* Here are some default property values you can change anytime:\n* Amplitude:    Gradient.amp = 0\n* Colors:       Gradient.sectionColors (if you change colors, use normalizeColor(#hexValue)) before you assign it.\n*\n*\n* Useful functions\n* Gradient.toggleColor(index)\n* Gradient.updateFrequency(freq)\n*///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcGkvcmlnaHRHcmFkaWVudC5qcz8yOWU0Il0sIm5hbWVzIjpbIm5vcm1hbGl6ZUNvbG9yIiwiaGV4Q29kZSIsInJlZHVjZSIsInQiLCJuIiwiT2JqZWN0IiwiYXNzaWduIiwiTWluaUdsIiwiY29uc3RydWN0b3IiLCJjYW52YXMiLCJ3aWR0aCIsImhlaWdodCIsImRlYnVnIiwiX21pbmlHbCIsImRlYnVnX291dHB1dCIsImRvY3VtZW50IiwibG9jYXRpb24iLCJzZWFyY2giLCJ0b0xvd2VyQ2FzZSIsImluZGV4T2YiLCJnbCIsImdldENvbnRleHQiLCJhbnRpYWxpYXMiLCJtZXNoZXMiLCJjb250ZXh0Iiwic2V0U2l6ZSIsImxhc3REZWJ1Z01zZyIsImUiLCJEYXRlIiwiY29uc29sZSIsImxvZyIsInRvTG9jYWxlVGltZVN0cmluZyIsIkFycmF5IiwiTWF0aCIsIm1heCIsImxlbmd0aCIsImpvaW4iLCJmcm9tIiwiYXJndW1lbnRzIiwic2xpY2UiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiTWF0ZXJpYWwiLCJlbnVtZXJhYmxlIiwidmFsdWUiLCJ2ZXJ0ZXhTaGFkZXJzIiwiZnJhZ21lbnRzIiwidW5pZm9ybXMiLCJtYXRlcmlhbCIsImdldFNoYWRlckJ5VHlwZSIsInR5cGUiLCJzb3VyY2UiLCJzaGFkZXIiLCJjcmVhdGVTaGFkZXIiLCJzaGFkZXJTb3VyY2UiLCJjb21waWxlU2hhZGVyIiwiZ2V0U2hhZGVyUGFyYW1ldGVyIiwiQ09NUElMRV9TVEFUVVMiLCJlcnJvciIsImdldFNoYWRlckluZm9Mb2ciLCJnZXRVbmlmb3JtVmFyaWFibGVEZWNsYXJhdGlvbnMiLCJlbnRyaWVzIiwibWFwIiwidW5pZm9ybSIsImdldERlY2xhcmF0aW9uIiwidW5pZm9ybUluc3RhbmNlcyIsInByZWZpeCIsInZlcnRleFNvdXJjZSIsImNvbW1vblVuaWZvcm1zIiwiU291cmNlIiwidmVydGV4U2hhZGVyIiwiVkVSVEVYX1NIQURFUiIsImZyYWdtZW50U2hhZGVyIiwiRlJBR01FTlRfU0hBREVSIiwicHJvZ3JhbSIsImNyZWF0ZVByb2dyYW0iLCJhdHRhY2hTaGFkZXIiLCJsaW5rUHJvZ3JhbSIsImdldFByb2dyYW1QYXJhbWV0ZXIiLCJMSU5LX1NUQVRVUyIsImdldFByb2dyYW1JbmZvTG9nIiwidXNlUHJvZ3JhbSIsImF0dGFjaFVuaWZvcm1zIiwibmFtZSIsImZvckVhY2giLCJpIiwicHVzaCIsImdldFVuaWZvcm1Mb2NhdGlvbiIsIlVuaWZvcm0iLCJ0eXBlRm4iLCJmbG9hdCIsImludCIsInZlYzIiLCJ2ZWMzIiwidmVjNCIsIm1hdDQiLCJ1cGRhdGUiLCJ0cmFuc3Bvc2UiLCJleGNsdWRlRnJvbSIsIm5hbWVfbm9fcHJlZml4IiwicmVwbGFjZSIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiUGxhbmVHZW9tZXRyeSIsIm9yaWVudGF0aW9uIiwiY3JlYXRlQnVmZmVyIiwiYXR0cmlidXRlcyIsInBvc2l0aW9uIiwiQXR0cmlidXRlIiwidGFyZ2V0IiwiQVJSQVlfQlVGRkVSIiwic2l6ZSIsInV2IiwidXZOb3JtIiwiaW5kZXgiLCJFTEVNRU5UX0FSUkFZX0JVRkZFUiIsIlVOU0lHTkVEX1NIT1JUIiwic2V0VG9wb2xvZ3kiLCJ4U2VnQ291bnQiLCJ5U2VnQ291bnQiLCJ2ZXJ0ZXhDb3VudCIsInF1YWRDb3VudCIsInZhbHVlcyIsIkZsb2F0MzJBcnJheSIsIlVpbnQxNkFycmF5IiwicyIsImdlb21ldHJ5IiwibyIsInIiLCJzZWdtZW50X3dpZHRoIiwic2VnbWVudF9oZWlnaHQiLCJ5SW5kZXgiLCJ4SW5kZXgiLCJsIiwiTWVzaCIsIm1lc2giLCJ3aXJlZnJhbWUiLCJhdHRyaWJ1dGVJbnN0YW5jZXMiLCJhdHRyaWJ1dGUiLCJhdHRhY2giLCJkcmF3IiwidXNlIiwiZHJhd0VsZW1lbnRzIiwiTElORVMiLCJUUklBTkdMRVMiLCJyZW1vdmUiLCJmaWx0ZXIiLCJGTE9BVCIsIm5vcm1hbGl6ZWQiLCJidWZmZXIiLCJiaW5kQnVmZmVyIiwiYnVmZmVyRGF0YSIsIlNUQVRJQ19EUkFXIiwiZ2V0QXR0cmliTG9jYXRpb24iLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsInZlcnRleEF0dHJpYlBvaW50ZXIiLCJhIiwicHJvamVjdGlvbk1hdHJpeCIsIm1vZGVsVmlld01hdHJpeCIsInJlc29sdXRpb24iLCJhc3BlY3RSYXRpbyIsInZpZXdwb3J0Iiwic2V0T3J0aG9ncmFwaGljQ2FtZXJhIiwicmVuZGVyIiwiY2xlYXJDb2xvciIsImNsZWFyRGVwdGgiLCJvYmplY3QiLCJwcm9wZXJ0eU5hbWUiLCJ2YWwiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiUmlnaHRHcmFkaWVudCIsImNsZWFyVGltZW91dCIsInNjcm9sbGluZ1RpbWVvdXQiLCJzZXRUaW1lb3V0IiwiaGFuZGxlU2Nyb2xsRW5kIiwic2Nyb2xsaW5nUmVmcmVzaERlbGF5IiwiaXNHcmFkaWVudExlZ2VuZFZpc2libGUiLCJoaWRlR3JhZGllbnRMZWdlbmQiLCJjb25mIiwicGxheWluZyIsImlzU2Nyb2xsaW5nIiwicGF1c2UiLCJpc0ludGVyc2VjdGluZyIsInBsYXkiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwibWluaWdsIiwiY2VpbCIsImRlbnNpdHkiLCJ1X3NoYWRvd19wb3dlciIsImlzTWV0YUtleSIsIm1ldGFLZXkiLCJpc01vdXNlRG93biIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImFuaW1hdGUiLCJzaG91bGRTa2lwRnJhbWUiLCJtaW4iLCJsYXN0IiwidV90aW1lIiwiaXNTdGF0aWMiLCJkaXNjb25uZWN0IiwiaXNMb2FkZWRDbGFzcyIsImVsIiwiY2xhc3NMaXN0IiwiYWRkIiwicGFyZW50RWxlbWVudCIsInNlbGVjdG9yIiwicXVlcnlTZWxlY3RvciIsImNvbm5lY3QiLCJzaGFkZXJGaWxlcyIsInZlcnRleCIsIm5vaXNlIiwiYmxlbmQiLCJmcmFnbWVudCIsInByZXNldE5hbWUiLCJ6b29tIiwicm90YXRpb24iLCJxdWVyeVNlbGVjdG9yQWxsIiwiY29tcHV0ZWRDYW52YXNTdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJ3YWl0Rm9yQ3NzVmFycyIsInNjcm9sbE9ic2VydmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZVNjcm9sbCIsImhhbmRsZU1vdXNlRG93biIsImhhbmRsZU1vdXNlVXAiLCJoYW5kbGVLZXlEb3duIiwicmVzaXplIiwiaW5pdE1hdGVyaWFsIiwidV9kYXJrZW5fdG9wIiwiZGF0YXNldCIsImpzRGFya2VuVG9wIiwidV9hY3RpdmVfY29sb3JzIiwiYWN0aXZlQ29sb3JzIiwidV9nbG9iYWwiLCJub2lzZUZyZXEiLCJmcmVxWCIsImZyZXFZIiwibm9pc2VTcGVlZCIsInVfdmVydERlZm9ybSIsImluY2xpbmUiLCJzaW4iLCJhbmdsZSIsImNvcyIsIm9mZnNldFRvcCIsIm9mZnNldEJvdHRvbSIsIm5vaXNlQW1wIiwiYW1wIiwibm9pc2VGbG93Iiwibm9pc2VTZWVkIiwic2VlZCIsInVfYmFzZUNvbG9yIiwic2VjdGlvbkNvbG9ycyIsInVfd2F2ZUxheWVycyIsImNvbG9yIiwibm9pc2VGbG9vciIsIm5vaXNlQ2VpbCIsImluaXRNZXNoIiwiaGlkZGVuIiwicGFyc2VJbnQiLCJ1cGRhdGVGcmVxdWVuY3kiLCJ0b2dnbGVDb2xvciIsInNob3dHcmFkaWVudExlZ2VuZCIsIm1pbldpZHRoIiwiYm9keSIsImluaXQiLCJpbml0R3JhZGllbnRDb2xvcnMiLCJhZGRFdmVudExpc3RlbmVyIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImFkZElzTG9hZGVkQ2xhc3MiLCJjc3NWYXJSZXRyaWVzIiwibWF4Q3NzVmFyUmV0cmllcyIsImNzc1Byb3BlcnR5TmFtZSIsImhleCIsInRyaW0iLCJoZXhUZW1wIiwic3Vic3RyIiwic3BsaXQiLCJCb29sZWFuIl0sIm1hcHBpbmdzIjoiQUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBLFNBQVNBLGNBQVQsQ0FBd0JDLE9BQXhCLEVBQWlD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LE9BQWpELEVBQTBEaFAsSUFBMUQsQ0FBK0QsRUFBL0QsQ0FBaEI7QUFDQThPLFdBQUcsR0FBSSxJQUFHRSxPQUFRLEVBQWxCO0FBQ0g7O0FBQ0QsYUFBT0YsR0FBRyxJQUFLLEtBQUlBLEdBQUcsQ0FBQ0csTUFBSixDQUFXLENBQVgsQ0FBYyxFQUFqQztBQUNILEtBUm9CLEVBUWxCcEksTUFSa0IsQ0FRWHNJLE9BUlcsRUFRRjFOLEdBUkUsQ0FRRTdELGNBUkYsQ0FBckI7QUFTSDs7QUEzTnNCO0FBaU8zQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL2FwaS9yaWdodEdyYWRpZW50LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiAgIFN0cmlwZSBXZWJHbCBHcmFkaWVudCBBbmltYXRpb25cbiogICBBbGwgQ3JlZGl0cyB0byBTdHJpcGUuY29tXG4qICAgU2Nyb2xsT2JzZXJ2ZXIgZnVuY3Rpb25hbGl0eSB0byBkaXNhYmxlIGFuaW1hdGlvbiB3aGVuIG5vdCBzY3JvbGxlZCBpbnRvIHZpZXcgaGFzIGJlZW4gZGlzYWJsZWQgYW5kIFxuKiAgIGNvbW1lbnRlZCBvdXQgZm9yIG5vdy5cbiogICBodHRwczovL2tldmluaHVmbmFnbC5jb21cbiovXG5cblxuLy9Db252ZXJ0aW5nIGNvbG9ycyB0byBwcm9wZXIgZm9ybWF0XG5mdW5jdGlvbiBub3JtYWxpemVDb2xvcihoZXhDb2RlKSB7XG4gICAgcmV0dXJuIFsoaGV4Q29kZSA+PiAxNiAmIDI1NSkgLyAyNTUsIChoZXhDb2RlID4+IDggJiAyNTUpIC8gMjU1LCAoMjU1ICYgaGV4Q29kZSkgLyAyNTVdXG59IFtcIlNDUkVFTlwiLCBcIkxJTkVBUl9MSUdIVFwiXS5yZWR1Y2UoKGhleENvZGUsIHQsIG4pID0+IE9iamVjdC5hc3NpZ24oaGV4Q29kZSwge1xuICAgIFt0XTogblxufSksIHt9KTtcblxuLy9Fc3NlbnRpYWwgZnVuY3Rpb25hbGl0eSBvZiBXZWJHbFxuLy90ID0gd2lkdGhcbi8vbiA9IGhlaWdodFxuY2xhc3MgTWluaUdsIHtcbiAgICBjb25zdHJ1Y3RvcihjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGRlYnVnID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgX21pbmlHbCA9IHRoaXMsXG4gICAgICAgICAgICBkZWJ1Z19vdXRwdXQgPSAtMSAhPT0gZG9jdW1lbnQubG9jYXRpb24uc2VhcmNoLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImRlYnVnPXdlYmdsXCIpO1xuICAgICAgICBfbWluaUdsLmNhbnZhcyA9IGNhbnZhcywgX21pbmlHbC5nbCA9IF9taW5pR2wuY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCB7XG4gICAgICAgICAgICBhbnRpYWxpYXM6IHRydWVcbiAgICAgICAgfSksIF9taW5pR2wubWVzaGVzID0gW107XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBfbWluaUdsLmdsO1xuICAgICAgICB3aWR0aCAmJiBoZWlnaHQgJiYgdGhpcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpLCBfbWluaUdsLmxhc3REZWJ1Z01zZywgX21pbmlHbC5kZWJ1ZyA9IGRlYnVnICYmIGRlYnVnX291dHB1dCA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0gbmV3IERhdGU7XG4gICAgICAgICAgICB0IC0gX21pbmlHbC5sYXN0RGVidWdNc2cgPiAxZTMgJiYgY29uc29sZS5sb2coXCItLS1cIiksIGNvbnNvbGUubG9nKHQudG9Mb2NhbGVUaW1lU3RyaW5nKCkgKyBBcnJheShNYXRoLm1heCgwLCAzMiAtIGUubGVuZ3RoKSkuam9pbihcIiBcIikgKyBlICsgXCI6IFwiLCAuLi5BcnJheS5mcm9tKGFyZ3VtZW50cykuc2xpY2UoMSkpLCBfbWluaUdsLmxhc3REZWJ1Z01zZyA9IHRcbiAgICAgICAgfSA6ICgpID0+IHsgfSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX21pbmlHbCwge1xuICAgICAgICAgICAgTWF0ZXJpYWw6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2xhc3Mge1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhTaGFkZXJzLCBmcmFnbWVudHMsIHVuaWZvcm1zID0ge30pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNoYWRlckJ5VHlwZSh0eXBlLCBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGFkZXIgPSBjb250ZXh0LmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpLCBjb250ZXh0LmNvbXBpbGVTaGFkZXIoc2hhZGVyKSwgY29udGV4dC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBjb250ZXh0LkNPTVBJTEVfU1RBVFVTKSB8fCBjb25zb2xlLmVycm9yKGNvbnRleHQuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKSwgX21pbmlHbC5kZWJ1ZyhcIk1hdGVyaWFsLmNvbXBpbGVTaGFkZXJTb3VyY2VcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBzaGFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFVuaWZvcm1WYXJpYWJsZURlY2xhcmF0aW9ucyh1bmlmb3JtcywgdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyh1bmlmb3JtcykubWFwKChbdW5pZm9ybSwgdmFsdWVdKSA9PiB2YWx1ZS5nZXREZWNsYXJhdGlvbih1bmlmb3JtLCB0eXBlKSkuam9pbihcIlxcblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwudW5pZm9ybXMgPSB1bmlmb3JtcywgbWF0ZXJpYWwudW5pZm9ybUluc3RhbmNlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBcIlxcbiAgICAgICAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgICAgICAgICAgIFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwudmVydGV4U291cmNlID0gYFxcbiAgICAgICAgICAgICAgJHtwcmVmaXh9XFxuICAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjNCBwb3NpdGlvbjtcXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIHV2O1xcbiAgICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgdXZOb3JtO1xcbiAgICAgICAgICAgICAgJHtnZXRVbmlmb3JtVmFyaWFibGVEZWNsYXJhdGlvbnMoX21pbmlHbC5jb21tb25Vbmlmb3JtcywgXCJ2ZXJ0ZXhcIil9XFxuICAgICAgICAgICAgICAke2dldFVuaWZvcm1WYXJpYWJsZURlY2xhcmF0aW9ucyh1bmlmb3JtcywgXCJ2ZXJ0ZXhcIil9XFxuICAgICAgICAgICAgICAke3ZlcnRleFNoYWRlcnN9XFxuICAgICAgICAgICAgYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5Tb3VyY2UgPSBgXFxuICAgICAgICAgICAgICAke3ByZWZpeH1cXG4gICAgICAgICAgICAgICR7Z2V0VW5pZm9ybVZhcmlhYmxlRGVjbGFyYXRpb25zKF9taW5pR2wuY29tbW9uVW5pZm9ybXMsIFwiZnJhZ21lbnRcIil9XFxuICAgICAgICAgICAgICAke2dldFVuaWZvcm1WYXJpYWJsZURlY2xhcmF0aW9ucyh1bmlmb3JtcywgXCJmcmFnbWVudFwiKX1cXG4gICAgICAgICAgICAgICR7ZnJhZ21lbnRzfVxcbiAgICAgICAgICAgIGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwudmVydGV4U2hhZGVyID0gZ2V0U2hhZGVyQnlUeXBlKGNvbnRleHQuVkVSVEVYX1NIQURFUiwgbWF0ZXJpYWwudmVydGV4U291cmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciA9IGdldFNoYWRlckJ5VHlwZShjb250ZXh0LkZSQUdNRU5UX1NIQURFUiwgbWF0ZXJpYWwuU291cmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5wcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hdHRhY2hTaGFkZXIobWF0ZXJpYWwucHJvZ3JhbSwgbWF0ZXJpYWwudmVydGV4U2hhZGVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmF0dGFjaFNoYWRlcihtYXRlcmlhbC5wcm9ncmFtLCBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5rUHJvZ3JhbShtYXRlcmlhbC5wcm9ncmFtKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmdldFByb2dyYW1QYXJhbWV0ZXIobWF0ZXJpYWwucHJvZ3JhbSwgY29udGV4dC5MSU5LX1NUQVRVUykgfHwgY29uc29sZS5lcnJvcihjb250ZXh0LmdldFByb2dyYW1JbmZvTG9nKG1hdGVyaWFsLnByb2dyYW0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnVzZVByb2dyYW0obWF0ZXJpYWwucHJvZ3JhbSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwuYXR0YWNoVW5pZm9ybXModm9pZCAwLCBfbWluaUdsLmNvbW1vblVuaWZvcm1zKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5hdHRhY2hVbmlmb3Jtcyh2b2lkIDAsIG1hdGVyaWFsLnVuaWZvcm1zKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vdCA9IHVuaWZvcm1cbiAgICAgICAgICAgICAgICAgICAgYXR0YWNoVW5pZm9ybXMobmFtZSwgdW5pZm9ybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbiAgPSBtYXRlcmlhbFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBuYW1lID8gT2JqZWN0LmVudHJpZXModW5pZm9ybXMpLmZvckVhY2goKFtuYW1lLCB1bmlmb3JtXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLmF0dGFjaFVuaWZvcm1zKG5hbWUsIHVuaWZvcm0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSA6IFwiYXJyYXlcIiA9PSB1bmlmb3Jtcy50eXBlID8gdW5pZm9ybXMudmFsdWUuZm9yRWFjaCgodW5pZm9ybSwgaSkgPT4gbWF0ZXJpYWwuYXR0YWNoVW5pZm9ybXMoYCR7bmFtZX1bJHtpfV1gLCB1bmlmb3JtKSkgOiBcInN0cnVjdFwiID09IHVuaWZvcm1zLnR5cGUgPyBPYmplY3QuZW50cmllcyh1bmlmb3Jtcy52YWx1ZSkuZm9yRWFjaCgoW3VuaWZvcm0sIGldKSA9PiBtYXRlcmlhbC5hdHRhY2hVbmlmb3JtcyhgJHtuYW1lfS4ke3VuaWZvcm19YCwgaSkpIDogKF9taW5pR2wuZGVidWcoXCJNYXRlcmlhbC5hdHRhY2hVbmlmb3Jtc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtOiB1bmlmb3Jtc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksIG1hdGVyaWFsLnVuaWZvcm1JbnN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybTogdW5pZm9ybXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGNvbnRleHQuZ2V0VW5pZm9ybUxvY2F0aW9uKG1hdGVyaWFsLnByb2dyYW0sIG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBVbmlmb3JtOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNsYXNzIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJmbG9hdFwiLCBPYmplY3QuYXNzaWduKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlRm4gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQ6IFwiMWZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQ6IFwiMWlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyOiBcIjJmdlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzM6IFwiM2Z2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjNDogXCI0ZnZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXQ0OiBcIk1hdHJpeDRmdlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9W3RoaXMudHlwZV0gfHwgXCIxZlwiLCB0aGlzLnVwZGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHRoaXMudmFsdWUgJiYgY29udGV4dFtgdW5pZm9ybSR7dGhpcy50eXBlRm59YF0odmFsdWUsIDAgPT09IHRoaXMudHlwZUZuLmluZGV4T2YoXCJNYXRyaXhcIikgPyB0aGlzLnRyYW5zcG9zZSA6IHRoaXMudmFsdWUsIDAgPT09IHRoaXMudHlwZUZuLmluZGV4T2YoXCJNYXRyaXhcIikgPyB0aGlzLnZhbHVlIDogbnVsbClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2UgLSBuYW1lXG4gICAgICAgICAgICAgICAgICAgIC8vdCAtIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgLy9uIC0gbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIGdldERlY2xhcmF0aW9uKG5hbWUsIHR5cGUsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5pZm9ybSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5pZm9ybS5leGNsdWRlRnJvbSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImFycmF5XCIgPT09IHVuaWZvcm0udHlwZSkgcmV0dXJuIHVuaWZvcm0udmFsdWVbMF0uZ2V0RGVjbGFyYXRpb24obmFtZSwgdHlwZSwgdW5pZm9ybS52YWx1ZS5sZW5ndGgpICsgYFxcbmNvbnN0IGludCAke25hbWV9X2xlbmd0aCA9ICR7dW5pZm9ybS52YWx1ZS5sZW5ndGh9O2A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RydWN0XCIgPT09IHVuaWZvcm0udHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZV9ub19wcmVmaXggPSBuYW1lLnJlcGxhY2UoXCJ1X1wiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWVfbm9fcHJlZml4ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVfbm9fcHJlZml4LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVfbm9fcHJlZml4LnNsaWNlKDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYHVuaWZvcm0gc3RydWN0ICR7bmFtZV9ub19wcmVmaXh9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHVuaWZvcm0udmFsdWUpLm1hcCgoW25hbWUsIHVuaWZvcm1dKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uZ2V0RGVjbGFyYXRpb24obmFtZSwgdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL151bmlmb3JtLywgXCJcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgYFxcbn0gJHtuYW1lfSR7bGVuZ3RoID4gMCA/IGBbJHtsZW5ndGh9XWAgOiBcIlwifTtgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgdW5pZm9ybSAke3VuaWZvcm0udHlwZX0gJHtuYW1lfSR7bGVuZ3RoID4gMCA/IGBbJHtsZW5ndGh9XWAgOiBcIlwifTtgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgUGxhbmVHZW9tZXRyeToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjbGFzcyB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIG4sIGksIG9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNyZWF0ZUJ1ZmZlcigpLCB0aGlzLmF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG5ldyBfbWluaUdsLkF0dHJpYnV0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogY29udGV4dC5BUlJBWV9CVUZGRVIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1djogbmV3IF9taW5pR2wuQXR0cmlidXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBjb250ZXh0LkFSUkFZX0JVRkZFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2Tm9ybTogbmV3IF9taW5pR2wuQXR0cmlidXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBjb250ZXh0LkFSUkFZX0JVRkZFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBuZXcgX21pbmlHbC5BdHRyaWJ1dGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGNvbnRleHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGNvbnRleHQuVU5TSUdORURfU0hPUlRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5zZXRUb3BvbG9neShuLCBpKSwgdGhpcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQsIG9yaWVudGF0aW9uKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFRvcG9sb2d5KGUgPSAxLCB0ID0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLnhTZWdDb3VudCA9IGUsIG4ueVNlZ0NvdW50ID0gdCwgbi52ZXJ0ZXhDb3VudCA9IChuLnhTZWdDb3VudCArIDEpICogKG4ueVNlZ0NvdW50ICsgMSksIG4ucXVhZENvdW50ID0gbi54U2VnQ291bnQgKiBuLnlTZWdDb3VudCAqIDIsIG4uYXR0cmlidXRlcy51di52YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KDIgKiBuLnZlcnRleENvdW50KSwgbi5hdHRyaWJ1dGVzLnV2Tm9ybS52YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KDIgKiBuLnZlcnRleENvdW50KSwgbi5hdHRyaWJ1dGVzLmluZGV4LnZhbHVlcyA9IG5ldyBVaW50MTZBcnJheSgzICogbi5xdWFkQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPD0gbi55U2VnQ291bnQ7IGUrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8PSBuLnhTZWdDb3VudDsgdCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBlICogKG4ueFNlZ0NvdW50ICsgMSkgKyB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobi5hdHRyaWJ1dGVzLnV2LnZhbHVlc1syICogaV0gPSB0IC8gbi54U2VnQ291bnQsIG4uYXR0cmlidXRlcy51di52YWx1ZXNbMiAqIGkgKyAxXSA9IDEgLSBlIC8gbi55U2VnQ291bnQsIG4uYXR0cmlidXRlcy51dk5vcm0udmFsdWVzWzIgKiBpXSA9IHQgLyBuLnhTZWdDb3VudCAqIDIgLSAxLCBuLmF0dHJpYnV0ZXMudXZOb3JtLnZhbHVlc1syICogaSArIDFdID0gMSAtIGUgLyBuLnlTZWdDb3VudCAqIDIsIHQgPCBuLnhTZWdDb3VudCAmJiBlIDwgbi55U2VnQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBlICogbi54U2VnQ291bnQgKyB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbi5hdHRyaWJ1dGVzLmluZGV4LnZhbHVlc1s2ICogc10gPSBpLCBuLmF0dHJpYnV0ZXMuaW5kZXgudmFsdWVzWzYgKiBzICsgMV0gPSBpICsgMSArIG4ueFNlZ0NvdW50LCBuLmF0dHJpYnV0ZXMuaW5kZXgudmFsdWVzWzYgKiBzICsgMl0gPSBpICsgMSwgbi5hdHRyaWJ1dGVzLmluZGV4LnZhbHVlc1s2ICogcyArIDNdID0gaSArIDEsIG4uYXR0cmlidXRlcy5pbmRleC52YWx1ZXNbNiAqIHMgKyA0XSA9IGkgKyAxICsgbi54U2VnQ291bnQsIG4uYXR0cmlidXRlcy5pbmRleC52YWx1ZXNbNiAqIHMgKyA1XSA9IGkgKyAyICsgbi54U2VnQ291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG4uYXR0cmlidXRlcy51di51cGRhdGUoKSwgbi5hdHRyaWJ1dGVzLnV2Tm9ybS51cGRhdGUoKSwgbi5hdHRyaWJ1dGVzLmluZGV4LnVwZGF0ZSgpLCBfbWluaUdsLmRlYnVnKFwiR2VvbWV0cnkuc2V0VG9wb2xvZ3lcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2OiBuLmF0dHJpYnV0ZXMudXYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXZOb3JtOiBuLmF0dHJpYnV0ZXMudXZOb3JtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBuLmF0dHJpYnV0ZXMuaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0U2l6ZSh3aWR0aCA9IDEsIGhlaWdodCA9IDEsIG9yaWVudGF0aW9uID0gXCJ4elwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS53aWR0aCA9IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmhlaWdodCA9IGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24udmFsdWVzICYmIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24udmFsdWVzLmxlbmd0aCA9PT0gMyAqIGdlb21ldHJ5LnZlcnRleENvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24udmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSgzICogZ2VvbWV0cnkudmVydGV4Q291bnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG8gPSB3aWR0aCAvIC0yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBoZWlnaHQgLyAtMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50X3dpZHRoID0gd2lkdGggLyBnZW9tZXRyeS54U2VnQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBnZW9tZXRyeS55U2VnQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB5SW5kZXggPSAwOyB5SW5kZXggPD0gZ2VvbWV0cnkueVNlZ0NvdW50OyB5SW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSByICsgeUluZGV4ICogc2VnbWVudF9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeEluZGV4ID0gMDsgeEluZGV4IDw9IGdlb21ldHJ5LnhTZWdDb3VudDsgeEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IG8gKyB4SW5kZXggKiBzZWdtZW50X3dpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHlJbmRleCAqIChnZW9tZXRyeS54U2VnQ291bnQgKyAxKSArIHhJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi52YWx1ZXNbMyAqIGwgKyBcInh5elwiLmluZGV4T2Yob3JpZW50YXRpb25bMF0pXSA9IC1yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi52YWx1ZXNbMyAqIGwgKyBcInh5elwiLmluZGV4T2Yob3JpZW50YXRpb25bMV0pXSA9IC10XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi51cGRhdGUoKSwgX21pbmlHbC5kZWJ1ZyhcIkdlb21ldHJ5LnNldFNpemVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIE1lc2g6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2xhc3Mge1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcihnZW9tZXRyeSwgbWF0ZXJpYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc2ggPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzaC5nZW9tZXRyeSA9IGdlb21ldHJ5LCBtZXNoLm1hdGVyaWFsID0gbWF0ZXJpYWwsIG1lc2gud2lyZWZyYW1lID0gITEsIG1lc2guYXR0cmlidXRlSW5zdGFuY2VzID0gW10sIE9iamVjdC5lbnRyaWVzKG1lc2guZ2VvbWV0cnkuYXR0cmlidXRlcykuZm9yRWFjaCgoW2UsIGF0dHJpYnV0ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNoLmF0dHJpYnV0ZUluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiBhdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBhdHRyaWJ1dGUuYXR0YWNoKGUsIG1lc2gubWF0ZXJpYWwucHJvZ3JhbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIF9taW5pR2wubWVzaGVzLnB1c2gobWVzaCksIF9taW5pR2wuZGVidWcoXCJNZXNoLmNvbnN0cnVjdG9yXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNoOiBtZXNoXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRyYXcoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnVzZVByb2dyYW0odGhpcy5tYXRlcmlhbC5wcm9ncmFtKSwgdGhpcy5tYXRlcmlhbC51bmlmb3JtSW5zdGFuY2VzLmZvckVhY2goKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSA9PiBlLnVwZGF0ZSh0KSksIHRoaXMuYXR0cmlidXRlSW5zdGFuY2VzLmZvckVhY2goKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pID0+IGUudXNlKHQpKSwgY29udGV4dC5kcmF3RWxlbWVudHModGhpcy53aXJlZnJhbWUgPyBjb250ZXh0LkxJTkVTIDogY29udGV4dC5UUklBTkdMRVMsIHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5pbmRleC52YWx1ZXMubGVuZ3RoLCBjb250ZXh0LlVOU0lHTkVEX1NIT1JULCAwKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9taW5pR2wubWVzaGVzID0gX21pbmlHbC5tZXNoZXMuZmlsdGVyKGUgPT4gZSAhPSB0aGlzKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEF0dHJpYnV0ZToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjbGFzcyB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IGNvbnRleHQuRkxPQVQsIHRoaXMubm9ybWFsaXplZCA9ICExLCB0aGlzLmJ1ZmZlciA9IGNvbnRleHQuY3JlYXRlQnVmZmVyKCksIE9iamVjdC5hc3NpZ24odGhpcywgZSksIHRoaXMudXBkYXRlKClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHRoaXMudmFsdWVzICYmIChjb250ZXh0LmJpbmRCdWZmZXIodGhpcy50YXJnZXQsIHRoaXMuYnVmZmVyKSwgY29udGV4dC5idWZmZXJEYXRhKHRoaXMudGFyZ2V0LCB0aGlzLnZhbHVlcywgY29udGV4dC5TVEFUSUNfRFJBVykpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXR0YWNoKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBjb250ZXh0LmdldEF0dHJpYkxvY2F0aW9uKHQsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0ID09PSBjb250ZXh0LkFSUkFZX0JVRkZFUiAmJiAoY29udGV4dC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShuKSwgY29udGV4dC52ZXJ0ZXhBdHRyaWJQb2ludGVyKG4sIHRoaXMuc2l6ZSwgdGhpcy50eXBlLCB0aGlzLm5vcm1hbGl6ZWQsIDAsIDApKSwgblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVzZShlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmJpbmRCdWZmZXIodGhpcy50YXJnZXQsIHRoaXMuYnVmZmVyKSwgdGhpcy50YXJnZXQgPT09IGNvbnRleHQuQVJSQVlfQlVGRkVSICYmIChjb250ZXh0LmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGUpLCBjb250ZXh0LnZlcnRleEF0dHJpYlBvaW50ZXIoZSwgdGhpcy5zaXplLCB0aGlzLnR5cGUsIHRoaXMubm9ybWFsaXplZCwgMCwgMCkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xuICAgICAgICBfbWluaUdsLmNvbW1vblVuaWZvcm1zID0ge1xuICAgICAgICAgICAgcHJvamVjdGlvbk1hdHJpeDogbmV3IF9taW5pR2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJtYXQ0XCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGFcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbW9kZWxWaWV3TWF0cml4OiBuZXcgX21pbmlHbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm1hdDRcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogYVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByZXNvbHV0aW9uOiBuZXcgX21pbmlHbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInZlYzJcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogWzEsIDFdXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFzcGVjdFJhdGlvOiBuZXcgX21pbmlHbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDFcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0U2l6ZShlID0gNjQwLCB0ID0gNDgwKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSBlLCB0aGlzLmhlaWdodCA9IHQsIHRoaXMuY2FudmFzLndpZHRoID0gZSwgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdCwgdGhpcy5nbC52aWV3cG9ydCgwLCAwLCBlLCB0KSwgdGhpcy5jb21tb25Vbmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlID0gW2UsIHRdLCB0aGlzLmNvbW1vblVuaWZvcm1zLmFzcGVjdFJhdGlvLnZhbHVlID0gZSAvIHQsIHRoaXMuZGVidWcoXCJNaW5pR0wuc2V0U2l6ZVwiLCB7XG4gICAgICAgICAgICB3aWR0aDogZSxcbiAgICAgICAgICAgIGhlaWdodDogdFxuICAgICAgICB9KVxuICAgIH1cbiAgICAvL2xlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyXG4gICAgc2V0T3J0aG9ncmFwaGljQ2FtZXJhKGUgPSAwLCB0ID0gMCwgbiA9IDAsIGkgPSAtMmUzLCBzID0gMmUzKSB7XG4gICAgICAgIHRoaXMuY29tbW9uVW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeC52YWx1ZSA9IFsyIC8gdGhpcy53aWR0aCwgMCwgMCwgMCwgMCwgMiAvIHRoaXMuaGVpZ2h0LCAwLCAwLCAwLCAwLCAyIC8gKGkgLSBzKSwgMCwgZSwgdCwgbiwgMV0sIHRoaXMuZGVidWcoXCJzZXRPcnRob2dyYXBoaWNDYW1lcmFcIiwgdGhpcy5jb21tb25Vbmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LnZhbHVlKVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKSwgdGhpcy5nbC5jbGVhckRlcHRoKDEpLCB0aGlzLm1lc2hlcy5mb3JFYWNoKGUgPT4gZS5kcmF3KCkpXG4gICAgfVxufVxuXG5cblxuLy9TZXRzIGluaXRpYWwgcHJvcGVydGllc1xuZnVuY3Rpb24gZShvYmplY3QsIHByb3BlcnR5TmFtZSwgdmFsKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5TmFtZSBpbiBvYmplY3QgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgIHdyaXRhYmxlOiAhMFxuICAgIH0pIDogb2JqZWN0W3Byb3BlcnR5TmFtZV0gPSB2YWwsIG9iamVjdFxufVxuXG4vL0dyYWRpZW50IG9iamVjdFxuZXhwb3J0IGNsYXNzIFJpZ2h0R3JhZGllbnQge1xuICAgIGNvbnN0cnVjdG9yKC4uLnQpIHtcbiAgICAgICAgZSh0aGlzLCBcImVsXCIsIHZvaWQgMCksIGUodGhpcywgXCJjc3NWYXJSZXRyaWVzXCIsIDApLCBlKHRoaXMsIFwibWF4Q3NzVmFyUmV0cmllc1wiLCAyMDApLCBlKHRoaXMsIFwiYW5nbGVcIiwgMCksIGUodGhpcywgXCJpc0xvYWRlZENsYXNzXCIsICExKSwgZSh0aGlzLCBcImlzU2Nyb2xsaW5nXCIsICExKSwgLyplKHRoaXMsIFwiaXNTdGF0aWNcIiwgby5kaXNhYmxlQW1iaWVudEFuaW1hdGlvbnMoKSksKi8gZSh0aGlzLCBcInNjcm9sbGluZ1RpbWVvdXRcIiwgdm9pZCAwKSwgZSh0aGlzLCBcInNjcm9sbGluZ1JlZnJlc2hEZWxheVwiLCAyMDApLCBlKHRoaXMsIFwiaXNJbnRlcnNlY3RpbmdcIiwgITEpLCBlKHRoaXMsIFwic2hhZGVyRmlsZXNcIiwgdm9pZCAwKSwgZSh0aGlzLCBcInZlcnRleFNoYWRlclwiLCB2b2lkIDApLCBlKHRoaXMsIFwic2VjdGlvbkNvbG9yc1wiLCB2b2lkIDApLCBlKHRoaXMsIFwiY29tcHV0ZWRDYW52YXNTdHlsZVwiLCB2b2lkIDApLCBlKHRoaXMsIFwiY29uZlwiLCB2b2lkIDApLCBlKHRoaXMsIFwidW5pZm9ybXNcIiwgdm9pZCAwKSwgZSh0aGlzLCBcInRcIiwgMTI1MzEwNiksIGUodGhpcywgXCJsYXN0XCIsIDApLCBlKHRoaXMsIFwid2lkdGhcIiwgdm9pZCAwKSwgZSh0aGlzLCBcIm1pbldpZHRoXCIsIDExMTEpLCBlKHRoaXMsIFwiaGVpZ2h0XCIsIDYwMCksIGUodGhpcywgXCJ4U2VnQ291bnRcIiwgdm9pZCAwKSwgZSh0aGlzLCBcInlTZWdDb3VudFwiLCB2b2lkIDApLCBlKHRoaXMsIFwibWVzaFwiLCB2b2lkIDApLCBlKHRoaXMsIFwibWF0ZXJpYWxcIiwgdm9pZCAwKSwgZSh0aGlzLCBcImdlb21ldHJ5XCIsIHZvaWQgMCksIGUodGhpcywgXCJtaW5pZ2xcIiwgdm9pZCAwKSwgZSh0aGlzLCBcInNjcm9sbE9ic2VydmVyXCIsIHZvaWQgMCksIGUodGhpcywgXCJhbXBcIiwgMzIwKSwgZSh0aGlzLCBcInNlZWRcIiwgNSksIGUodGhpcywgXCJmcmVxWFwiLCAxNGUtNSksIGUodGhpcywgXCJmcmVxWVwiLCAyOWUtNSksIGUodGhpcywgXCJmcmVxRGVsdGFcIiwgMWUtNSksIGUodGhpcywgXCJhY3RpdmVDb2xvcnNcIiwgWzEsIDEsIDEsIDFdKSwgZSh0aGlzLCBcImlzTWV0YUtleVwiLCAhMSksIGUodGhpcywgXCJpc0dyYWRpZW50TGVnZW5kVmlzaWJsZVwiLCAhMSksIGUodGhpcywgXCJpc01vdXNlRG93blwiLCAhMSksIGUodGhpcywgXCJoYW5kbGVTY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2Nyb2xsaW5nVGltZW91dCksIHRoaXMuc2Nyb2xsaW5nVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5oYW5kbGVTY3JvbGxFbmQsIHRoaXMuc2Nyb2xsaW5nUmVmcmVzaERlbGF5KSwgdGhpcy5pc0dyYWRpZW50TGVnZW5kVmlzaWJsZSAmJiB0aGlzLmhpZGVHcmFkaWVudExlZ2VuZCgpLCB0aGlzLmNvbmYucGxheWluZyAmJiAodGhpcy5pc1Njcm9sbGluZyA9ICEwLCB0aGlzLnBhdXNlKCkpXG4gICAgICAgIH0pLCBlKHRoaXMsIFwiaGFuZGxlU2Nyb2xsRW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSAhMSwgdGhpcy5pc0ludGVyc2VjdGluZyAmJiB0aGlzLnBsYXkoKVxuICAgICAgICB9KSwgZSh0aGlzLCBcInJlc2l6ZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGgsIHRoaXMubWluaWdsLnNldFNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpLCB0aGlzLm1pbmlnbC5zZXRPcnRob2dyYXBoaWNDYW1lcmEoKSwgdGhpcy54U2VnQ291bnQgPSBNYXRoLmNlaWwodGhpcy53aWR0aCAqIHRoaXMuY29uZi5kZW5zaXR5WzBdKSwgdGhpcy55U2VnQ291bnQgPSBNYXRoLmNlaWwodGhpcy5oZWlnaHQgKiB0aGlzLmNvbmYuZGVuc2l0eVsxXSksIHRoaXMubWVzaC5nZW9tZXRyeS5zZXRUb3BvbG9neSh0aGlzLnhTZWdDb3VudCwgdGhpcy55U2VnQ291bnQpLCB0aGlzLm1lc2guZ2VvbWV0cnkuc2V0U2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCksIHRoaXMubWVzaC5tYXRlcmlhbC51bmlmb3Jtcy51X3NoYWRvd19wb3dlci52YWx1ZSA9IHRoaXMud2lkdGggPCA2MDAgPyA1IDogNlxuICAgICAgICB9KSwgZSh0aGlzLCBcImhhbmRsZU1vdXNlRG93blwiLCBlID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNHcmFkaWVudExlZ2VuZFZpc2libGUgJiYgKHRoaXMuaXNNZXRhS2V5ID0gZS5tZXRhS2V5LCB0aGlzLmlzTW91c2VEb3duID0gITAsICExID09PSB0aGlzLmNvbmYucGxheWluZyAmJiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlKSlcbiAgICAgICAgfSksIGUodGhpcywgXCJoYW5kbGVNb3VzZVVwXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNNb3VzZURvd24gPSAhMVxuICAgICAgICB9KSwgZSh0aGlzLCBcImFuaW1hdGVcIiwgZSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkU2tpcEZyYW1lKGUpIHx8IHRoaXMuaXNNb3VzZURvd24pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50ICs9IE1hdGgubWluKGUgLSB0aGlzLmxhc3QsIDFlMyAvIDE1KSwgdGhpcy5sYXN0ID0gZSwgdGhpcy5pc01vdXNlRG93bikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZSA9IDE2MDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc01ldGFLZXkgJiYgKGUgPSAtMTYwKSwgdGhpcy50ICs9IGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNoLm1hdGVyaWFsLnVuaWZvcm1zLnVfdGltZS52YWx1ZSA9IHRoaXMudCwgdGhpcy5taW5pZ2wucmVuZGVyKClcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKDAgIT09IHRoaXMubGFzdCAmJiB0aGlzLmlzU3RhdGljKSByZXR1cm4gdGhpcy5taW5pZ2wucmVuZGVyKCksIHZvaWQgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAoLyp0aGlzLmlzSW50ZXJzZWN0aW5nICYmICovdGhpcy5jb25mLnBsYXlpbmcgfHwgdGhpcy5pc01vdXNlRG93bikgJiYgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZSlcbiAgICAgICAgfSksIGUodGhpcywgXCJhZGRJc0xvYWRlZENsYXNzXCIsICgpID0+IHtcbiAgICAgICAgICAgIC8qdGhpcy5pc0ludGVyc2VjdGluZyAmJiAqLyF0aGlzLmlzTG9hZGVkQ2xhc3MgJiYgKHRoaXMuaXNMb2FkZWRDbGFzcyA9ICEwLCB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoXCJpc0xvYWRlZFwiKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVsLnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImlzTG9hZGVkXCIpXG4gICAgICAgIH0sIDNlMykpXG4gICAgICAgIH0pLCBlKHRoaXMsIFwicGF1c2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25mLnBsYXlpbmcgPSBmYWxzZVxuICAgICAgICB9KSwgZSh0aGlzLCBcInBsYXlcIiwgKCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZSksIHRoaXMuY29uZi5wbGF5aW5nID0gdHJ1ZVxuICAgICAgICB9KSwgZSh0aGlzLCBcImluaXRHcmFkaWVudFwiLCAoc2VsZWN0b3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pXG4gICAgfVxuICAgIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuc2hhZGVyRmlsZXMgPSB7XG4gICAgICAgICAgICB2ZXJ0ZXg6IFwidmFyeWluZyB2ZWMzIHZfY29sb3I7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgZmxvYXQgdGltZSA9IHVfdGltZSAqIHVfZ2xvYmFsLm5vaXNlU3BlZWQ7XFxuXFxuICB2ZWMyIG5vaXNlQ29vcmQgPSByZXNvbHV0aW9uICogdXZOb3JtICogdV9nbG9iYWwubm9pc2VGcmVxO1xcblxcbiAgdmVjMiBzdCA9IDEuIC0gdXZOb3JtLnh5O1xcblxcbiAgLy9cXG4gIC8vIFRpbHRpbmcgdGhlIHBsYW5lXFxuICAvL1xcblxcbiAgLy8gRnJvbnQtdG8tYmFjayB0aWx0XFxuICBmbG9hdCB0aWx0ID0gcmVzb2x1dGlvbi55IC8gMi4wICogdXZOb3JtLnk7XFxuXFxuICAvLyBMZWZ0LXRvLXJpZ2h0IGFuZ2xlXFxuICBmbG9hdCBpbmNsaW5lID0gcmVzb2x1dGlvbi54ICogdXZOb3JtLnggLyAyLjAgKiB1X3ZlcnREZWZvcm0uaW5jbGluZTtcXG5cXG4gIC8vIFVwLWRvd24gc2hpZnQgdG8gb2Zmc2V0IGluY2xpbmVcXG4gIGZsb2F0IG9mZnNldCA9IHJlc29sdXRpb24ueCAvIDIuMCAqIHVfdmVydERlZm9ybS5pbmNsaW5lICogbWl4KHVfdmVydERlZm9ybS5vZmZzZXRCb3R0b20sIHVfdmVydERlZm9ybS5vZmZzZXRUb3AsIHV2LnkpO1xcblxcbiAgLy9cXG4gIC8vIFZlcnRleCBub2lzZVxcbiAgLy9cXG5cXG4gIGZsb2F0IG5vaXNlID0gc25vaXNlKHZlYzMoXFxuICAgIG5vaXNlQ29vcmQueCAqIHVfdmVydERlZm9ybS5ub2lzZUZyZXEueCArIHRpbWUgKiB1X3ZlcnREZWZvcm0ubm9pc2VGbG93LFxcbiAgICBub2lzZUNvb3JkLnkgKiB1X3ZlcnREZWZvcm0ubm9pc2VGcmVxLnksXFxuICAgIHRpbWUgKiB1X3ZlcnREZWZvcm0ubm9pc2VTcGVlZCArIHVfdmVydERlZm9ybS5ub2lzZVNlZWRcXG4gICkpICogdV92ZXJ0RGVmb3JtLm5vaXNlQW1wO1xcblxcbiAgLy8gRmFkZSBub2lzZSB0byB6ZXJvIGF0IGVkZ2VzXFxuICBub2lzZSAqPSAxLjAgLSBwb3coYWJzKHV2Tm9ybS55KSwgMi4wKTtcXG5cXG4gIC8vIENsYW1wIHRvIDBcXG4gIG5vaXNlID0gbWF4KDAuMCwgbm9pc2UpO1xcblxcbiAgdmVjMyBwb3MgPSB2ZWMzKFxcbiAgICBwb3NpdGlvbi54LFxcbiAgICBwb3NpdGlvbi55ICsgdGlsdCArIGluY2xpbmUgKyBub2lzZSAtIG9mZnNldCxcXG4gICAgcG9zaXRpb24uelxcbiAgKTtcXG5cXG4gIC8vXFxuICAvLyBWZXJ0ZXggY29sb3IsIHRvIGJlIHBhc3NlZCB0byBmcmFnbWVudCBzaGFkZXJcXG4gIC8vXFxuXFxuICBpZiAodV9hY3RpdmVfY29sb3JzWzBdID09IDEuKSB7XFxuICAgIHZfY29sb3IgPSB1X2Jhc2VDb2xvcjtcXG4gIH1cXG5cXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgdV93YXZlTGF5ZXJzX2xlbmd0aDsgaSsrKSB7XFxuICAgIGlmICh1X2FjdGl2ZV9jb2xvcnNbaSArIDFdID09IDEuKSB7XFxuICAgICAgV2F2ZUxheWVycyBsYXllciA9IHVfd2F2ZUxheWVyc1tpXTtcXG5cXG4gICAgICBmbG9hdCBub2lzZSA9IHNtb290aHN0ZXAoXFxuICAgICAgICBsYXllci5ub2lzZUZsb29yLFxcbiAgICAgICAgbGF5ZXIubm9pc2VDZWlsLFxcbiAgICAgICAgc25vaXNlKHZlYzMoXFxuICAgICAgICAgIG5vaXNlQ29vcmQueCAqIGxheWVyLm5vaXNlRnJlcS54ICsgdGltZSAqIGxheWVyLm5vaXNlRmxvdyxcXG4gICAgICAgICAgbm9pc2VDb29yZC55ICogbGF5ZXIubm9pc2VGcmVxLnksXFxuICAgICAgICAgIHRpbWUgKiBsYXllci5ub2lzZVNwZWVkICsgbGF5ZXIubm9pc2VTZWVkXFxuICAgICAgICApKSAvIDIuMCArIDAuNVxcbiAgICAgICk7XFxuXFxuICAgICAgdl9jb2xvciA9IGJsZW5kTm9ybWFsKHZfY29sb3IsIGxheWVyLmNvbG9yLCBwb3cobm9pc2UsIDQuKSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vXFxuICAvLyBGaW5pc2hcXG4gIC8vXFxuXFxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvcywgMS4wKTtcXG59XCIsXG4gICAgICAgICAgICBub2lzZTogXCIvL1xcbi8vIERlc2NyaXB0aW9uIDogQXJyYXkgYW5kIHRleHR1cmVsZXNzIEdMU0wgMkQvM0QvNEQgc2ltcGxleFxcbi8vICAgICAgICAgICAgICAgbm9pc2UgZnVuY3Rpb25zLlxcbi8vICAgICAgQXV0aG9yIDogSWFuIE1jRXdhbiwgQXNoaW1hIEFydHMuXFxuLy8gIE1haW50YWluZXIgOiBzdGVndVxcbi8vICAgICBMYXN0bW9kIDogMjAxMTA4MjIgKGlqbSlcXG4vLyAgICAgTGljZW5zZSA6IENvcHlyaWdodCAoQykgMjAxMSBBc2hpbWEgQXJ0cy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4vLyAgICAgICAgICAgICAgIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZS5cXG4vLyAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hc2hpbWEvd2ViZ2wtbm9pc2VcXG4vLyAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9zdGVndS93ZWJnbC1ub2lzZVxcbi8vXFxuXFxudmVjMyBtb2QyODkodmVjMyB4KSB7XFxuICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wO1xcbn1cXG5cXG52ZWM0IG1vZDI4OSh2ZWM0IHgpIHtcXG4gIHJldHVybiB4IC0gZmxvb3IoeCAqICgxLjAgLyAyODkuMCkpICogMjg5LjA7XFxufVxcblxcbnZlYzQgcGVybXV0ZSh2ZWM0IHgpIHtcXG4gICAgcmV0dXJuIG1vZDI4OSgoKHgqMzQuMCkrMS4wKSp4KTtcXG59XFxuXFxudmVjNCB0YXlsb3JJbnZTcXJ0KHZlYzQgcilcXG57XFxuICByZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO1xcbn1cXG5cXG5mbG9hdCBzbm9pc2UodmVjMyB2KVxcbntcXG4gIGNvbnN0IHZlYzIgIEMgPSB2ZWMyKDEuMC82LjAsIDEuMC8zLjApIDtcXG4gIGNvbnN0IHZlYzQgIEQgPSB2ZWM0KDAuMCwgMC41LCAxLjAsIDIuMCk7XFxuXFxuLy8gRmlyc3QgY29ybmVyXFxuICB2ZWMzIGkgID0gZmxvb3IodiArIGRvdCh2LCBDLnl5eSkgKTtcXG4gIHZlYzMgeDAgPSAgIHYgLSBpICsgZG90KGksIEMueHh4KSA7XFxuXFxuLy8gT3RoZXIgY29ybmVyc1xcbiAgdmVjMyBnID0gc3RlcCh4MC55engsIHgwLnh5eik7XFxuICB2ZWMzIGwgPSAxLjAgLSBnO1xcbiAgdmVjMyBpMSA9IG1pbiggZy54eXosIGwuenh5ICk7XFxuICB2ZWMzIGkyID0gbWF4KCBnLnh5eiwgbC56eHkgKTtcXG5cXG4gIC8vICAgeDAgPSB4MCAtIDAuMCArIDAuMCAqIEMueHh4O1xcbiAgLy8gICB4MSA9IHgwIC0gaTEgICsgMS4wICogQy54eHg7XFxuICAvLyAgIHgyID0geDAgLSBpMiAgKyAyLjAgKiBDLnh4eDtcXG4gIC8vICAgeDMgPSB4MCAtIDEuMCArIDMuMCAqIEMueHh4O1xcbiAgdmVjMyB4MSA9IHgwIC0gaTEgKyBDLnh4eDtcXG4gIHZlYzMgeDIgPSB4MCAtIGkyICsgQy55eXk7IC8vIDIuMCpDLnggPSAxLzMgPSBDLnlcXG4gIHZlYzMgeDMgPSB4MCAtIEQueXl5OyAgICAgIC8vIC0xLjArMy4wKkMueCA9IC0wLjUgPSAtRC55XFxuXFxuLy8gUGVybXV0YXRpb25zXFxuICBpID0gbW9kMjg5KGkpO1xcbiAgdmVjNCBwID0gcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZShcXG4gICAgICAgICAgICBpLnogKyB2ZWM0KDAuMCwgaTEueiwgaTIueiwgMS4wICkpXFxuICAgICAgICAgICsgaS55ICsgdmVjNCgwLjAsIGkxLnksIGkyLnksIDEuMCApKVxcbiAgICAgICAgICArIGkueCArIHZlYzQoMC4wLCBpMS54LCBpMi54LCAxLjAgKSk7XFxuXFxuLy8gR3JhZGllbnRzOiA3eDcgcG9pbnRzIG92ZXIgYSBzcXVhcmUsIG1hcHBlZCBvbnRvIGFuIG9jdGFoZWRyb24uXFxuLy8gVGhlIHJpbmcgc2l6ZSAxNyoxNyA9IDI4OSBpcyBjbG9zZSB0byBhIG11bHRpcGxlIG9mIDQ5ICg0OSo2ID0gMjk0KVxcbiAgZmxvYXQgbl8gPSAwLjE0Mjg1NzE0Mjg1NzsgLy8gMS4wLzcuMFxcbiAgdmVjMyAgbnMgPSBuXyAqIEQud3l6IC0gRC54eng7XFxuXFxuICB2ZWM0IGogPSBwIC0gNDkuMCAqIGZsb29yKHAgKiBucy56ICogbnMueik7ICAvLyAgbW9kKHAsNyo3KVxcblxcbiAgdmVjNCB4XyA9IGZsb29yKGogKiBucy56KTtcXG4gIHZlYzQgeV8gPSBmbG9vcihqIC0gNy4wICogeF8gKTsgICAgLy8gbW9kKGosTilcXG5cXG4gIHZlYzQgeCA9IHhfICpucy54ICsgbnMueXl5eTtcXG4gIHZlYzQgeSA9IHlfICpucy54ICsgbnMueXl5eTtcXG4gIHZlYzQgaCA9IDEuMCAtIGFicyh4KSAtIGFicyh5KTtcXG5cXG4gIHZlYzQgYjAgPSB2ZWM0KCB4Lnh5LCB5Lnh5ICk7XFxuICB2ZWM0IGIxID0gdmVjNCggeC56dywgeS56dyApO1xcblxcbiAgLy92ZWM0IHMwID0gdmVjNChsZXNzVGhhbihiMCwwLjApKSoyLjAgLSAxLjA7XFxuICAvL3ZlYzQgczEgPSB2ZWM0KGxlc3NUaGFuKGIxLDAuMCkpKjIuMCAtIDEuMDtcXG4gIHZlYzQgczAgPSBmbG9vcihiMCkqMi4wICsgMS4wO1xcbiAgdmVjNCBzMSA9IGZsb29yKGIxKSoyLjAgKyAxLjA7XFxuICB2ZWM0IHNoID0gLXN0ZXAoaCwgdmVjNCgwLjApKTtcXG5cXG4gIHZlYzQgYTAgPSBiMC54enl3ICsgczAueHp5dypzaC54eHl5IDtcXG4gIHZlYzQgYTEgPSBiMS54enl3ICsgczEueHp5dypzaC56end3IDtcXG5cXG4gIHZlYzMgcDAgPSB2ZWMzKGEwLnh5LGgueCk7XFxuICB2ZWMzIHAxID0gdmVjMyhhMC56dyxoLnkpO1xcbiAgdmVjMyBwMiA9IHZlYzMoYTEueHksaC56KTtcXG4gIHZlYzMgcDMgPSB2ZWMzKGExLnp3LGgudyk7XFxuXFxuLy9Ob3JtYWxpc2UgZ3JhZGllbnRzXFxuICB2ZWM0IG5vcm0gPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KHAwLHAwKSwgZG90KHAxLHAxKSwgZG90KHAyLCBwMiksIGRvdChwMyxwMykpKTtcXG4gIHAwICo9IG5vcm0ueDtcXG4gIHAxICo9IG5vcm0ueTtcXG4gIHAyICo9IG5vcm0uejtcXG4gIHAzICo9IG5vcm0udztcXG5cXG4vLyBNaXggZmluYWwgbm9pc2UgdmFsdWVcXG4gIHZlYzQgbSA9IG1heCgwLjYgLSB2ZWM0KGRvdCh4MCx4MCksIGRvdCh4MSx4MSksIGRvdCh4Mix4MiksIGRvdCh4Myx4MykpLCAwLjApO1xcbiAgbSA9IG0gKiBtO1xcbiAgcmV0dXJuIDQyLjAgKiBkb3QoIG0qbSwgdmVjNCggZG90KHAwLHgwKSwgZG90KHAxLHgxKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdChwMix4MiksIGRvdChwMyx4MykgKSApO1xcbn1cIixcbiAgICAgICAgICAgIGJsZW5kOiBcIi8vXFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2phbWllb3dlbi9nbHNsLWJsZW5kXFxuLy9cXG5cXG4vLyBOb3JtYWxcXG5cXG52ZWMzIGJsZW5kTm9ybWFsKHZlYzMgYmFzZSwgdmVjMyBibGVuZCkge1xcblxcdHJldHVybiBibGVuZDtcXG59XFxuXFxudmVjMyBibGVuZE5vcm1hbCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kTm9ybWFsKGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gU2NyZWVuXFxuXFxuZmxvYXQgYmxlbmRTY3JlZW4oZmxvYXQgYmFzZSwgZmxvYXQgYmxlbmQpIHtcXG5cXHRyZXR1cm4gMS4wLSgoMS4wLWJhc2UpKigxLjAtYmxlbmQpKTtcXG59XFxuXFxudmVjMyBibGVuZFNjcmVlbih2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHRyZXR1cm4gdmVjMyhibGVuZFNjcmVlbihiYXNlLnIsYmxlbmQuciksYmxlbmRTY3JlZW4oYmFzZS5nLGJsZW5kLmcpLGJsZW5kU2NyZWVuKGJhc2UuYixibGVuZC5iKSk7XFxufVxcblxcbnZlYzMgYmxlbmRTY3JlZW4odmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZFNjcmVlbihiYXNlLCBibGVuZCkgKiBvcGFjaXR5ICsgYmFzZSAqICgxLjAgLSBvcGFjaXR5KSk7XFxufVxcblxcbi8vIE11bHRpcGx5XFxuXFxudmVjMyBibGVuZE11bHRpcGx5KHZlYzMgYmFzZSwgdmVjMyBibGVuZCkge1xcblxcdHJldHVybiBiYXNlKmJsZW5kO1xcbn1cXG5cXG52ZWMzIGJsZW5kTXVsdGlwbHkodmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZE11bHRpcGx5KGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gT3ZlcmxheVxcblxcbmZsb2F0IGJsZW5kT3ZlcmxheShmbG9hdCBiYXNlLCBmbG9hdCBibGVuZCkge1xcblxcdHJldHVybiBiYXNlPDAuNT8oMi4wKmJhc2UqYmxlbmQpOigxLjAtMi4wKigxLjAtYmFzZSkqKDEuMC1ibGVuZCkpO1xcbn1cXG5cXG52ZWMzIGJsZW5kT3ZlcmxheSh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHRyZXR1cm4gdmVjMyhibGVuZE92ZXJsYXkoYmFzZS5yLGJsZW5kLnIpLGJsZW5kT3ZlcmxheShiYXNlLmcsYmxlbmQuZyksYmxlbmRPdmVybGF5KGJhc2UuYixibGVuZC5iKSk7XFxufVxcblxcbnZlYzMgYmxlbmRPdmVybGF5KHZlYzMgYmFzZSwgdmVjMyBibGVuZCwgZmxvYXQgb3BhY2l0eSkge1xcblxcdHJldHVybiAoYmxlbmRPdmVybGF5KGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gSGFyZCBsaWdodFxcblxcbnZlYzMgYmxlbmRIYXJkTGlnaHQodmVjMyBiYXNlLCB2ZWMzIGJsZW5kKSB7XFxuXFx0cmV0dXJuIGJsZW5kT3ZlcmxheShibGVuZCxiYXNlKTtcXG59XFxuXFxudmVjMyBibGVuZEhhcmRMaWdodCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kSGFyZExpZ2h0KGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gU29mdCBsaWdodFxcblxcbmZsb2F0IGJsZW5kU29mdExpZ2h0KGZsb2F0IGJhc2UsIGZsb2F0IGJsZW5kKSB7XFxuXFx0cmV0dXJuIChibGVuZDwwLjUpPygyLjAqYmFzZSpibGVuZCtiYXNlKmJhc2UqKDEuMC0yLjAqYmxlbmQpKTooc3FydChiYXNlKSooMi4wKmJsZW5kLTEuMCkrMi4wKmJhc2UqKDEuMC1ibGVuZCkpO1xcbn1cXG5cXG52ZWMzIGJsZW5kU29mdExpZ2h0KHZlYzMgYmFzZSwgdmVjMyBibGVuZCkge1xcblxcdHJldHVybiB2ZWMzKGJsZW5kU29mdExpZ2h0KGJhc2UucixibGVuZC5yKSxibGVuZFNvZnRMaWdodChiYXNlLmcsYmxlbmQuZyksYmxlbmRTb2Z0TGlnaHQoYmFzZS5iLGJsZW5kLmIpKTtcXG59XFxuXFxudmVjMyBibGVuZFNvZnRMaWdodCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kU29mdExpZ2h0KGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gQ29sb3IgZG9kZ2VcXG5cXG5mbG9hdCBibGVuZENvbG9yRG9kZ2UoZmxvYXQgYmFzZSwgZmxvYXQgYmxlbmQpIHtcXG5cXHRyZXR1cm4gKGJsZW5kPT0xLjApP2JsZW5kOm1pbihiYXNlLygxLjAtYmxlbmQpLDEuMCk7XFxufVxcblxcbnZlYzMgYmxlbmRDb2xvckRvZGdlKHZlYzMgYmFzZSwgdmVjMyBibGVuZCkge1xcblxcdHJldHVybiB2ZWMzKGJsZW5kQ29sb3JEb2RnZShiYXNlLnIsYmxlbmQuciksYmxlbmRDb2xvckRvZGdlKGJhc2UuZyxibGVuZC5nKSxibGVuZENvbG9yRG9kZ2UoYmFzZS5iLGJsZW5kLmIpKTtcXG59XFxuXFxudmVjMyBibGVuZENvbG9yRG9kZ2UodmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZENvbG9yRG9kZ2UoYmFzZSwgYmxlbmQpICogb3BhY2l0eSArIGJhc2UgKiAoMS4wIC0gb3BhY2l0eSkpO1xcbn1cXG5cXG4vLyBDb2xvciBidXJuXFxuXFxuZmxvYXQgYmxlbmRDb2xvckJ1cm4oZmxvYXQgYmFzZSwgZmxvYXQgYmxlbmQpIHtcXG5cXHRyZXR1cm4gKGJsZW5kPT0wLjApP2JsZW5kOm1heCgoMS4wLSgoMS4wLWJhc2UpL2JsZW5kKSksMC4wKTtcXG59XFxuXFxudmVjMyBibGVuZENvbG9yQnVybih2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHRyZXR1cm4gdmVjMyhibGVuZENvbG9yQnVybihiYXNlLnIsYmxlbmQuciksYmxlbmRDb2xvckJ1cm4oYmFzZS5nLGJsZW5kLmcpLGJsZW5kQ29sb3JCdXJuKGJhc2UuYixibGVuZC5iKSk7XFxufVxcblxcbnZlYzMgYmxlbmRDb2xvckJ1cm4odmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZENvbG9yQnVybihiYXNlLCBibGVuZCkgKiBvcGFjaXR5ICsgYmFzZSAqICgxLjAgLSBvcGFjaXR5KSk7XFxufVxcblxcbi8vIFZpdmlkIExpZ2h0XFxuXFxuZmxvYXQgYmxlbmRWaXZpZExpZ2h0KGZsb2F0IGJhc2UsIGZsb2F0IGJsZW5kKSB7XFxuXFx0cmV0dXJuIChibGVuZDwwLjUpP2JsZW5kQ29sb3JCdXJuKGJhc2UsKDIuMCpibGVuZCkpOmJsZW5kQ29sb3JEb2RnZShiYXNlLCgyLjAqKGJsZW5kLTAuNSkpKTtcXG59XFxuXFxudmVjMyBibGVuZFZpdmlkTGlnaHQodmVjMyBiYXNlLCB2ZWMzIGJsZW5kKSB7XFxuXFx0cmV0dXJuIHZlYzMoYmxlbmRWaXZpZExpZ2h0KGJhc2UucixibGVuZC5yKSxibGVuZFZpdmlkTGlnaHQoYmFzZS5nLGJsZW5kLmcpLGJsZW5kVml2aWRMaWdodChiYXNlLmIsYmxlbmQuYikpO1xcbn1cXG5cXG52ZWMzIGJsZW5kVml2aWRMaWdodCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kVml2aWRMaWdodChiYXNlLCBibGVuZCkgKiBvcGFjaXR5ICsgYmFzZSAqICgxLjAgLSBvcGFjaXR5KSk7XFxufVxcblxcbi8vIExpZ2h0ZW5cXG5cXG5mbG9hdCBibGVuZExpZ2h0ZW4oZmxvYXQgYmFzZSwgZmxvYXQgYmxlbmQpIHtcXG5cXHRyZXR1cm4gbWF4KGJsZW5kLGJhc2UpO1xcbn1cXG5cXG52ZWMzIGJsZW5kTGlnaHRlbih2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHRyZXR1cm4gdmVjMyhibGVuZExpZ2h0ZW4oYmFzZS5yLGJsZW5kLnIpLGJsZW5kTGlnaHRlbihiYXNlLmcsYmxlbmQuZyksYmxlbmRMaWdodGVuKGJhc2UuYixibGVuZC5iKSk7XFxufVxcblxcbnZlYzMgYmxlbmRMaWdodGVuKHZlYzMgYmFzZSwgdmVjMyBibGVuZCwgZmxvYXQgb3BhY2l0eSkge1xcblxcdHJldHVybiAoYmxlbmRMaWdodGVuKGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gTGluZWFyIGJ1cm5cXG5cXG5mbG9hdCBibGVuZExpbmVhckJ1cm4oZmxvYXQgYmFzZSwgZmxvYXQgYmxlbmQpIHtcXG5cXHQvLyBOb3RlIDogU2FtZSBpbXBsZW1lbnRhdGlvbiBhcyBCbGVuZFN1YnRyYWN0ZlxcblxcdHJldHVybiBtYXgoYmFzZStibGVuZC0xLjAsMC4wKTtcXG59XFxuXFxudmVjMyBibGVuZExpbmVhckJ1cm4odmVjMyBiYXNlLCB2ZWMzIGJsZW5kKSB7XFxuXFx0Ly8gTm90ZSA6IFNhbWUgaW1wbGVtZW50YXRpb24gYXMgQmxlbmRTdWJ0cmFjdFxcblxcdHJldHVybiBtYXgoYmFzZStibGVuZC12ZWMzKDEuMCksdmVjMygwLjApKTtcXG59XFxuXFxudmVjMyBibGVuZExpbmVhckJ1cm4odmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZExpbmVhckJ1cm4oYmFzZSwgYmxlbmQpICogb3BhY2l0eSArIGJhc2UgKiAoMS4wIC0gb3BhY2l0eSkpO1xcbn1cXG5cXG4vLyBMaW5lYXIgZG9kZ2VcXG5cXG5mbG9hdCBibGVuZExpbmVhckRvZGdlKGZsb2F0IGJhc2UsIGZsb2F0IGJsZW5kKSB7XFxuXFx0Ly8gTm90ZSA6IFNhbWUgaW1wbGVtZW50YXRpb24gYXMgQmxlbmRBZGRmXFxuXFx0cmV0dXJuIG1pbihiYXNlK2JsZW5kLDEuMCk7XFxufVxcblxcbnZlYzMgYmxlbmRMaW5lYXJEb2RnZSh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHQvLyBOb3RlIDogU2FtZSBpbXBsZW1lbnRhdGlvbiBhcyBCbGVuZEFkZFxcblxcdHJldHVybiBtaW4oYmFzZStibGVuZCx2ZWMzKDEuMCkpO1xcbn1cXG5cXG52ZWMzIGJsZW5kTGluZWFyRG9kZ2UodmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZExpbmVhckRvZGdlKGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gTGluZWFyIGxpZ2h0XFxuXFxuZmxvYXQgYmxlbmRMaW5lYXJMaWdodChmbG9hdCBiYXNlLCBmbG9hdCBibGVuZCkge1xcblxcdHJldHVybiBibGVuZDwwLjU/YmxlbmRMaW5lYXJCdXJuKGJhc2UsKDIuMCpibGVuZCkpOmJsZW5kTGluZWFyRG9kZ2UoYmFzZSwoMi4wKihibGVuZC0wLjUpKSk7XFxufVxcblxcbnZlYzMgYmxlbmRMaW5lYXJMaWdodCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHRyZXR1cm4gdmVjMyhibGVuZExpbmVhckxpZ2h0KGJhc2UucixibGVuZC5yKSxibGVuZExpbmVhckxpZ2h0KGJhc2UuZyxibGVuZC5nKSxibGVuZExpbmVhckxpZ2h0KGJhc2UuYixibGVuZC5iKSk7XFxufVxcblxcbnZlYzMgYmxlbmRMaW5lYXJMaWdodCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kTGluZWFyTGlnaHQoYmFzZSwgYmxlbmQpICogb3BhY2l0eSArIGJhc2UgKiAoMS4wIC0gb3BhY2l0eSkpO1xcbn1cIixcbiAgICAgICAgICAgIGZyYWdtZW50OiBcInZhcnlpbmcgdmVjMyB2X2NvbG9yO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzMgY29sb3IgPSB2X2NvbG9yO1xcbiAgaWYgKHVfZGFya2VuX3RvcCA9PSAxLjApIHtcXG4gICAgdmVjMiBzdCA9IGdsX0ZyYWdDb29yZC54eS9yZXNvbHV0aW9uLnh5O1xcbiAgICBjb2xvci5nIC09IHBvdyhzdC55ICsgc2luKC0xMi4wKSAqIHN0LngsIHVfc2hhZG93X3Bvd2VyKSAqIDAuNDtcXG4gIH1cXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIDEuMCk7XFxufVwiXG4gICAgICAgIH0sXG4gICAgICAgICAgICB0aGlzLmNvbmYgPSB7XG4gICAgICAgICAgICAgICAgcHJlc2V0TmFtZTogXCJcIixcbiAgICAgICAgICAgICAgICB3aXJlZnJhbWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRlbnNpdHk6IFsuMDYsIC4xNl0sXG4gICAgICAgICAgICAgICAgem9vbTogMSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogMCxcbiAgICAgICAgICAgICAgICBwbGF5aW5nOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImNhbnZhc1wiKS5sZW5ndGggPCAxID8gY29uc29sZS5sb2coXCJESUQgTk9UIExPQUQgSEVSTyBTVFJJUEUgQ0FOVkFTXCIpIDogKFxuXG4gICAgICAgICAgICAgICAgdGhpcy5taW5pZ2wgPSBuZXcgTWluaUdsKHRoaXMuZWwsIG51bGwsIG51bGwsICEwKSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsICYmICh0aGlzLmNvbXB1dGVkQ2FudmFzU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuZWwpLCB0aGlzLndhaXRGb3JDc3NWYXJzKCkpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsT2JzZXJ2ZXIgPSBhd2FpdCBzLmNyZWF0ZSguMSwgITEpLFxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmVsKSxcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbE9ic2VydmVyLm9uU2VwYXJhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLmhhbmRsZVNjcm9sbCksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuaGFuZGxlTW91c2VEb3duKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuaGFuZGxlTW91c2VVcCksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmhhbmRsZUtleURvd24pLCB0aGlzLmlzSW50ZXJzZWN0aW5nID0gITEsIHRoaXMuY29uZi5wbGF5aW5nICYmIHRoaXMucGF1c2UoKVxuICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbE9ic2VydmVyLm9uSW50ZXJzZWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5oYW5kbGVTY3JvbGwpLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLmhhbmRsZU1vdXNlRG93biksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLmhhbmRsZU1vdXNlVXApLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5oYW5kbGVLZXlEb3duKSwgdGhpcy5pc0ludGVyc2VjdGluZyA9ICEwLCB0aGlzLmFkZElzTG9hZGVkQ2xhc3MoKSwgdGhpcy5wbGF5KClcbiAgICAgICAgICAgICAgICB9KSovXG5cbiAgICAgICAgICAgIClcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxPYnNlcnZlciAmJiAod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5oYW5kbGVTY3JvbGwpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLmhhbmRsZU1vdXNlRG93biksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLmhhbmRsZU1vdXNlVXApLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5oYW5kbGVLZXlEb3duKSwgdGhpcy5zY3JvbGxPYnNlcnZlci5kaXNjb25uZWN0KCkpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLnJlc2l6ZSlcbiAgICB9XG4gICAgaW5pdE1hdGVyaWFsKCkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgICAgICAgdV90aW1lOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdV9zaGFkb3dfcG93ZXI6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogNVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB1X2Rhcmtlbl90b3A6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIiA9PT0gdGhpcy5lbC5kYXRhc2V0LmpzRGFya2VuVG9wID8gMSA6IDBcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdV9hY3RpdmVfY29sb3JzOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuYWN0aXZlQ29sb3JzLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidmVjNFwiXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHVfZ2xvYmFsOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgbm9pc2VGcmVxOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW3RoaXMuZnJlcVgsIHRoaXMuZnJlcVldLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ2ZWMyXCJcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIG5vaXNlU3BlZWQ6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiA1ZS02XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cnVjdFwiXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHVfdmVydERlZm9ybTogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIGluY2xpbmU6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBNYXRoLnNpbih0aGlzLmFuZ2xlKSAvIE1hdGguY29zKHRoaXMuYW5nbGUpXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRUb3A6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAtLjVcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEJvdHRvbTogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IC0uNVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgbm9pc2VGcmVxOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogWzMsIDRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ2ZWMyXCJcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIG5vaXNlQW1wOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5hbXBcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIG5vaXNlU3BlZWQ6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAxMFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgbm9pc2VGbG93OiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogM1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgbm9pc2VTZWVkOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zZWVkXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cnVjdFwiLFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVGcm9tOiBcImZyYWdtZW50XCJcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdV9iYXNlQ29sb3I6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zZWN0aW9uQ29sb3JzWzBdLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidmVjM1wiLFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVGcm9tOiBcImZyYWdtZW50XCJcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdV93YXZlTGF5ZXJzOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVGcm9tOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiXG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBlID0gMTsgZSA8IHRoaXMuc2VjdGlvbkNvbG9ycy5sZW5ndGg7IGUgKz0gMSkgdGhpcy51bmlmb3Jtcy51X3dhdmVMYXllcnMudmFsdWUucHVzaChuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNlY3Rpb25Db2xvcnNbZV0sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidmVjM1wiXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbm9pc2VGcmVxOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbMiArIGUgLyB0aGlzLnNlY3Rpb25Db2xvcnMubGVuZ3RoLCAzICsgZSAvIHRoaXMuc2VjdGlvbkNvbG9ycy5sZW5ndGhdLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInZlYzJcIlxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG5vaXNlU3BlZWQ6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDExICsgLjMgKiBlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbm9pc2VGbG93OiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiA2LjUgKyAuMyAqIGVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBub2lzZVNlZWQ6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc2VlZCArIDEwICogZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG5vaXNlRmxvb3I6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IC4xXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbm9pc2VDZWlsOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAuNjMgKyAuMDcgKiBlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiBcInN0cnVjdFwiXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGV4U2hhZGVyID0gW3RoaXMuc2hhZGVyRmlsZXMubm9pc2UsIHRoaXMuc2hhZGVyRmlsZXMuYmxlbmQsIHRoaXMuc2hhZGVyRmlsZXMudmVydGV4XS5qb2luKFwiXFxuXFxuXCIpLCBuZXcgdGhpcy5taW5pZ2wuTWF0ZXJpYWwodGhpcy52ZXJ0ZXhTaGFkZXIsIHRoaXMuc2hhZGVyRmlsZXMuZnJhZ21lbnQsIHRoaXMudW5pZm9ybXMpXG4gICAgfVxuICAgIGluaXRNZXNoKCkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsID0gdGhpcy5pbml0TWF0ZXJpYWwoKSwgdGhpcy5nZW9tZXRyeSA9IG5ldyB0aGlzLm1pbmlnbC5QbGFuZUdlb21ldHJ5LCB0aGlzLm1lc2ggPSBuZXcgdGhpcy5taW5pZ2wuTWVzaCh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKVxuICAgIH1cbiAgICBzaG91bGRTa2lwRnJhbWUoZSkge1xuICAgICAgICByZXR1cm4gISF3aW5kb3cuZG9jdW1lbnQuaGlkZGVuIHx8ICghdGhpcy5jb25mLnBsYXlpbmcgfHwgKHBhcnNlSW50KGUsIDEwKSAlIDIgPT0gMCB8fCB2b2lkIDApKVxuICAgIH1cbiAgICB1cGRhdGVGcmVxdWVuY3koZSkge1xuICAgICAgICB0aGlzLmZyZXFYICs9IGUsIHRoaXMuZnJlcVkgKz0gZVxuICAgIH1cbiAgICB0b2dnbGVDb2xvcihpbmRleCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUNvbG9yc1tpbmRleF0gPSAwID09PSB0aGlzLmFjdGl2ZUNvbG9yc1tpbmRleF0gPyAxIDogMFxuICAgIH1cbiAgICBzaG93R3JhZGllbnRMZWdlbmQoKSB7XG4gICAgICAgIHRoaXMud2lkdGggPiB0aGlzLm1pbldpZHRoICYmICh0aGlzLmlzR3JhZGllbnRMZWdlbmRWaXNpYmxlID0gITAsIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChcImlzR3JhZGllbnRMZWdlbmRWaXNpYmxlXCIpKVxuICAgIH1cbiAgICBoaWRlR3JhZGllbnRMZWdlbmQoKSB7XG4gICAgICAgIHRoaXMuaXNHcmFkaWVudExlZ2VuZFZpc2libGUgPSAhMSwgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKFwiaXNHcmFkaWVudExlZ2VuZFZpc2libGVcIilcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5pbml0R3JhZGllbnRDb2xvcnMoKSwgdGhpcy5pbml0TWVzaCgpLCB0aGlzLnJlc2l6ZSgpLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5yZXNpemUpXG4gICAgfVxuICAgIC8qXG4gICAgKiBXYWl0aW5nIGZvciB0aGUgY3NzIHZhcmlhYmxlcyB0byBiZWNvbWUgYXZhaWxhYmxlLCB1c3VhbGx5IG9uIHBhZ2UgbG9hZCBiZWZvcmUgd2UgY2FuIGNvbnRpbnVlLlxuICAgICogVXNpbmcgZGVmYXVsdCBjb2xvcnMgYXNzaWduZWQgYmVsb3cgaWYgbm8gdmFyaWFibGVzIGhhdmUgYmVlbiBmb3VuZCBhZnRlciBtYXhDc3NWYXJSZXRyaWVzXG4gICAgKi9cbiAgICB3YWl0Rm9yQ3NzVmFycygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcHV0ZWRDYW52YXNTdHlsZSAmJiAtMSAhPT0gdGhpcy5jb21wdXRlZENhbnZhc1N0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLWdyYWRpZW50LWNvbG9yLTFcIikuaW5kZXhPZihcIiNcIikpIHRoaXMuaW5pdCgpLCB0aGlzLmFkZElzTG9hZGVkQ2xhc3MoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jc3NWYXJSZXRyaWVzICs9IDEsIHRoaXMuY3NzVmFyUmV0cmllcyA+IHRoaXMubWF4Q3NzVmFyUmV0cmllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlY3Rpb25Db2xvcnMgPSBbMTY3MTE2ODAsIDE2NzExNjgwLCAxNjcxMTkzNSwgNjUyODAsIDI1NV0sIHZvaWQgdGhpcy5pbml0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy53YWl0Rm9yQ3NzVmFycygpKVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgKiBJbml0aWFsaXplcyB0aGUgZm91ciBzZWN0aW9uIGNvbG9ycyBieSByZXRyaWV2aW5nIHRoZW0gZnJvbSBjc3MgdmFyaWFibGVzLlxuICAgICovXG4gICAgaW5pdEdyYWRpZW50Q29sb3JzKCkge1xuICAgICAgICB0aGlzLnNlY3Rpb25Db2xvcnMgPSBbXCItLWdyYWRpZW50LWNvbG9yLTFcIiwgXCItLWdyYWRpZW50LWNvbG9yLTJcIiwgXCItLWdyYWRpZW50LWNvbG9yLTNcIiwgXCItLWdyYWRpZW50LWNvbG9yLTRcIl0ubWFwKGNzc1Byb3BlcnR5TmFtZSA9PiB7XG4gICAgICAgICAgICBsZXQgaGV4ID0gdGhpcy5jb21wdXRlZENhbnZhc1N0eWxlLmdldFByb3BlcnR5VmFsdWUoY3NzUHJvcGVydHlOYW1lKS50cmltKCk7XG4gICAgICAgICAgICAvL0NoZWNrIGlmIHNob3J0aGFuZCBoZXggdmFsdWUgd2FzIHVzZWQgYW5kIGRvdWJsZSB0aGUgbGVuZ3RoIHNvIHRoZSBjb252ZXJzaW9uIGluIG5vcm1hbGl6ZUNvbG9yIHdpbGwgd29yay5cbiAgICAgICAgICAgIGlmICg0ID09PSBoZXgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGV4VGVtcCA9IGhleC5zdWJzdHIoMSkuc3BsaXQoXCJcIikubWFwKGhleFRlbXAgPT4gaGV4VGVtcCArIGhleFRlbXApLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgaGV4ID0gYCMke2hleFRlbXB9YFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhleCAmJiBgMHgke2hleC5zdWJzdHIoMSl9YFxuICAgICAgICB9KS5maWx0ZXIoQm9vbGVhbikubWFwKG5vcm1hbGl6ZUNvbG9yKVxuICAgIH1cbn1cblxuXG5cblxuLypcbipGaW5hbGx5IGluaXRpYWxpemluZyB0aGUgR3JhZGllbnQgY2xhc3MsIGFzc2lnbmluZyBhIGNhbnZhcyB0byBpdCBhbmQgY2FsbGluZyBHcmFkaWVudC5jb25uZWN0KCkgd2hpY2ggaW5pdGlhbGl6ZXMgZXZlcnl0aGluZyxcbiogVXNlIEdyYWRpZW50LnBhdXNlKCkgYW5kIEdyYWRpZW50LnBsYXkoKSBmb3IgY29udHJvbHMuXG4qXG4qIEhlcmUgYXJlIHNvbWUgZGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZXMgeW91IGNhbiBjaGFuZ2UgYW55dGltZTpcbiogQW1wbGl0dWRlOiAgICBHcmFkaWVudC5hbXAgPSAwXG4qIENvbG9yczogICAgICAgR3JhZGllbnQuc2VjdGlvbkNvbG9ycyAoaWYgeW91IGNoYW5nZSBjb2xvcnMsIHVzZSBub3JtYWxpemVDb2xvcigjaGV4VmFsdWUpKSBiZWZvcmUgeW91IGFzc2lnbiBpdC5cbipcbipcbiogVXNlZnVsIGZ1bmN0aW9uc1xuKiBHcmFkaWVudC50b2dnbGVDb2xvcihpbmRleClcbiogR3JhZGllbnQudXBkYXRlRnJlcXVlbmN5KGZyZXEpXG4qLyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./api/rightGradient.js\n");

/***/ }),

/***/ "./components/repos.jsx":
/*!******************************!*\
  !*** ./components/repos.jsx ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Repos; });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/router */ \"next/router\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _styles_repos_module_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../styles/repos.module.css */ \"./styles/repos.module.css\");\n/* harmony import */ var _styles_repos_module_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_styles_repos_module_css__WEBPACK_IMPORTED_MODULE_3__);\n\nvar _jsxFileName = \"/Users/guy/Development/Web/Site/components/repos.jsx\";\n\n\n\n\nfunction createData(Title, Description, Language, url) {\n  return {\n    Title,\n    Description,\n    Language,\n    url\n  };\n}\n\nfunction Repos(props) {\n  const {\n    0: arrayItems,\n    1: setArrayItems\n  } = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])([]);\n  Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(async () => {\n    await fetch('https://api.github.com/users/torbet/repos').then(response => response.json()).then(data => {\n      const items = data.map(arraySingleItem => {\n        return createData(arraySingleItem.name, arraySingleItem.description, arraySingleItem.language, arraySingleItem.html_url);\n      });\n      setArrayItems(items);\n    });\n  }, []);\n  const router = Object(next_router__WEBPACK_IMPORTED_MODULE_2__[\"useRouter\"])();\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"div\", {\n    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"ul\", {\n      children: arrayItems.map(row => /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"li\", {\n        className: _styles_repos_module_css__WEBPACK_IMPORTED_MODULE_3___default.a.row,\n        onClick: () => {\n          router.push(row.url);\n        },\n        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"h3\", {\n          className: _styles_repos_module_css__WEBPACK_IMPORTED_MODULE_3___default.a.title,\n          children: row.Title\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 34,\n          columnNumber: 29\n        }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"h4\", {\n          className: _styles_repos_module_css__WEBPACK_IMPORTED_MODULE_3___default.a.subTitle,\n          children: row.Description\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 35,\n          columnNumber: 29\n        }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"h4\", {\n          className: _styles_repos_module_css__WEBPACK_IMPORTED_MODULE_3___default.a.subTitle,\n          children: row.Language\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 36,\n          columnNumber: 29\n        }, this)]\n      }, row.Title, true, {\n        fileName: _jsxFileName,\n        lineNumber: 33,\n        columnNumber: 25\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 31,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 30,\n    columnNumber: 9\n  }, this);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3JlcG9zLmpzeD81ZWI1Il0sIm5hbWVzIjpbImNyZWF0ZURhdGEiLCJUaXRsZSIsIkRlc2NyaXB0aW9uIiwiTGFuZ3VhZ2UiLCJ1cmwiLCJSZXBvcyIsInByb3BzIiwiYXJyYXlJdGVtcyIsInNldEFycmF5SXRlbXMiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImZldGNoIiwidGhlbiIsInJlc3BvbnNlIiwianNvbiIsImRhdGEiLCJpdGVtcyIsIm1hcCIsImFycmF5U2luZ2xlSXRlbSIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsImxhbmd1YWdlIiwiaHRtbF91cmwiLCJyb3V0ZXIiLCJ1c2VSb3V0ZXIiLCJyb3ciLCJzdHlsZXMiLCJwdXNoIiwidGl0bGUiLCJzdWJUaXRsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUVBOztBQUVBLFNBQVNBLFVBQVQsQ0FBb0JDLEtBQXBCLEVBQTJCQyxXQUEzQixFQUF3Q0MsUUFBeEMsRUFBa0RDLEdBQWxELEVBQXVEO0FBQ25ELFNBQU87QUFBRUgsU0FBRjtBQUFTQyxlQUFUO0FBQXNCQyxZQUF0QjtBQUFnQ0M7QUFBaEMsR0FBUDtBQUNIOztBQUVjLFNBQVNDLEtBQVQsQ0FBZUMsS0FBZixFQUFzQjtBQUNqQyxRQUFNO0FBQUEsT0FBQ0MsVUFBRDtBQUFBLE9BQWFDO0FBQWIsTUFBOEJDLHNEQUFRLENBQUMsRUFBRCxDQUE1QztBQUNBQyx5REFBUyxDQUFDLFlBQVk7QUFDbEIsVUFBTUMsS0FBSyxDQUFDLDJDQUFELENBQUwsQ0FBbURDLElBQW5ELENBQXdEQyxRQUFRLElBQUlBLFFBQVEsQ0FBQ0MsSUFBVCxFQUFwRSxFQUNERixJQURDLENBQ0lHLElBQUksSUFBSTtBQUNWLFlBQU1DLEtBQUssR0FBR0QsSUFBSSxDQUFDRSxHQUFMLENBQVVDLGVBQUQsSUFBcUI7QUFDeEMsZUFDSWxCLFVBQVUsQ0FBQ2tCLGVBQWUsQ0FBQ0MsSUFBakIsRUFBdUJELGVBQWUsQ0FBQ0UsV0FBdkMsRUFBb0RGLGVBQWUsQ0FBQ0csUUFBcEUsRUFBOEVILGVBQWUsQ0FBQ0ksUUFBOUYsQ0FEZDtBQUdILE9BSmEsQ0FBZDtBQUtBZCxtQkFBYSxDQUFDUSxLQUFELENBQWI7QUFDSCxLQVJDLENBQU47QUFVSCxHQVhRLEVBV04sRUFYTSxDQUFUO0FBYUEsUUFBTU8sTUFBTSxHQUFHQyw2REFBUyxFQUF4QjtBQUlBLHNCQUNJO0FBQUEsMkJBQ0k7QUFBQSxnQkFDS2pCLFVBQVUsQ0FBQ1UsR0FBWCxDQUFnQlEsR0FBRCxpQkFDUjtBQUFJLGlCQUFTLEVBQUVDLCtEQUFNLENBQUNELEdBQXRCO0FBQTJCLGVBQU8sRUFBRSxNQUFNO0FBQUVGLGdCQUFNLENBQUNJLElBQVAsQ0FBWUYsR0FBRyxDQUFDckIsR0FBaEI7QUFBc0IsU0FBbEU7QUFBQSxnQ0FDSTtBQUFJLG1CQUFTLEVBQUVzQiwrREFBTSxDQUFDRSxLQUF0QjtBQUFBLG9CQUE4QkgsR0FBRyxDQUFDeEI7QUFBbEM7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFESixlQUVJO0FBQUksbUJBQVMsRUFBRXlCLCtEQUFNLENBQUNHLFFBQXRCO0FBQUEsb0JBQWlDSixHQUFHLENBQUN2QjtBQUFyQztBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUZKLGVBR0k7QUFBSSxtQkFBUyxFQUFFd0IsK0RBQU0sQ0FBQ0csUUFBdEI7QUFBQSxvQkFBaUNKLEdBQUcsQ0FBQ3RCO0FBQXJDO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBSEo7QUFBQSxTQUF5RXNCLEdBQUcsQ0FBQ3hCLEtBQTdFO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FEUDtBQURMO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFESjtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBREo7QUFnQkgiLCJmaWxlIjoiLi9jb21wb25lbnRzL3JlcG9zLmpzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvcm91dGVyJ1xuXG5pbXBvcnQgc3R5bGVzIGZyb20gJy4uL3N0eWxlcy9yZXBvcy5tb2R1bGUuY3NzJ1xuXG5mdW5jdGlvbiBjcmVhdGVEYXRhKFRpdGxlLCBEZXNjcmlwdGlvbiwgTGFuZ3VhZ2UsIHVybCkge1xuICAgIHJldHVybiB7IFRpdGxlLCBEZXNjcmlwdGlvbiwgTGFuZ3VhZ2UsIHVybCB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSZXBvcyhwcm9wcykge1xuICAgIGNvbnN0IFthcnJheUl0ZW1zLCBzZXRBcnJheUl0ZW1zXSA9IHVzZVN0YXRlKFtdKVxuICAgIHVzZUVmZmVjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGZldGNoKCdodHRwczovL2FwaS5naXRodWIuY29tL3VzZXJzL3RvcmJldC9yZXBvcycpLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBkYXRhLm1hcCgoYXJyYXlTaW5nbGVJdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVEYXRhKGFycmF5U2luZ2xlSXRlbS5uYW1lLCBhcnJheVNpbmdsZUl0ZW0uZGVzY3JpcHRpb24sIGFycmF5U2luZ2xlSXRlbS5sYW5ndWFnZSwgYXJyYXlTaW5nbGVJdGVtLmh0bWxfdXJsKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNldEFycmF5SXRlbXMoaXRlbXMpO1xuICAgICAgICAgICAgfSlcblxuICAgIH0sIFtdKVxuXG4gICAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKClcblxuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIHthcnJheUl0ZW1zLm1hcCgocm93KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPXtzdHlsZXMucm93fSBvbkNsaWNrPXsoKSA9PiB7IHJvdXRlci5wdXNoKHJvdy51cmwpIH19IGtleT17cm93LlRpdGxlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPXtzdHlsZXMudGl0bGV9Pntyb3cuVGl0bGV9PC9oMz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3NOYW1lPXtzdHlsZXMuc3ViVGl0bGV9Pntyb3cuRGVzY3JpcHRpb259PC9oND5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3NOYW1lPXtzdHlsZXMuc3ViVGl0bGV9Pntyb3cuTGFuZ3VhZ2V9PC9oND5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICA8L3VsPlxuXG5cbiAgICAgICAgPC9kaXY+XG5cbiAgICApO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/repos.jsx\n");

/***/ }),

/***/ "./layouts/default.jsx":
/*!*****************************!*\
  !*** ./layouts/default.jsx ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Default; });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../styles/default.module.css */ \"./styles/default.module.css\");\n/* harmony import */ var _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_styles_default_module_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/head */ \"next/head\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _api_gradient__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../api/gradient */ \"./api/gradient.js\");\n/* harmony import */ var _api_rightGradient__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../api/rightGradient */ \"./api/rightGradient.js\");\n/* harmony import */ var react_icons_fa__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-icons/fa */ \"react-icons/fa\");\n/* harmony import */ var react_icons_fa__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react_icons_fa__WEBPACK_IMPORTED_MODULE_7__);\n\nvar _jsxFileName = \"/Users/guy/Development/Web/Site/layouts/default.jsx\";\n\n\n\n\n\n\n\nfunction Default(props) {\n  Object(react__WEBPACK_IMPORTED_MODULE_4__[\"useEffect\"])(() => {\n    var leftGrad = new _api_gradient__WEBPACK_IMPORTED_MODULE_5__[\"Gradient\"]();\n    leftGrad.initGradient(\"#default_leftGrad__3GcSF\");\n    var rightGrad = new _api_rightGradient__WEBPACK_IMPORTED_MODULE_6__[\"RightGradient\"]();\n    rightGrad.initGradient(\"#default_rightGrad__2dqIv\");\n  });\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"main\", {\n    id: _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default.a.main,\n    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"section\", {\n      id: _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default.a.left,\n      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"canvas\", {\n        id: _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default.a.leftGrad\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 27,\n        columnNumber: 17\n      }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"div\", {\n        id: _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default.a.about,\n        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"h1\", {\n          id: _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default.a.title,\n          children: \"GUY TORBET.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 30,\n          columnNumber: 21\n        }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"p\", {\n          className: _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default.a.subHeading,\n          children: \"I'm a 17 year old Software Developer and Student from Scotland.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 31,\n          columnNumber: 21\n        }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"p\", {\n          className: _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default.a.subHeading,\n          children: \"I read a lot online, and make a lot of projects; here I document and summarise the key ideas and insights from my experiences, and hopefully provide some value to you.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 32,\n          columnNumber: 21\n        }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"p\", {\n          className: _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default.a.subHeading,\n          children: [\"I also have an email newsletter, it's a 2-5 minute read every week of high quality tech and productivity content. There's also a \", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"a\", {\n            href: \"/feed\",\n            className: \"navItem\",\n            children: \"RSS feed\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 33,\n            columnNumber: 183\n          }, this), \" if you're into that.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 33,\n          columnNumber: 21\n        }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"div\", {\n          id: _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default.a.links,\n          children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {\n            href: \"https://github.com/torbet\",\n            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_icons_fa__WEBPACK_IMPORTED_MODULE_7__[\"FaGithub\"], {\n              className: _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default.a.icon\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 35,\n              columnNumber: 64\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 35,\n            columnNumber: 25\n          }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {\n            href: \"https://twitter.com/\",\n            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_icons_fa__WEBPACK_IMPORTED_MODULE_7__[\"FaTwitter\"], {\n              className: _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default.a.icon\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 36,\n              columnNumber: 59\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 36,\n            columnNumber: 25\n          }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {\n            href: \"https://instagram.com/guytorbet\",\n            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_icons_fa__WEBPACK_IMPORTED_MODULE_7__[\"FaInstagram\"], {\n              className: _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default.a.icon\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 37,\n              columnNumber: 70\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 37,\n            columnNumber: 25\n          }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {\n            href: \"mailto:guy@torbet.co\",\n            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_icons_fa__WEBPACK_IMPORTED_MODULE_7__[\"FaInbox\"], {\n              className: _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default.a.icon\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 38,\n              columnNumber: 59\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 38,\n            columnNumber: 25\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 34,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 29,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 26,\n      columnNumber: 13\n    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"section\", {\n      id: _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default.a.right,\n      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"nav\", {\n        id: _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default.a.nav,\n        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"canvas\", {\n          id: _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default.a.rightGrad\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 48,\n          columnNumber: 21\n        }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"div\", {\n          id: _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default.a.navLinks,\n          children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {\n            href: \"/\",\n            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"a\", {\n              className: _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default.a.navItem,\n              children: \"Posts\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 50,\n              columnNumber: 40\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 50,\n            columnNumber: 25\n          }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {\n            href: \"/projects\",\n            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"a\", {\n              className: _styles_default_module_css__WEBPACK_IMPORTED_MODULE_1___default.a.navItem,\n              children: \"Projects\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 51,\n              columnNumber: 48\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 51,\n            columnNumber: 25\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 49,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 47,\n        columnNumber: 17\n      }, this), props.children]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 46,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 24,\n    columnNumber: 9\n  }, this);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9sYXlvdXRzL2RlZmF1bHQuanN4P2YzM2EiXSwibmFtZXMiOlsiRGVmYXVsdCIsInByb3BzIiwidXNlRWZmZWN0IiwibGVmdEdyYWQiLCJHcmFkaWVudCIsImluaXRHcmFkaWVudCIsInJpZ2h0R3JhZCIsIlJpZ2h0R3JhZGllbnQiLCJzdHlsZXMiLCJtYWluIiwibGVmdCIsImFib3V0IiwidGl0bGUiLCJzdWJIZWFkaW5nIiwibGlua3MiLCJpY29uIiwicmlnaHQiLCJuYXYiLCJuYXZMaW5rcyIsIm5hdkl0ZW0iLCJjaGlsZHJlbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFFZSxTQUFTQSxPQUFULENBQWlCQyxLQUFqQixFQUF3QjtBQUVuQ0MseURBQVMsQ0FBQyxNQUFNO0FBQ1osUUFBSUMsUUFBUSxHQUFHLElBQUlDLHNEQUFKLEVBQWY7QUFDQUQsWUFBUSxDQUFDRSxZQUFULENBQXNCLDBCQUF0QjtBQUVBLFFBQUlDLFNBQVMsR0FBRyxJQUFJQyxnRUFBSixFQUFoQjtBQUNBRCxhQUFTLENBQUNELFlBQVYsQ0FBdUIsMkJBQXZCO0FBQ0gsR0FOUSxDQUFUO0FBUUEsc0JBQ0k7QUFBTSxNQUFFLEVBQUVHLGlFQUFNLENBQUNDLElBQWpCO0FBQUEsNEJBRUk7QUFBUyxRQUFFLEVBQUVELGlFQUFNLENBQUNFLElBQXBCO0FBQUEsOEJBQ0k7QUFBUSxVQUFFLEVBQUVGLGlFQUFNLENBQUNMO0FBQW5CO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FESixlQUdJO0FBQUssVUFBRSxFQUFFSyxpRUFBTSxDQUFDRyxLQUFoQjtBQUFBLGdDQUNJO0FBQUksWUFBRSxFQUFFSCxpRUFBTSxDQUFDSSxLQUFmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQURKLGVBRUk7QUFBRyxtQkFBUyxFQUFFSixpRUFBTSxDQUFDSyxVQUFyQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFGSixlQUdJO0FBQUcsbUJBQVMsRUFBRUwsaUVBQU0sQ0FBQ0ssVUFBckI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBSEosZUFJSTtBQUFHLG1CQUFTLEVBQUVMLGlFQUFNLENBQUNLLFVBQXJCO0FBQUEsdUtBQWtLO0FBQUcsZ0JBQUksRUFBQyxPQUFSO0FBQWdCLHFCQUFTLEVBQUMsU0FBMUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0JBQWxLO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFKSixlQUtJO0FBQUssWUFBRSxFQUFFTCxpRUFBTSxDQUFDTSxLQUFoQjtBQUFBLGtDQUNJLHFFQUFDLGdEQUFEO0FBQU0sZ0JBQUksRUFBQywyQkFBWDtBQUFBLG1DQUF1QyxxRUFBQyx1REFBRDtBQUFVLHVCQUFTLEVBQUVOLGlFQUFNLENBQUNPO0FBQTVCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBdkM7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQkFESixlQUVJLHFFQUFDLGdEQUFEO0FBQU0sZ0JBQUksRUFBQyxzQkFBWDtBQUFBLG1DQUFrQyxxRUFBQyx3REFBRDtBQUFXLHVCQUFTLEVBQUVQLGlFQUFNLENBQUNPO0FBQTdCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBbEM7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQkFGSixlQUdJLHFFQUFDLGdEQUFEO0FBQU0sZ0JBQUksRUFBQyxpQ0FBWDtBQUFBLG1DQUE2QyxxRUFBQywwREFBRDtBQUFhLHVCQUFTLEVBQUVQLGlFQUFNLENBQUNPO0FBQS9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBN0M7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQkFISixlQUlJLHFFQUFDLGdEQUFEO0FBQU0sZ0JBQUksRUFBQyxzQkFBWDtBQUFBLG1DQUFrQyxxRUFBQyxzREFBRDtBQUFTLHVCQUFTLEVBQUVQLGlFQUFNLENBQUNPO0FBQTNCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBbEM7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQkFKSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBTEo7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBSEo7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBRkosZUFzQkk7QUFBUyxRQUFFLEVBQUVQLGlFQUFNLENBQUNRLEtBQXBCO0FBQUEsOEJBQ0k7QUFBSyxVQUFFLEVBQUVSLGlFQUFNLENBQUNTLEdBQWhCO0FBQUEsZ0NBQ0k7QUFBUSxZQUFFLEVBQUVULGlFQUFNLENBQUNGO0FBQW5CO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBREosZUFFSTtBQUFLLFlBQUUsRUFBRUUsaUVBQU0sQ0FBQ1UsUUFBaEI7QUFBQSxrQ0FDSSxxRUFBQyxnREFBRDtBQUFNLGdCQUFJLEVBQUMsR0FBWDtBQUFBLG1DQUFlO0FBQUcsdUJBQVMsRUFBRVYsaUVBQU0sQ0FBQ1csT0FBckI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBZjtBQUFBO0FBQUE7QUFBQTtBQUFBLGtCQURKLGVBRUkscUVBQUMsZ0RBQUQ7QUFBTSxnQkFBSSxFQUFDLFdBQVg7QUFBQSxtQ0FBdUI7QUFBRyx1QkFBUyxFQUFFWCxpRUFBTSxDQUFDVyxPQUFyQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUF2QjtBQUFBO0FBQUE7QUFBQTtBQUFBLGtCQUZKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFGSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FESixFQVFLbEIsS0FBSyxDQUFDbUIsUUFSWDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUF0Qko7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBREo7QUFvQ0giLCJmaWxlIjoiLi9sYXlvdXRzL2RlZmF1bHQuanN4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHN0eWxlcyBmcm9tIFwiLi4vc3R5bGVzL2RlZmF1bHQubW9kdWxlLmNzc1wiXG5pbXBvcnQgTGluayBmcm9tICduZXh0L2xpbmsnXG5pbXBvcnQgSGVhZCBmcm9tICduZXh0L2hlYWQnXG5cblxuXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgR3JhZGllbnQgfSBmcm9tIFwiLi4vYXBpL2dyYWRpZW50XCJcbmltcG9ydCB7IFJpZ2h0R3JhZGllbnQgfSBmcm9tIFwiLi4vYXBpL3JpZ2h0R3JhZGllbnRcIlxuXG5pbXBvcnQgeyBGYUdpdGh1YiwgRmFUd2l0dGVyLCBGYUluc3RhZ3JhbSwgRmFJbmJveCB9IGZyb20gXCJyZWFjdC1pY29ucy9mYVwiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERlZmF1bHQocHJvcHMpIHtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZhciBsZWZ0R3JhZCA9IG5ldyBHcmFkaWVudCgpO1xuICAgICAgICBsZWZ0R3JhZC5pbml0R3JhZGllbnQoXCIjZGVmYXVsdF9sZWZ0R3JhZF9fM0djU0ZcIik7XG5cbiAgICAgICAgdmFyIHJpZ2h0R3JhZCA9IG5ldyBSaWdodEdyYWRpZW50KCk7XG4gICAgICAgIHJpZ2h0R3JhZC5pbml0R3JhZGllbnQoXCIjZGVmYXVsdF9yaWdodEdyYWRfXzJkcUl2XCIpO1xuICAgIH0pXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8bWFpbiBpZD17c3R5bGVzLm1haW59PlxuXG4gICAgICAgICAgICA8c2VjdGlvbiBpZD17c3R5bGVzLmxlZnR9PlxuICAgICAgICAgICAgICAgIDxjYW52YXMgaWQ9e3N0eWxlcy5sZWZ0R3JhZH0+PC9jYW52YXM+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IGlkPXtzdHlsZXMuYWJvdXR9PlxuICAgICAgICAgICAgICAgICAgICA8aDEgaWQ9e3N0eWxlcy50aXRsZX0+R1VZIFRPUkJFVC48L2gxPlxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9e3N0eWxlcy5zdWJIZWFkaW5nfT5JJ20gYSAxNyB5ZWFyIG9sZCBTb2Z0d2FyZSBEZXZlbG9wZXIgYW5kIFN0dWRlbnQgZnJvbSBTY290bGFuZC48L3A+XG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT17c3R5bGVzLnN1YkhlYWRpbmd9PkkgcmVhZCBhIGxvdCBvbmxpbmUsIGFuZCBtYWtlIGEgbG90IG9mIHByb2plY3RzOyBoZXJlIEkgZG9jdW1lbnQgYW5kIHN1bW1hcmlzZSB0aGUga2V5IGlkZWFzIGFuZCBpbnNpZ2h0cyBmcm9tIG15IGV4cGVyaWVuY2VzLCBhbmQgaG9wZWZ1bGx5IHByb3ZpZGUgc29tZSB2YWx1ZSB0byB5b3UuPC9wPlxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9e3N0eWxlcy5zdWJIZWFkaW5nfT5JIGFsc28gaGF2ZSBhbiBlbWFpbCBuZXdzbGV0dGVyLCBpdCdzIGEgMi01IG1pbnV0ZSByZWFkIGV2ZXJ5IHdlZWsgb2YgaGlnaCBxdWFsaXR5IHRlY2ggYW5kIHByb2R1Y3Rpdml0eSBjb250ZW50LiBUaGVyZSdzIGFsc28gYSA8YSBocmVmPVwiL2ZlZWRcIiBjbGFzc05hbWU9XCJuYXZJdGVtXCI+UlNTIGZlZWQ8L2E+IGlmIHlvdSdyZSBpbnRvIHRoYXQuPC9wPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPXtzdHlsZXMubGlua3N9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPExpbmsgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS90b3JiZXRcIj48RmFHaXRodWIgY2xhc3NOYW1lPXtzdHlsZXMuaWNvbn0gLz48L0xpbms+XG4gICAgICAgICAgICAgICAgICAgICAgICA8TGluayBocmVmPVwiaHR0cHM6Ly90d2l0dGVyLmNvbS9cIj48RmFUd2l0dGVyIGNsYXNzTmFtZT17c3R5bGVzLmljb259IC8+PC9MaW5rPlxuICAgICAgICAgICAgICAgICAgICAgICAgPExpbmsgaHJlZj1cImh0dHBzOi8vaW5zdGFncmFtLmNvbS9ndXl0b3JiZXRcIj48RmFJbnN0YWdyYW0gY2xhc3NOYW1lPXtzdHlsZXMuaWNvbn0gLz48L0xpbms+XG4gICAgICAgICAgICAgICAgICAgICAgICA8TGluayBocmVmPVwibWFpbHRvOmd1eUB0b3JiZXQuY29cIj48RmFJbmJveCBjbGFzc05hbWU9e3N0eWxlcy5pY29ufSAvPjwvTGluaz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L3NlY3Rpb24+XG5cblxuXG5cbiAgICAgICAgICAgIDxzZWN0aW9uIGlkPXtzdHlsZXMucmlnaHR9PlxuICAgICAgICAgICAgICAgIDxuYXYgaWQ9e3N0eWxlcy5uYXZ9PlxuICAgICAgICAgICAgICAgICAgICA8Y2FudmFzIGlkPXtzdHlsZXMucmlnaHRHcmFkfT48L2NhbnZhcz5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD17c3R5bGVzLm5hdkxpbmtzfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxMaW5rIGhyZWY9XCIvXCI+PGEgY2xhc3NOYW1lPXtzdHlsZXMubmF2SXRlbX0+UG9zdHM8L2E+PC9MaW5rPlxuICAgICAgICAgICAgICAgICAgICAgICAgPExpbmsgaHJlZj1cIi9wcm9qZWN0c1wiPjxhIGNsYXNzTmFtZT17c3R5bGVzLm5hdkl0ZW19PlByb2plY3RzPC9hPjwvTGluaz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9uYXY+XG4gICAgICAgICAgICAgICAge3Byb3BzLmNoaWxkcmVufVxuICAgICAgICAgICAgPC9zZWN0aW9uPlxuXG4gICAgICAgIDwvbWFpbj5cbiAgICApXG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./layouts/default.jsx\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanM/NGVhNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/interopRequireDefault.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nmodule.exports = _interopRequireWildcard;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzP2RiY2UiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLHNGQUErQjs7QUFFckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsO1xuICB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4gIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH07XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJkZWZhdWx0XCI6IG9ialxuICAgIH07XG4gIH1cblxuICB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTtcblxuICBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XG4gIH1cblxuICB2YXIgbmV3T2JqID0ge307XG4gIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsO1xuXG4gICAgICBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7XG5cbiAgaWYgKGNhY2hlKSB7XG4gICAgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTtcbiAgfVxuXG4gIHJldHVybiBuZXdPYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQ7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanM/NzAzNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/typeof.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\n\nvar _router = __webpack_require__(/*! ../next-server/lib/router/router */ \"./node_modules/next/dist/next-server/lib/router/router.js\");\n\nvar _router2 = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\n\nvar _useIntersection = __webpack_require__(/*! ./use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\n\nconst prefetched = {};\n\nfunction prefetch(router, href, as, options) {\n  if (true) return;\n  if (!(0, _router.isLocalURL)(href)) return; // Prefetch the JSON page if asked (only in the client)\n  // We need to handle a prefetch error here since we may be\n  // loading with priority which can reject but we don't\n  // want to force navigation since this is only a prefetch\n\n  router.prefetch(href, as, options).catch(err => {\n    if (true) {\n      // rethrow to show invalid URL errors\n      throw err;\n    }\n  });\n  const curLocale = options && typeof options.locale !== 'undefined' ? options.locale : router && router.locale; // Join on an invalid URI character\n\n  prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')] = true;\n}\n\nfunction isModifiedEvent(event) {\n  const {\n    target\n  } = event.currentTarget;\n  return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n  event.nativeEvent && event.nativeEvent.which === 2;\n}\n\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale) {\n  const {\n    nodeName\n  } = e.currentTarget;\n\n  if (nodeName === 'A' && (isModifiedEvent(e) || !(0, _router.isLocalURL)(href))) {\n    // ignore click for browsers default behavior\n    return;\n  }\n\n  e.preventDefault(); //  avoid scroll for urls with anchor refs\n\n  if (scroll == null) {\n    scroll = as.indexOf('#') < 0;\n  } // replace state instead of push if prop is present\n\n\n  router[replace ? 'replace' : 'push'](href, as, {\n    shallow,\n    locale,\n    scroll\n  });\n}\n\nfunction Link(props) {\n  if (true) {\n    function createPropError(args) {\n      return new Error(`Failed prop type: The prop \\`${args.key}\\` expects a ${args.expected} in \\`<Link>\\`, but got \\`${args.actual}\\` instead.` + (false ? undefined : ''));\n    } // TypeScript trick for type-guarding:\n\n\n    const requiredPropsGuard = {\n      href: true\n    };\n    const requiredProps = Object.keys(requiredPropsGuard);\n    requiredProps.forEach(key => {\n      if (key === 'href') {\n        if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {\n          throw createPropError({\n            key,\n            expected: '`string` or `object`',\n            actual: props[key] === null ? 'null' : typeof props[key]\n          });\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const _ = key;\n      }\n    }); // TypeScript trick for type-guarding:\n\n    const optionalPropsGuard = {\n      as: true,\n      replace: true,\n      scroll: true,\n      shallow: true,\n      passHref: true,\n      prefetch: true,\n      locale: true\n    };\n    const optionalProps = Object.keys(optionalPropsGuard);\n    optionalProps.forEach(key => {\n      const valType = typeof props[key];\n\n      if (key === 'as') {\n        if (props[key] && valType !== 'string' && valType !== 'object') {\n          throw createPropError({\n            key,\n            expected: '`string` or `object`',\n            actual: valType\n          });\n        }\n      } else if (key === 'locale') {\n        if (props[key] && valType !== 'string') {\n          throw createPropError({\n            key,\n            expected: '`string`',\n            actual: valType\n          });\n        }\n      } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch') {\n        if (props[key] != null && valType !== 'boolean') {\n          throw createPropError({\n            key,\n            expected: '`boolean`',\n            actual: valType\n          });\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const _ = key;\n      }\n    }); // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n\n    const hasWarned = _react.default.useRef(false);\n\n    if (props.prefetch && !hasWarned.current) {\n      hasWarned.current = true;\n      console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated');\n    }\n  }\n\n  const p = props.prefetch !== false;\n  const router = (0, _router2.useRouter)();\n  const pathname = router && router.pathname || '/';\n\n  const {\n    href,\n    as\n  } = _react.default.useMemo(() => {\n    const [resolvedHref, resolvedAs] = (0, _router.resolveHref)(pathname, props.href, true);\n    return {\n      href: resolvedHref,\n      as: props.as ? (0, _router.resolveHref)(pathname, props.as) : resolvedAs || resolvedHref\n    };\n  }, [pathname, props.href, props.as]);\n\n  let {\n    children,\n    replace,\n    shallow,\n    scroll,\n    locale\n  } = props; // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag\n\n  if (typeof children === 'string') {\n    children = /*#__PURE__*/_react.default.createElement(\"a\", null, children);\n  } // This will return the first child, if multiple are provided it will throw an error\n\n\n  const child = _react.Children.only(children);\n\n  const childRef = child && typeof child === 'object' && child.ref;\n  const [setIntersectionRef, isVisible] = (0, _useIntersection.useIntersection)({\n    rootMargin: '200px'\n  });\n\n  const setRef = _react.default.useCallback(el => {\n    setIntersectionRef(el);\n\n    if (childRef) {\n      if (typeof childRef === 'function') childRef(el);else if (typeof childRef === 'object') {\n        childRef.current = el;\n      }\n    }\n  }, [childRef, setIntersectionRef]);\n\n  (0, _react.useEffect)(() => {\n    const shouldPrefetch = isVisible && p && (0, _router.isLocalURL)(href);\n    const curLocale = typeof locale !== 'undefined' ? locale : router && router.locale;\n    const isPrefetched = prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')];\n\n    if (shouldPrefetch && !isPrefetched) {\n      prefetch(router, href, as, {\n        locale: curLocale\n      });\n    }\n  }, [as, href, isVisible, locale, p, router]);\n  const childProps = {\n    ref: setRef,\n    onClick: e => {\n      if (child.props && typeof child.props.onClick === 'function') {\n        child.props.onClick(e);\n      }\n\n      if (!e.defaultPrevented) {\n        linkClicked(e, router, href, as, replace, shallow, scroll, locale);\n      }\n    }\n  };\n\n  childProps.onMouseEnter = e => {\n    if (!(0, _router.isLocalURL)(href)) return;\n\n    if (child.props && typeof child.props.onMouseEnter === 'function') {\n      child.props.onMouseEnter(e);\n    }\n\n    prefetch(router, href, as, {\n      priority: true\n    });\n  }; // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n  // defined, we specify the current 'href', so that repetition is not needed by the user\n\n\n  if (props.passHref || child.type === 'a' && !('href' in child.props)) {\n    const curLocale = typeof locale !== 'undefined' ? locale : router && router.locale; // we only render domain locales if we are currently on a domain locale\n    // so that locale links are still visitable in development/preview envs\n\n    const localeDomain = router && router.isLocaleDomain && (0, _router.getDomainLocale)(as, curLocale, router && router.locales, router && router.domainLocales);\n    childProps.href = localeDomain || (0, _router.addBasePath)((0, _router.addLocale)(as, curLocale, router && router.defaultLocale));\n  }\n\n  return /*#__PURE__*/_react.default.cloneElement(child, childProps);\n}\n\nvar _default = Link;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L2xpbmsudHN4PzVlNGIiXSwibmFtZXMiOlsicHJlZmV0Y2hlZCIsInJvdXRlciIsImVyciIsImN1ckxvY2FsZSIsIm9wdGlvbnMiLCJocmVmIiwiZXZlbnQiLCJ0YXJnZXQiLCJlIiwibm9kZU5hbWUiLCJpc01vZGlmaWVkRXZlbnQiLCJzY3JvbGwiLCJhcyIsInJlcGxhY2UiLCJhcmdzIiwia2V5IiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJyZXF1aXJlZFByb3BzR3VhcmQiLCJyZXF1aXJlZFByb3BzIiwiT2JqZWN0IiwicHJvcHMiLCJjcmVhdGVQcm9wRXJyb3IiLCJfIiwib3B0aW9uYWxQcm9wc0d1YXJkIiwic2hhbGxvdyIsInBhc3NIcmVmIiwicHJlZmV0Y2giLCJsb2NhbGUiLCJvcHRpb25hbFByb3BzIiwidmFsVHlwZSIsImhhc1dhcm5lZCIsIlJlYWN0IiwiY29uc29sZSIsInAiLCJwYXRobmFtZSIsInJlc29sdmVkQXMiLCJjaGlsZHJlbiIsImNoaWxkIiwiQ2hpbGRyZW4iLCJjaGlsZFJlZiIsInJvb3RNYXJnaW4iLCJzZXRSZWYiLCJlbCIsInNldEludGVyc2VjdGlvblJlZiIsInNob3VsZFByZWZldGNoIiwiaXNWaXNpYmxlIiwiaXNQcmVmZXRjaGVkIiwiY2hpbGRQcm9wcyIsInJlZiIsIm9uQ2xpY2siLCJsaW5rQ2xpY2tlZCIsInByaW9yaXR5IiwibG9jYWxlRG9tYWluIiwiTGluayJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUVBOztBQVNBOztBQUNBOztBQXVCQSxNQUFNQSxVQUEyQyxHQUFqRDs7QUFFQSw2Q0FLUTtBQUNOLE1BQUksSUFBSixFQUE4QztBQUM5QyxNQUFJLENBQUMsd0JBQUwsSUFBSyxDQUFMLEVBQXVCLE9BRmpCLENBR047QUFDQTtBQUNBO0FBQ0E7O0FBQ0FDLFFBQU0sQ0FBTkEsa0NBQTBDQyxHQUFELElBQVM7QUFDaEQsY0FBMkM7QUFDekM7QUFDQTtBQUVIO0FB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QUFNLElBQ05BLE1BQU0sQ0FETkEsa0JBRUEsNENBR0VBLE1BQU0sSUFBSUEsTUFBTSxDQUhsQixTQUlFQSxNQUFNLElBQUlBLE1BQU0sQ0FQcEIsYUFHRSxDQUhGO0FBVUErQyxjQUFVLENBQVZBLE9BQ0VLLFlBQVksSUFDWix5QkFBWSxzQ0FBeUJwRCxNQUFNLElBQUlBLE1BQU0sQ0FGdkQrQyxhQUVjLENBQVosQ0FGRkE7QUFLRjs7QUFBQSxzQkFBT2hCLG1DQUFQLFVBQU9BLENBQVA7OztlQUdhc0IsSSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xpbmsuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ2hpbGRyZW4sIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHtcbiAgYWRkQmFzZVBhdGgsXG4gIGFkZExvY2FsZSxcbiAgZ2V0RG9tYWluTG9jYWxlLFxuICBpc0xvY2FsVVJMLFxuICBOZXh0Um91dGVyLFxuICBQcmVmZXRjaE9wdGlvbnMsXG4gIHJlc29sdmVIcmVmLFxufSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJy4vcm91dGVyJ1xuaW1wb3J0IHsgdXNlSW50ZXJzZWN0aW9uIH0gZnJvbSAnLi91c2UtaW50ZXJzZWN0aW9uJ1xuXG50eXBlIFVybCA9IHN0cmluZyB8IFVybE9iamVjdFxudHlwZSBSZXF1aXJlZEtleXM8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdLT86IHt9IGV4dGVuZHMgUGljazxULCBLPiA/IG5ldmVyIDogS1xufVtrZXlvZiBUXVxudHlwZSBPcHRpb25hbEtleXM8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdLT86IHt9IGV4dGVuZHMgUGljazxULCBLPiA/IEsgOiBuZXZlclxufVtrZXlvZiBUXVxuXG5leHBvcnQgdHlwZSBMaW5rUHJvcHMgPSB7XG4gIGhyZWY6IFVybFxuICBhcz86IFVybFxuICByZXBsYWNlPzogYm9vbGVhblxuICBzY3JvbGw/OiBib29sZWFuXG4gIHNoYWxsb3c/OiBib29sZWFuXG4gIHBhc3NIcmVmPzogYm9vbGVhblxuICBwcmVmZXRjaD86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2Vcbn1cbnR5cGUgTGlua1Byb3BzUmVxdWlyZWQgPSBSZXF1aXJlZEtleXM8TGlua1Byb3BzPlxudHlwZSBMaW5rUHJvcHNPcHRpb25hbCA9IE9wdGlvbmFsS2V5czxMaW5rUHJvcHM+XG5cbmNvbnN0IHByZWZldGNoZWQ6IHsgW2NhY2hlS2V5OiBzdHJpbmddOiBib29sZWFuIH0gPSB7fVxuXG5mdW5jdGlvbiBwcmVmZXRjaChcbiAgcm91dGVyOiBOZXh0Um91dGVyLFxuICBocmVmOiBzdHJpbmcsXG4gIGFzOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBQcmVmZXRjaE9wdGlvbnNcbik6IHZvaWQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXJvdXRlcikgcmV0dXJuXG4gIGlmICghaXNMb2NhbFVSTChocmVmKSkgcmV0dXJuXG4gIC8vIFByZWZldGNoIHRoZSBKU09OIHBhZ2UgaWYgYXNrZWQgKG9ubHkgaW4gdGhlIGNsaWVudClcbiAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYSBwcmVmZXRjaCBlcnJvciBoZXJlIHNpbmNlIHdlIG1heSBiZVxuICAvLyBsb2FkaW5nIHdpdGggcHJpb3JpdHkgd2hpY2ggY2FuIHJlamVjdCBidXQgd2UgZG9uJ3RcbiAgLy8gd2FudCB0byBmb3JjZSBuYXZpZ2F0aW9uIHNpbmNlIHRoaXMgaXMgb25seSBhIHByZWZldGNoXG4gIHJvdXRlci5wcmVmZXRjaChocmVmLCBhcywgb3B0aW9ucykuY2F0Y2goKGVycikgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyByZXRocm93IHRvIHNob3cgaW52YWxpZCBVUkwgZXJyb3JzXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH0pXG4gIGNvbnN0IGN1ckxvY2FsZSA9XG4gICAgb3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnXG4gICAgICA/IG9wdGlvbnMubG9jYWxlXG4gICAgICA6IHJvdXRlciAmJiByb3V0ZXIubG9jYWxlXG5cbiAgLy8gSm9pbiBvbiBhbiBpbnZhbGlkIFVSSSBjaGFyYWN0ZXJcbiAgcHJlZmV0Y2hlZFtocmVmICsgJyUnICsgYXMgKyAoY3VyTG9jYWxlID8gJyUnICsgY3VyTG9jYWxlIDogJycpXSA9IHRydWVcbn1cblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50KTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgdGFyZ2V0IH0gPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxBbmNob3JFbGVtZW50XG4gIHJldHVybiAoXG4gICAgKHRhcmdldCAmJiB0YXJnZXQgIT09ICdfc2VsZicpIHx8XG4gICAgZXZlbnQubWV0YUtleSB8fFxuICAgIGV2ZW50LmN0cmxLZXkgfHxcbiAgICBldmVudC5zaGlmdEtleSB8fFxuICAgIGV2ZW50LmFsdEtleSB8fCAvLyB0cmlnZ2VycyByZXNvdXJjZSBkb3dubG9hZFxuICAgIChldmVudC5uYXRpdmVFdmVudCAmJiBldmVudC5uYXRpdmVFdmVudC53aGljaCA9PT0gMilcbiAgKVxufVxuXG5mdW5jdGlvbiBsaW5rQ2xpY2tlZChcbiAgZTogUmVhY3QuTW91c2VFdmVudCxcbiAgcm91dGVyOiBOZXh0Um91dGVyLFxuICBocmVmOiBzdHJpbmcsXG4gIGFzOiBzdHJpbmcsXG4gIHJlcGxhY2U/OiBib29sZWFuLFxuICBzaGFsbG93PzogYm9vbGVhbixcbiAgc2Nyb2xsPzogYm9vbGVhbixcbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2Vcbik6IHZvaWQge1xuICBjb25zdCB7IG5vZGVOYW1lIH0gPSBlLmN1cnJlbnRUYXJnZXRcblxuICBpZiAobm9kZU5hbWUgPT09ICdBJyAmJiAoaXNNb2RpZmllZEV2ZW50KGUpIHx8ICFpc0xvY2FsVVJMKGhyZWYpKSkge1xuICAgIC8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxuICAgIHJldHVyblxuICB9XG5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgLy8gIGF2b2lkIHNjcm9sbCBmb3IgdXJscyB3aXRoIGFuY2hvciByZWZzXG4gIGlmIChzY3JvbGwgPT0gbnVsbCkge1xuICAgIHNjcm9sbCA9IGFzLmluZGV4T2YoJyMnKSA8IDBcbiAgfVxuXG4gIC8vIHJlcGxhY2Ugc3RhdGUgaW5zdGVhZCBvZiBwdXNoIGlmIHByb3AgaXMgcHJlc2VudFxuICByb3V0ZXJbcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdwdXNoJ10oaHJlZiwgYXMsIHtcbiAgICBzaGFsbG93LFxuICAgIGxvY2FsZSxcbiAgICBzY3JvbGwsXG4gIH0pXG59XG5cbmZ1bmN0aW9uIExpbmsocHJvcHM6IFJlYWN0LlByb3BzV2l0aENoaWxkcmVuPExpbmtQcm9wcz4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9wRXJyb3IoYXJnczoge1xuICAgICAga2V5OiBzdHJpbmdcbiAgICAgIGV4cGVjdGVkOiBzdHJpbmdcbiAgICAgIGFjdHVhbDogc3RyaW5nXG4gICAgfSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIFxcYCR7YXJncy5rZXl9XFxgIGV4cGVjdHMgYSAke2FyZ3MuZXhwZWN0ZWR9IGluIFxcYDxMaW5rPlxcYCwgYnV0IGdvdCBcXGAke2FyZ3MuYWN0dWFsfVxcYCBpbnN0ZWFkLmAgK1xuICAgICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBcIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCJcbiAgICAgICAgICAgIDogJycpXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICBjb25zdCByZXF1aXJlZFByb3BzR3VhcmQ6IFJlY29yZDxMaW5rUHJvcHNSZXF1aXJlZCwgdHJ1ZT4gPSB7XG4gICAgICBocmVmOiB0cnVlLFxuICAgIH0gYXMgY29uc3RcbiAgICBjb25zdCByZXF1aXJlZFByb3BzOiBMaW5rUHJvcHNSZXF1aXJlZFtdID0gT2JqZWN0LmtleXMoXG4gICAgICByZXF1aXJlZFByb3BzR3VhcmRcbiAgICApIGFzIExpbmtQcm9wc1JlcXVpcmVkW11cbiAgICByZXF1aXJlZFByb3BzLmZvckVhY2goKGtleTogTGlua1Byb3BzUmVxdWlyZWQpID0+IHtcbiAgICAgIGlmIChrZXkgPT09ICdocmVmJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvcHNba2V5XSA9PSBudWxsIHx8XG4gICAgICAgICAgKHR5cGVvZiBwcm9wc1trZXldICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ29iamVjdCcpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgIGFjdHVhbDogcHJvcHNba2V5XSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBwcm9wc1trZXldLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgXzogbmV2ZXIgPSBrZXlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICBjb25zdCBvcHRpb25hbFByb3BzR3VhcmQ6IFJlY29yZDxMaW5rUHJvcHNPcHRpb25hbCwgdHJ1ZT4gPSB7XG4gICAgICBhczogdHJ1ZSxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICBzY3JvbGw6IHRydWUsXG4gICAgICBzaGFsbG93OiB0cnVlLFxuICAgICAgcGFzc0hyZWY6IHRydWUsXG4gICAgICBwcmVmZXRjaDogdHJ1ZSxcbiAgICAgIGxvY2FsZTogdHJ1ZSxcbiAgICB9IGFzIGNvbnN0XG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wczogTGlua1Byb3BzT3B0aW9uYWxbXSA9IE9iamVjdC5rZXlzKFxuICAgICAgb3B0aW9uYWxQcm9wc0d1YXJkXG4gICAgKSBhcyBMaW5rUHJvcHNPcHRpb25hbFtdXG4gICAgb3B0aW9uYWxQcm9wcy5mb3JFYWNoKChrZXk6IExpbmtQcm9wc09wdGlvbmFsKSA9PiB7XG4gICAgICBjb25zdCB2YWxUeXBlID0gdHlwZW9mIHByb3BzW2tleV1cblxuICAgICAgaWYgKGtleSA9PT0gJ2FzJykge1xuICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnc3RyaW5nJyAmJiB2YWxUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2xvY2FsZScpIHtcbiAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgc3RyaW5nYCcsXG4gICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAga2V5ID09PSAncmVwbGFjZScgfHxcbiAgICAgICAga2V5ID09PSAnc2Nyb2xsJyB8fFxuICAgICAgICBrZXkgPT09ICdzaGFsbG93JyB8fFxuICAgICAgICBrZXkgPT09ICdwYXNzSHJlZicgfHxcbiAgICAgICAga2V5ID09PSAncHJlZmV0Y2gnXG4gICAgICApIHtcbiAgICAgICAgaWYgKHByb3BzW2tleV0gIT0gbnVsbCAmJiB2YWxUeXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgYm9vbGVhbmAnLFxuICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgXzogbmV2ZXIgPSBrZXlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gVGhpcyBob29rIGlzIGluIGEgY29uZGl0aW9uYWwgYnV0IHRoYXQgaXMgb2sgYmVjYXVzZSBgcHJvY2Vzcy5lbnYuTk9ERV9FTlZgIG5ldmVyIGNoYW5nZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBjb25zdCBoYXNXYXJuZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpXG4gICAgaWYgKHByb3BzLnByZWZldGNoICYmICFoYXNXYXJuZWQuY3VycmVudCkge1xuICAgICAgaGFzV2FybmVkLmN1cnJlbnQgPSB0cnVlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdOZXh0LmpzIGF1dG8tcHJlZmV0Y2hlcyBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHZpZXdwb3J0LiBUaGUgcHJlZmV0Y2ggYXR0cmlidXRlIGlzIG5vIGxvbmdlciBuZWVkZWQuIE1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3ByZWZldGNoLXRydWUtZGVwcmVjYXRlZCdcbiAgICAgIClcbiAgICB9XG4gIH1cbiAgY29uc3QgcCA9IHByb3BzLnByZWZldGNoICE9PSBmYWxzZVxuXG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpXG4gIGNvbnN0IHBhdGhuYW1lID0gKHJvdXRlciAmJiByb3V0ZXIucGF0aG5hbWUpIHx8ICcvJ1xuXG4gIGNvbnN0IHsgaHJlZiwgYXMgfSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IFtyZXNvbHZlZEhyZWYsIHJlc29sdmVkQXNdID0gcmVzb2x2ZUhyZWYocGF0aG5hbWUsIHByb3BzLmhyZWYsIHRydWUpXG4gICAgcmV0dXJuIHtcbiAgICAgIGhyZWY6IHJlc29sdmVkSHJlZixcbiAgICAgIGFzOiBwcm9wcy5hc1xuICAgICAgICA/IHJlc29sdmVIcmVmKHBhdGhuYW1lLCBwcm9wcy5hcylcbiAgICAgICAgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZixcbiAgICB9XG4gIH0sIFtwYXRobmFtZSwgcHJvcHMuaHJlZiwgcHJvcHMuYXNdKVxuXG4gIGxldCB7IGNoaWxkcmVuLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSB9ID0gcHJvcHNcblxuICAvLyBEZXByZWNhdGVkLiBXYXJuaW5nIHNob3duIGJ5IHByb3BUeXBlIGNoZWNrLiBJZiB0aGUgY2hpbGRyZW4gcHJvdmlkZWQgaXMgYSBzdHJpbmcgKDxMaW5rPmV4YW1wbGU8L0xpbms+KSB3ZSB3cmFwIGl0IGluIGFuIDxhPiB0YWdcbiAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycpIHtcbiAgICBjaGlsZHJlbiA9IDxhPntjaGlsZHJlbn08L2E+XG4gIH1cblxuICAvLyBUaGlzIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBjaGlsZCwgaWYgbXVsdGlwbGUgYXJlIHByb3ZpZGVkIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgY29uc3QgY2hpbGQ6IGFueSA9IENoaWxkcmVuLm9ubHkoY2hpbGRyZW4pXG4gIGNvbnN0IGNoaWxkUmVmOiBhbnkgPSBjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmIGNoaWxkLnJlZlxuXG4gIGNvbnN0IFtzZXRJbnRlcnNlY3Rpb25SZWYsIGlzVmlzaWJsZV0gPSB1c2VJbnRlcnNlY3Rpb24oe1xuICAgIHJvb3RNYXJnaW46ICcyMDBweCcsXG4gIH0pXG4gIGNvbnN0IHNldFJlZiA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChlbDogRWxlbWVudCkgPT4ge1xuICAgICAgc2V0SW50ZXJzZWN0aW9uUmVmKGVsKVxuICAgICAgaWYgKGNoaWxkUmVmKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGRSZWYgPT09ICdmdW5jdGlvbicpIGNoaWxkUmVmKGVsKVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGRSZWYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgY2hpbGRSZWYuY3VycmVudCA9IGVsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFtjaGlsZFJlZiwgc2V0SW50ZXJzZWN0aW9uUmVmXVxuICApXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc2hvdWxkUHJlZmV0Y2ggPSBpc1Zpc2libGUgJiYgcCAmJiBpc0xvY2FsVVJMKGhyZWYpXG4gICAgY29uc3QgY3VyTG9jYWxlID1cbiAgICAgIHR5cGVvZiBsb2NhbGUgIT09ICd1bmRlZmluZWQnID8gbG9jYWxlIDogcm91dGVyICYmIHJvdXRlci5sb2NhbGVcbiAgICBjb25zdCBpc1ByZWZldGNoZWQgPVxuICAgICAgcHJlZmV0Y2hlZFtocmVmICsgJyUnICsgYXMgKyAoY3VyTG9jYWxlID8gJyUnICsgY3VyTG9jYWxlIDogJycpXVxuICAgIGlmIChzaG91bGRQcmVmZXRjaCAmJiAhaXNQcmVmZXRjaGVkKSB7XG4gICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgIGxvY2FsZTogY3VyTG9jYWxlLFxuICAgICAgfSlcbiAgICB9XG4gIH0sIFthcywgaHJlZiwgaXNWaXNpYmxlLCBsb2NhbGUsIHAsIHJvdXRlcl0pXG5cbiAgY29uc3QgY2hpbGRQcm9wczoge1xuICAgIG9uTW91c2VFbnRlcj86IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyXG4gICAgb25DbGljazogUmVhY3QuTW91c2VFdmVudEhhbmRsZXJcbiAgICBocmVmPzogc3RyaW5nXG4gICAgcmVmPzogYW55XG4gIH0gPSB7XG4gICAgcmVmOiBzZXRSZWYsXG4gICAgb25DbGljazogKGU6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcbiAgICAgIGlmIChjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjaGlsZC5wcm9wcy5vbkNsaWNrKGUpXG4gICAgICB9XG4gICAgICBpZiAoIWUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICBsaW5rQ2xpY2tlZChlLCByb3V0ZXIsIGhyZWYsIGFzLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSlcbiAgICAgIH1cbiAgICB9LFxuICB9XG5cbiAgY2hpbGRQcm9wcy5vbk1vdXNlRW50ZXIgPSAoZTogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xuICAgIGlmICghaXNMb2NhbFVSTChocmVmKSkgcmV0dXJuXG4gICAgaWYgKGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlcihlKVxuICAgIH1cbiAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7IHByaW9yaXR5OiB0cnVlIH0pXG4gIH1cblxuICAvLyBJZiBjaGlsZCBpcyBhbiA8YT4gdGFnIGFuZCBkb2Vzbid0IGhhdmUgYSBocmVmIGF0dHJpYnV0ZSwgb3IgaWYgdGhlICdwYXNzSHJlZicgcHJvcGVydHkgaXNcbiAgLy8gZGVmaW5lZCwgd2Ugc3BlY2lmeSB0aGUgY3VycmVudCAnaHJlZicsIHNvIHRoYXQgcmVwZXRpdGlvbiBpcyBub3QgbmVlZGVkIGJ5IHRoZSB1c2VyXG4gIGlmIChwcm9wcy5wYXNzSHJlZiB8fCAoY2hpbGQudHlwZSA9PT0gJ2EnICYmICEoJ2hyZWYnIGluIGNoaWxkLnByb3BzKSkpIHtcbiAgICBjb25zdCBjdXJMb2NhbGUgPVxuICAgICAgdHlwZW9mIGxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBsb2NhbGUgOiByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZVxuXG4gICAgLy8gd2Ugb25seSByZW5kZXIgZG9tYWluIGxvY2FsZXMgaWYgd2UgYXJlIGN1cnJlbnRseSBvbiBhIGRvbWFpbiBsb2NhbGVcbiAgICAvLyBzbyB0aGF0IGxvY2FsZSBsaW5rcyBhcmUgc3RpbGwgdmlzaXRhYmxlIGluIGRldmVsb3BtZW50L3ByZXZpZXcgZW52c1xuICAgIGNvbnN0IGxvY2FsZURvbWFpbiA9XG4gICAgICByb3V0ZXIgJiZcbiAgICAgIHJvdXRlci5pc0xvY2FsZURvbWFpbiAmJlxuICAgICAgZ2V0RG9tYWluTG9jYWxlKFxuICAgICAgICBhcyxcbiAgICAgICAgY3VyTG9jYWxlLFxuICAgICAgICByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZXMsXG4gICAgICAgIHJvdXRlciAmJiByb3V0ZXIuZG9tYWluTG9jYWxlc1xuICAgICAgKVxuXG4gICAgY2hpbGRQcm9wcy5ocmVmID1cbiAgICAgIGxvY2FsZURvbWFpbiB8fFxuICAgICAgYWRkQmFzZVBhdGgoYWRkTG9jYWxlKGFzLCBjdXJMb2NhbGUsIHJvdXRlciAmJiByb3V0ZXIuZGVmYXVsdExvY2FsZSkpXG4gIH1cblxuICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaW5rXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/link.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/normalize-trailing-slash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.removePathTrailingSlash = removePathTrailingSlash;\nexports.normalizePathTrailingSlash = void 0;\n/**\n* Removes the trailing slash of a path if there is one. Preserves the root path `/`.\n*/\n\nfunction removePathTrailingSlash(path) {\n  return path.endsWith('/') && path !== '/' ? path.slice(0, -1) : path;\n}\n/**\n* Normalizes the trailing slash of a path according to the `trailingSlash` option\n* in `next.config.js`.\n*/\n\n\nconst normalizePathTrailingSlash =  false ? undefined : removePathTrailingSlash;\nexports.normalizePathTrailingSlash = normalizePathTrailingSlash;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaC50cz82MzIzIl0sIm5hbWVzIjpbInBhdGgiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsInByb2Nlc3MiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUNPLHVDQUF1RDtBQUM1RCxTQUFPQSxJQUFJLENBQUpBLGlCQUFzQkEsSUFBSSxLQUExQkEsTUFBcUNBLElBQUksQ0FBSkEsU0FBYyxDQUFuREEsQ0FBcUNBLENBQXJDQSxHQUFQO0FBR0Y7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sTUFBTUMsMEJBQTBCLEdBQUdDLFNBQ3JDRixTQURxQ0UsR0FBbkMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2guanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJlbW92ZXMgdGhlIHRyYWlsaW5nIHNsYXNoIG9mIGEgcGF0aCBpZiB0aGVyZSBpcyBvbmUuIFByZXNlcnZlcyB0aGUgcm9vdCBwYXRoIGAvYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBwYXRoLmVuZHNXaXRoKCcvJykgJiYgcGF0aCAhPT0gJy8nID8gcGF0aC5zbGljZSgwLCAtMSkgOiBwYXRoXG59XG5cbi8qKlxuICogTm9ybWFsaXplcyB0aGUgdHJhaWxpbmcgc2xhc2ggb2YgYSBwYXRoIGFjY29yZGluZyB0byB0aGUgYHRyYWlsaW5nU2xhc2hgIG9wdGlvblxuICogaW4gYG5leHQuY29uZmlnLmpzYC5cbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1RSQUlMSU5HX1NMQVNIXG4gID8gKHBhdGg6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICBpZiAoL1xcLlteL10rXFwvPyQvLnRlc3QocGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGgpXG4gICAgICB9IGVsc2UgaWYgKHBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICByZXR1cm4gcGF0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhdGggKyAnLydcbiAgICAgIH1cbiAgICB9XG4gIDogcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2hcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/normalize-trailing-slash.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.cancelIdleCallback = exports.requestIdleCallback = void 0;\n\nconst requestIdleCallback = typeof self !== 'undefined' && self.requestIdleCallback || function (cb) {\n  let start = Date.now();\n  return setTimeout(function () {\n    cb({\n      didTimeout: false,\n      timeRemaining: function () {\n        return Math.max(0, 50 - (Date.now() - start));\n      }\n    });\n  }, 1);\n};\n\nexports.requestIdleCallback = requestIdleCallback;\n\nconst cancelIdleCallback = typeof self !== 'undefined' && self.cancelIdleCallback || function (id) {\n  return clearTimeout(id);\n};\n\nexports.cancelIdleCallback = cancelIdleCallback;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay50cz9mZjllIl0sIm5hbWVzIjpbInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJzZWxmIiwic3RhcnQiLCJEYXRlIiwic2V0VGltZW91dCIsImNiIiwiZGlkVGltZW91dCIsInRpbWVSZW1haW5pbmciLCJNYXRoIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwiY2xlYXJUaW1lb3V0Il0sIm1hcHBpbmdzIjoiOzs7OztBQW1CTyxNQUFNQSxtQkFBbUIsR0FDN0IsK0JBQStCQyxJQUFJLENBQXBDLG1CQUFDLElBQ0QsY0FFa0I7QUFDaEIsTUFBSUMsS0FBSyxHQUFHQyxJQUFJLENBQWhCLEdBQVlBLEVBQVo7QUFDQSxTQUFPQyxVQUFVLENBQUMsWUFBWTtBQUM1QkMsTUFBRSxDQUFDO0FBQ0RDLGdCQUFVLEVBRFQ7QUFFREMsbUJBQWEsRUFBRSxZQUFZO0FBQ3pCLGVBQU9DLElBQUksQ0FBSkEsT0FBWSxNQUFNTCxJQUFJLENBQUpBLFFBQXpCLEtBQW1CLENBQVpLLENBQVA7QUFISkg7QUFBRyxLQUFELENBQUZBO0FBRGUsS0FBakIsQ0FBaUIsQ0FBakI7QUFORzs7OztBQWdCQSxNQUFNSSxrQkFBa0IsR0FDNUIsK0JBQStCUixJQUFJLENBQXBDLGtCQUFDLElBQ0QsY0FBeUM7QUFDdkMsU0FBT1MsWUFBWSxDQUFuQixFQUFtQixDQUFuQjtBQUhHIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvcmVxdWVzdC1pZGxlLWNhbGxiYWNrLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidHlwZSBSZXF1ZXN0SWRsZUNhbGxiYWNrSGFuZGxlID0gYW55XG50eXBlIFJlcXVlc3RJZGxlQ2FsbGJhY2tPcHRpb25zID0ge1xuICB0aW1lb3V0OiBudW1iZXJcbn1cbnR5cGUgUmVxdWVzdElkbGVDYWxsYmFja0RlYWRsaW5lID0ge1xuICByZWFkb25seSBkaWRUaW1lb3V0OiBib29sZWFuXG4gIHRpbWVSZW1haW5pbmc6ICgpID0+IG51bWJlclxufVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2s6IChcbiAgICAgIGNhbGxiYWNrOiAoZGVhZGxpbmU6IFJlcXVlc3RJZGxlQ2FsbGJhY2tEZWFkbGluZSkgPT4gdm9pZCxcbiAgICAgIG9wdHM/OiBSZXF1ZXN0SWRsZUNhbGxiYWNrT3B0aW9uc1xuICAgICkgPT4gUmVxdWVzdElkbGVDYWxsYmFja0hhbmRsZVxuICAgIGNhbmNlbElkbGVDYWxsYmFjazogKGlkOiBSZXF1ZXN0SWRsZUNhbGxiYWNrSGFuZGxlKSA9PiB2b2lkXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgPVxuICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYucmVxdWVzdElkbGVDYWxsYmFjaykgfHxcbiAgZnVuY3Rpb24gKFxuICAgIGNiOiAoZGVhZGxpbmU6IFJlcXVlc3RJZGxlQ2FsbGJhY2tEZWFkbGluZSkgPT4gdm9pZFxuICApOiBOb2RlSlMuVGltZW91dCB7XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKHtcbiAgICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgNTAgLSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSlcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSwgMSlcbiAgfVxuXG5leHBvcnQgY29uc3QgY2FuY2VsSWRsZUNhbGxiYWNrID1cbiAgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLmNhbmNlbElkbGVDYWxsYmFjaykgfHxcbiAgZnVuY3Rpb24gKGlkOiBSZXF1ZXN0SWRsZUNhbGxiYWNrSGFuZGxlKSB7XG4gICAgcmV0dXJuIGNsZWFyVGltZW91dChpZClcbiAgfVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/request-idle-callback.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/route-loader.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/route-loader.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nexports.__esModule = true;\nexports.markAssetError = markAssetError;\nexports.isAssetError = isAssetError;\nexports.getClientBuildManifest = getClientBuildManifest;\nexports.default = void 0;\n\nvar _getAssetPathFromRoute = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/router/utils/get-asset-path-from-route */ \"../next-server/lib/router/utils/get-asset-path-from-route\"));\n\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\"); // 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\n\n\nconst MS_MAX_IDLE_DELAY = 3800;\n\nfunction withFuture(key, map, generator) {\n  let entry = map.get(key);\n\n  if (entry) {\n    if ('future' in entry) {\n      return entry.future;\n    }\n\n    return Promise.resolve(entry);\n  }\n\n  let resolver;\n  const prom = new Promise(resolve => {\n    resolver = resolve;\n  });\n  map.set(key, entry = {\n    resolve: resolver,\n    future: prom\n  });\n  return generator ? // eslint-disable-next-line no-sequences\n  generator().then(value => (resolver(value), value)) : prom;\n}\n\nfunction hasPrefetch(link) {\n  try {\n    link = document.createElement('link');\n    return (// detect IE11 since it supports prefetch but isn't detected\n      // with relList.support\n      !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports('prefetch')\n    );\n  } catch (_unused) {\n    return false;\n  }\n}\n\nconst canPrefetch = hasPrefetch();\n\nfunction prefetchViaDom(href, as, link) {\n  return new Promise((res, rej) => {\n    if (document.querySelector(`link[rel=\"prefetch\"][href^=\"${href}\"]`)) {\n      return res();\n    }\n\n    link = document.createElement('link'); // The order of property assignment here is intentional:\n\n    if (as) link.as = as;\n    link.rel = `prefetch`;\n    link.crossOrigin = undefined;\n    link.onload = res;\n    link.onerror = rej; // `href` should always be last:\n\n    link.href = href;\n    document.head.appendChild(link);\n  });\n}\n\nconst ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR'); // TODO: unexport\n\nfunction markAssetError(err) {\n  return Object.defineProperty(err, ASSET_LOAD_ERROR, {});\n}\n\nfunction isAssetError(err) {\n  return err && ASSET_LOAD_ERROR in err;\n}\n\nfunction appendScript(src, script) {\n  return new Promise((resolve, reject) => {\n    script = document.createElement('script'); // The order of property assignment here is intentional.\n    // 1. Setup success/failure hooks in case the browser synchronously\n    //    executes when `src` is set.\n\n    script.onload = resolve;\n\n    script.onerror = () => reject(markAssetError(new Error(`Failed to load script: ${src}`))); // 2. Configure the cross-origin attribute before setting `src` in case the\n    //    browser begins to fetch.\n\n\n    script.crossOrigin = undefined; // 3. Finally, set the source and inject into the DOM in case the child\n    //    must be appended for fetching to start.\n\n    script.src = src;\n    document.body.appendChild(script);\n  });\n} // Resolve a promise that times out after given amount of milliseconds.\n\n\nfunction resolvePromiseWithTimeout(p, ms, err) {\n  return new Promise((resolve, reject) => {\n    let cancelled = false;\n    p.then(r => {\n      // Resolved, cancel the timeout\n      cancelled = true;\n      resolve(r);\n    }).catch(reject);\n    (0, _requestIdleCallback.requestIdleCallback)(() => setTimeout(() => {\n      if (!cancelled) {\n        reject(err);\n      }\n    }, ms));\n  });\n} // TODO: stop exporting or cache the failure\n// It'd be best to stop exporting this. It's an implementation detail. We're\n// only exporting it for backwards compatibilty with the `page-loader`.\n// Only cache this response as a last resort if we cannot eliminate all other\n// code branches that use the Build Manifest Callback and push them through\n// the Route Loader interface.\n\n\nfunction getClientBuildManifest() {\n  if (self.__BUILD_MANIFEST) {\n    return Promise.resolve(self.__BUILD_MANIFEST);\n  }\n\n  const onBuildManifest = new Promise(resolve => {\n    // Mandatory because this is not concurrent safe:\n    const cb = self.__BUILD_MANIFEST_CB;\n\n    self.__BUILD_MANIFEST_CB = () => {\n      resolve(self.__BUILD_MANIFEST);\n      cb && cb();\n    };\n  });\n  return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));\n}\n\nfunction getFilesForRoute(assetPrefix, route) {\n  if (true) {\n    return Promise.resolve({\n      scripts: [assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute.default)(route, '.js'))],\n      // Styles are handled by `style-loader` in development:\n      css: []\n    });\n  }\n\n  return getClientBuildManifest().then(manifest => {\n    if (!(route in manifest)) {\n      throw markAssetError(new Error(`Failed to lookup route: ${route}`));\n    }\n\n    const allFiles = manifest[route].map(entry => assetPrefix + '/_next/' + encodeURI(entry));\n    return {\n      scripts: allFiles.filter(v => v.endsWith('.js')),\n      css: allFiles.filter(v => v.endsWith('.css'))\n    };\n  });\n}\n\nfunction createRouteLoader(assetPrefix) {\n  const entrypoints = new Map();\n  const loadedScripts = new Map();\n  const styleSheets = new Map();\n  const routes = new Map();\n\n  function maybeExecuteScript(src) {\n    let prom = loadedScripts.get(src);\n\n    if (prom) {\n      return prom;\n    } // Skip executing script if it's already in the DOM:\n\n\n    if (document.querySelector(`script[src^=\"${src}\"]`)) {\n      return Promise.resolve();\n    }\n\n    loadedScripts.set(src, prom = appendScript(src));\n    return prom;\n  }\n\n  function fetchStyleSheet(href) {\n    let prom = styleSheets.get(href);\n\n    if (prom) {\n      return prom;\n    }\n\n    styleSheets.set(href, prom = fetch(href).then(res => {\n      if (!res.ok) {\n        throw new Error(`Failed to load stylesheet: ${href}`);\n      }\n\n      return res.text().then(text => ({\n        href: href,\n        content: text\n      }));\n    }).catch(err => {\n      throw markAssetError(err);\n    }));\n    return prom;\n  }\n\n  return {\n    whenEntrypoint(route) {\n      return withFuture(route, entrypoints);\n    },\n\n    onEntrypoint(route, execute) {\n      Promise.resolve(execute).then(fn => fn()).then(exports => ({\n        component: exports && exports.default || exports,\n        exports: exports\n      }), err => ({\n        error: err\n      })).then(input => {\n        const old = entrypoints.get(route);\n        entrypoints.set(route, input);\n        if (old && 'resolve' in old) old.resolve(input);\n      });\n    },\n\n    loadRoute(route) {\n      return withFuture(route, routes, async () => {\n        try {\n          const {\n            scripts,\n            css\n          } = await getFilesForRoute(assetPrefix, route);\n          const [, styles] = await Promise.all([entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)), Promise.all(css.map(fetchStyleSheet))]);\n          const entrypoint = await resolvePromiseWithTimeout(this.whenEntrypoint(route), MS_MAX_IDLE_DELAY, markAssetError(new Error(`Route did not complete loading: ${route}`)));\n          const res = Object.assign({\n            styles\n          }, entrypoint);\n          return 'error' in entrypoint ? entrypoint : res;\n        } catch (err) {\n          return {\n            error: err\n          };\n        }\n      });\n    },\n\n    prefetch(route) {\n      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n      // License: Apache 2.0\n      let cn;\n\n      if (cn = navigator.connection) {\n        // Don't prefetch if using 2G or if Save-Data is enabled.\n        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n      }\n\n      return getFilesForRoute(assetPrefix, route).then(output => Promise.all(canPrefetch ? output.scripts.map(script => prefetchViaDom(script, 'script')) : [])).then(() => {\n        (0, _requestIdleCallback.requestIdleCallback)(() => this.loadRoute(route));\n      }).catch( // swallow prefetch errors\n      () => {});\n    }\n\n  };\n}\n\nvar _default = createRouteLoader;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlci50cz84YTQ2Il0sIm5hbWVzIjpbIk1TX01BWF9JRExFX0RFTEFZIiwiZW50cnkiLCJtYXAiLCJQcm9taXNlIiwicHJvbSIsInJlc29sdmUiLCJyZXNvbHZlciIsImZ1dHVyZSIsImdlbmVyYXRvciIsInZhbHVlIiwibGluayIsImRvY3VtZW50Iiwid2luZG93IiwiY2FuUHJlZmV0Y2giLCJoYXNQcmVmZXRjaCIsImhyZWYiLCJyZXMiLCJwcm9jZXNzIiwiQVNTRVRfTE9BRF9FUlJPUiIsIlN5bWJvbCIsIk9iamVjdCIsImVyciIsInNjcmlwdCIsInJlamVjdCIsIm1hcmtBc3NldEVycm9yIiwic3JjIiwiY2FuY2VsbGVkIiwiciIsInNldFRpbWVvdXQiLCJzZWxmIiwib25CdWlsZE1hbmlmZXN0IiwiY2IiLCJyZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0Iiwic2NyaXB0cyIsImFzc2V0UHJlZml4IiwiZW5jb2RlVVJJIiwiY3NzIiwiZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCIsIm1hbmlmZXN0Iiwicm91dGUiLCJhbGxGaWxlcyIsInYiLCJlbnRyeXBvaW50cyIsImxvYWRlZFNjcmlwdHMiLCJzdHlsZVNoZWV0cyIsInJvdXRlcyIsImFwcGVuZFNjcmlwdCIsImZldGNoIiwidGV4dCIsImNvbnRlbnQiLCJ3aGVuRW50cnlwb2ludCIsIndpdGhGdXR1cmUiLCJvbkVudHJ5cG9pbnQiLCJmbiIsImV4cG9ydHMiLCJjb21wb25lbnQiLCJlcnJvciIsImlucHV0Iiwib2xkIiwibG9hZFJvdXRlIiwiZ2V0RmlsZXNGb3JSb3V0ZSIsImVudHJ5cG9pbnQiLCJwcmVmZXRjaCIsImNuIiwibmF2aWdhdG9yIiwib3V0cHV0IiwicHJlZmV0Y2hWaWFEb20iLCJjcmVhdGVSb3V0ZUxvYWRlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUVBOztBQUNBLDBJLENBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNB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Sm1DLENBQVpBLENBQXpCO0FBT0EsZ0JBQU0wRCxVQUEyQixHQUFHLE1BQU03Qix5QkFBeUIsQ0FDakUsb0JBRGlFLEtBQ2pFLENBRGlFLHFCQUdqRVIsY0FBYyxDQUNaLFVBQVcsbUNBQWtDZSxLQUpqRCxFQUlJLENBRFksQ0FIbUQsQ0FBbkU7QUFRQSxnQkFBTXZCLEdBQXFCLEdBQUdJLE1BQU0sQ0FBTkEsT0FHNUI7QUFINEJBO0FBRzVCLFdBSDRCQSxFQUE5QixVQUE4QkEsQ0FBOUI7QUFJQSxpQkFBTyxxQ0FBUDtBQUNBLFNBdEJGLENBc0JFLFlBQVk7QUFDWixpQkFBTztBQUFFb0MsaUJBQUssRUFBZDtBQUFPLFdBQVA7QUFFSDtBQTFCRCxPQUFpQixDQUFqQjtBQXJCRzs7QUFpRExNLFlBQVEsUUFBK0I7QUFDckM7QUFDQTtBQUNBOztBQUNBLFVBQUtDLEVBQUUsR0FBSUMsU0FBRCxDQUFWLFlBQTBDO0FBQ3hDO0FBQ0EsWUFBSUQsRUFBRSxDQUFGQSxZQUFlLFVBQVVBLEVBQUUsQ0FBL0IsYUFBbUIsQ0FBbkIsRUFBZ0QsT0FBTzVELE9BQU8sQ0FBZCxPQUFPQSxFQUFQO0FBRWxEOztBQUFBLGFBQU8sZ0JBQWdCLGNBQWhCLEtBQWdCLENBQWhCLE1BQ0U4RCxNQUFELElBQ0o5RCxPQUFPLENBQVBBLElBQ0VVLFdBQVcsR0FDUG9ELE1BQU0sQ0FBTkEsWUFBb0IzQyxNQUFELElBQVk0QyxjQUFjLFNBRHRDLFFBQ3NDLENBQTdDRCxDQURPLEdBSFYsRUFFSDlELENBRkcsT0FRQyxNQUFNO0FBQ1Ysc0RBQW9CLE1BQU0sZUFBMUIsS0FBMEIsQ0FBMUI7QUFURyxnQkFZSDtBQUNBLFlBQU0sQ0FiVixDQUFPLENBQVA7QUF6REo7O0FBQU8sR0FBUDs7O2VBNEVhZ0UsaUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZS1sb2FkZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBDbGllbnRCdWlsZE1hbmlmZXN0IH0gZnJvbSAnLi4vYnVpbGQvd2VicGFjay9wbHVnaW5zL2J1aWxkLW1hbmlmZXN0LXBsdWdpbidcbmltcG9ydCBnZXRBc3NldFBhdGhGcm9tUm91dGUgZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9nZXQtYXNzZXQtcGF0aC1mcm9tLXJvdXRlJ1xuaW1wb3J0IHsgcmVxdWVzdElkbGVDYWxsYmFjayB9IGZyb20gJy4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrJ1xuXG4vLyAzLjhzIHdhcyBhcmJpdHJhcmlseSBjaG9zZW4gYXMgaXQncyB3aGF0IGh0dHBzOi8vd2ViLmRldi9pbnRlcmFjdGl2ZVxuLy8gY29uc2lkZXJzIGFzIFwiR29vZFwiIHRpbWUtdG8taW50ZXJhY3RpdmUuIFdlIG11c3QgYXNzdW1lIHNvbWV0aGluZyB3ZW50XG4vLyB3cm9uZyBiZXlvbmQgdGhpcyBwb2ludCwgYW5kIHRoZW4gZmFsbC1iYWNrIHRvIGEgZnVsbCBwYWdlIHRyYW5zaXRpb24gdG9cbi8vIHNob3cgdGhlIHVzZXIgc29tZXRoaW5nIG9mIHZhbHVlLlxuY29uc3QgTVNfTUFYX0lETEVfREVMQVkgPSAzODAwXG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgX19CVUlMRF9NQU5JRkVTVD86IENsaWVudEJ1aWxkTWFuaWZlc3RcbiAgICBfX0JVSUxEX01BTklGRVNUX0NCPzogRnVuY3Rpb25cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlZEVudHJ5cG9pbnRTdWNjZXNzIHtcbiAgY29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gIGV4cG9ydHM6IGFueVxufVxuZXhwb3J0IGludGVyZmFjZSBMb2FkZWRFbnRyeXBvaW50RmFpbHVyZSB7XG4gIGVycm9yOiB1bmtub3duXG59XG5leHBvcnQgdHlwZSBSb3V0ZUVudHJ5cG9pbnQgPSBMb2FkZWRFbnRyeXBvaW50U3VjY2VzcyB8IExvYWRlZEVudHJ5cG9pbnRGYWlsdXJlXG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVTdHlsZVNoZWV0IHtcbiAgaHJlZjogc3RyaW5nXG4gIGNvbnRlbnQ6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlZFJvdXRlU3VjY2VzcyBleHRlbmRzIExvYWRlZEVudHJ5cG9pbnRTdWNjZXNzIHtcbiAgc3R5bGVzOiBSb3V0ZVN0eWxlU2hlZXRbXVxufVxuZXhwb3J0IGludGVyZmFjZSBMb2FkZWRSb3V0ZUZhaWx1cmUge1xuICBlcnJvcjogdW5rbm93blxufVxuZXhwb3J0IHR5cGUgUm91dGVMb2FkZXJFbnRyeSA9IExvYWRlZFJvdXRlU3VjY2VzcyB8IExvYWRlZFJvdXRlRmFpbHVyZVxuXG5leHBvcnQgdHlwZSBGdXR1cmU8Vj4gPSB7XG4gIHJlc29sdmU6IChlbnRyeXBvaW50OiBWKSA9PiB2b2lkXG4gIGZ1dHVyZTogUHJvbWlzZTxWPlxufVxuZnVuY3Rpb24gd2l0aEZ1dHVyZTxUPihcbiAga2V5OiBzdHJpbmcsXG4gIG1hcDogTWFwPHN0cmluZywgRnV0dXJlPFQ+IHwgVD4sXG4gIGdlbmVyYXRvcj86ICgpID0+IFByb21pc2U8VD5cbik6IFByb21pc2U8VD4ge1xuICBsZXQgZW50cnk6IEZ1dHVyZTxUPiB8IFQgfCB1bmRlZmluZWQgPSBtYXAuZ2V0KGtleSlcbiAgaWYgKGVudHJ5KSB7XG4gICAgaWYgKCdmdXR1cmUnIGluIGVudHJ5KSB7XG4gICAgICByZXR1cm4gZW50cnkuZnV0dXJlXG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW50cnkpXG4gIH1cbiAgbGV0IHJlc29sdmVyOiAoZW50cnlwb2ludDogVCkgPT4gdm9pZFxuICBjb25zdCBwcm9tOiBQcm9taXNlPFQ+ID0gbmV3IFByb21pc2U8VD4oKHJlc29sdmUpID0+IHtcbiAgICByZXNvbHZlciA9IHJlc29sdmVcbiAgfSlcbiAgbWFwLnNldChrZXksIChlbnRyeSA9IHsgcmVzb2x2ZTogcmVzb2x2ZXIhLCBmdXR1cmU6IHByb20gfSkpXG4gIHJldHVybiBnZW5lcmF0b3JcbiAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZXF1ZW5jZXNcbiAgICAgIGdlbmVyYXRvcigpLnRoZW4oKHZhbHVlKSA9PiAocmVzb2x2ZXIodmFsdWUpLCB2YWx1ZSkpXG4gICAgOiBwcm9tXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVMb2FkZXIge1xuICB3aGVuRW50cnlwb2ludChyb3V0ZTogc3RyaW5nKTogUHJvbWlzZTxSb3V0ZUVudHJ5cG9pbnQ+XG4gIG9uRW50cnlwb2ludChyb3V0ZTogc3RyaW5nLCBleGVjdXRlOiAoKSA9PiB1bmtub3duKTogdm9pZFxuICBsb2FkUm91dGUocm91dGU6IHN0cmluZyk6IFByb21pc2U8Um91dGVMb2FkZXJFbnRyeT5cbiAgcHJlZmV0Y2gocm91dGU6IHN0cmluZyk6IFByb21pc2U8dm9pZD5cbn1cblxuZnVuY3Rpb24gaGFzUHJlZmV0Y2gobGluaz86IEhUTUxMaW5rRWxlbWVudCk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJylcbiAgICByZXR1cm4gKFxuICAgICAgLy8gZGV0ZWN0IElFMTEgc2luY2UgaXQgc3VwcG9ydHMgcHJlZmV0Y2ggYnV0IGlzbid0IGRldGVjdGVkXG4gICAgICAvLyB3aXRoIHJlbExpc3Quc3VwcG9ydFxuICAgICAgKCEhd2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0ICYmICEhKGRvY3VtZW50IGFzIGFueSkuZG9jdW1lbnRNb2RlKSB8fFxuICAgICAgbGluay5yZWxMaXN0LnN1cHBvcnRzKCdwcmVmZXRjaCcpXG4gICAgKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5jb25zdCBjYW5QcmVmZXRjaDogYm9vbGVhbiA9IGhhc1ByZWZldGNoKClcblxuZnVuY3Rpb24gcHJlZmV0Y2hWaWFEb20oXG4gIGhyZWY6IHN0cmluZyxcbiAgYXM6IHN0cmluZyxcbiAgbGluaz86IEhUTUxMaW5rRWxlbWVudFxuKTogUHJvbWlzZTxhbnk+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBsaW5rW3JlbD1cInByZWZldGNoXCJdW2hyZWZePVwiJHtocmVmfVwiXWApKSB7XG4gICAgICByZXR1cm4gcmVzKClcbiAgICB9XG5cbiAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpXG5cbiAgICAvLyBUaGUgb3JkZXIgb2YgcHJvcGVydHkgYXNzaWdubWVudCBoZXJlIGlzIGludGVudGlvbmFsOlxuICAgIGlmIChhcykgbGluayEuYXMgPSBhc1xuICAgIGxpbmshLnJlbCA9IGBwcmVmZXRjaGBcbiAgICBsaW5rIS5jcm9zc09yaWdpbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DUk9TU19PUklHSU4hXG4gICAgbGluayEub25sb2FkID0gcmVzXG4gICAgbGluayEub25lcnJvciA9IHJlalxuXG4gICAgLy8gYGhyZWZgIHNob3VsZCBhbHdheXMgYmUgbGFzdDpcbiAgICBsaW5rIS5ocmVmID0gaHJlZlxuXG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKVxuICB9KVxufVxuXG5jb25zdCBBU1NFVF9MT0FEX0VSUk9SID0gU3ltYm9sKCdBU1NFVF9MT0FEX0VSUk9SJylcbi8vIFRPRE86IHVuZXhwb3J0XG5leHBvcnQgZnVuY3Rpb24gbWFya0Fzc2V0RXJyb3IoZXJyOiBFcnJvcik6IEVycm9yIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsIEFTU0VUX0xPQURfRVJST1IsIHt9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBc3NldEVycm9yKGVycj86IEVycm9yKTogYm9vbGVhbiB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBlcnIgJiYgQVNTRVRfTE9BRF9FUlJPUiBpbiBlcnJcbn1cblxuZnVuY3Rpb24gYXBwZW5kU2NyaXB0KFxuICBzcmM6IHN0cmluZyxcbiAgc2NyaXB0PzogSFRNTFNjcmlwdEVsZW1lbnRcbik6IFByb21pc2U8dW5rbm93bj4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG5cbiAgICAvLyBUaGUgb3JkZXIgb2YgcHJvcGVydHkgYXNzaWdubWVudCBoZXJlIGlzIGludGVudGlvbmFsLlxuICAgIC8vIDEuIFNldHVwIHN1Y2Nlc3MvZmFpbHVyZSBob29rcyBpbiBjYXNlIHRoZSBicm93c2VyIHN5bmNocm9ub3VzbHlcbiAgICAvLyAgICBleGVjdXRlcyB3aGVuIGBzcmNgIGlzIHNldC5cbiAgICBzY3JpcHQub25sb2FkID0gcmVzb2x2ZVxuICAgIHNjcmlwdC5vbmVycm9yID0gKCkgPT5cbiAgICAgIHJlamVjdChtYXJrQXNzZXRFcnJvcihuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHNjcmlwdDogJHtzcmN9YCkpKVxuXG4gICAgLy8gMi4gQ29uZmlndXJlIHRoZSBjcm9zcy1vcmlnaW4gYXR0cmlidXRlIGJlZm9yZSBzZXR0aW5nIGBzcmNgIGluIGNhc2UgdGhlXG4gICAgLy8gICAgYnJvd3NlciBiZWdpbnMgdG8gZmV0Y2guXG4gICAgc2NyaXB0LmNyb3NzT3JpZ2luID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NST1NTX09SSUdJTiFcblxuICAgIC8vIDMuIEZpbmFsbHksIHNldCB0aGUgc291cmNlIGFuZCBpbmplY3QgaW50byB0aGUgRE9NIGluIGNhc2UgdGhlIGNoaWxkXG4gICAgLy8gICAgbXVzdCBiZSBhcHBlbmRlZCBmb3IgZmV0Y2hpbmcgdG8gc3RhcnQuXG4gICAgc2NyaXB0LnNyYyA9IHNyY1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuICB9KVxufVxuXG4vLyBSZXNvbHZlIGEgcHJvbWlzZSB0aGF0IHRpbWVzIG91dCBhZnRlciBnaXZlbiBhbW91bnQgb2YgbWlsbGlzZWNvbmRzLlxuZnVuY3Rpb24gcmVzb2x2ZVByb21pc2VXaXRoVGltZW91dDxUPihcbiAgcDogUHJvbWlzZTxUPixcbiAgbXM6IG51bWJlcixcbiAgZXJyOiBFcnJvclxuKTogUHJvbWlzZTxUPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG5cbiAgICBwLnRoZW4oKHIpID0+IHtcbiAgICAgIC8vIFJlc29sdmVkLCBjYW5jZWwgdGhlIHRpbWVvdXRcbiAgICAgIGNhbmNlbGxlZCA9IHRydWVcbiAgICAgIHJlc29sdmUocilcbiAgICB9KS5jYXRjaChyZWplY3QpXG5cbiAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjYW5jZWxsZWQpIHtcbiAgICAgICAgICByZWplY3QoZXJyKVxuICAgICAgICB9XG4gICAgICB9LCBtcylcbiAgICApXG4gIH0pXG59XG5cbi8vIFRPRE86IHN0b3AgZXhwb3J0aW5nIG9yIGNhY2hlIHRoZSBmYWlsdXJlXG4vLyBJdCdkIGJlIGJlc3QgdG8gc3RvcCBleHBvcnRpbmcgdGhpcy4gSXQncyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuIFdlJ3JlXG4vLyBvbmx5IGV4cG9ydGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWx0eSB3aXRoIHRoZSBgcGFnZS1sb2FkZXJgLlxuLy8gT25seSBjYWNoZSB0aGlzIHJlc3BvbnNlIGFzIGEgbGFzdCByZXNvcnQgaWYgd2UgY2Fubm90IGVsaW1pbmF0ZSBhbGwgb3RoZXJcbi8vIGNvZGUgYnJhbmNoZXMgdGhhdCB1c2UgdGhlIEJ1aWxkIE1hbmlmZXN0IENhbGxiYWNrIGFuZCBwdXNoIHRoZW0gdGhyb3VnaFxuLy8gdGhlIFJvdXRlIExvYWRlciBpbnRlcmZhY2UuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpOiBQcm9taXNlPENsaWVudEJ1aWxkTWFuaWZlc3Q+IHtcbiAgaWYgKHNlbGYuX19CVUlMRF9NQU5JRkVTVCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2VsZi5fX0JVSUxEX01BTklGRVNUKVxuICB9XG5cbiAgY29uc3Qgb25CdWlsZE1hbmlmZXN0OiBQcm9taXNlPENsaWVudEJ1aWxkTWFuaWZlc3Q+ID0gbmV3IFByb21pc2U8XG4gICAgQ2xpZW50QnVpbGRNYW5pZmVzdFxuICA+KChyZXNvbHZlKSA9PiB7XG4gICAgLy8gTWFuZGF0b3J5IGJlY2F1c2UgdGhpcyBpcyBub3QgY29uY3VycmVudCBzYWZlOlxuICAgIGNvbnN0IGNiID0gc2VsZi5fX0JVSUxEX01BTklGRVNUX0NCXG4gICAgc2VsZi5fX0JVSUxEX01BTklGRVNUX0NCID0gKCkgPT4ge1xuICAgICAgcmVzb2x2ZShzZWxmLl9fQlVJTERfTUFOSUZFU1QhKVxuICAgICAgY2IgJiYgY2IoKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gcmVzb2x2ZVByb21pc2VXaXRoVGltZW91dDxDbGllbnRCdWlsZE1hbmlmZXN0PihcbiAgICBvbkJ1aWxkTWFuaWZlc3QsXG4gICAgTVNfTUFYX0lETEVfREVMQVksXG4gICAgbWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBjbGllbnQgYnVpbGQgbWFuaWZlc3QnKSlcbiAgKVxufVxuXG5pbnRlcmZhY2UgUm91dGVGaWxlcyB7XG4gIHNjcmlwdHM6IHN0cmluZ1tdXG4gIGNzczogc3RyaW5nW11cbn1cbmZ1bmN0aW9uIGdldEZpbGVzRm9yUm91dGUoXG4gIGFzc2V0UHJlZml4OiBzdHJpbmcsXG4gIHJvdXRlOiBzdHJpbmdcbik6IFByb21pc2U8Um91dGVGaWxlcz4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIHNjcmlwdHM6IFtcbiAgICAgICAgYXNzZXRQcmVmaXggK1xuICAgICAgICAgICcvX25leHQvc3RhdGljL2NodW5rcy9wYWdlcycgK1xuICAgICAgICAgIGVuY29kZVVSSShnZXRBc3NldFBhdGhGcm9tUm91dGUocm91dGUsICcuanMnKSksXG4gICAgICBdLFxuICAgICAgLy8gU3R5bGVzIGFyZSBoYW5kbGVkIGJ5IGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50OlxuICAgICAgY3NzOiBbXSxcbiAgICB9KVxuICB9XG4gIHJldHVybiBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkudGhlbigobWFuaWZlc3QpID0+IHtcbiAgICBpZiAoIShyb3V0ZSBpbiBtYW5pZmVzdCkpIHtcbiAgICAgIHRocm93IG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvb2t1cCByb3V0ZTogJHtyb3V0ZX1gKSlcbiAgICB9XG4gICAgY29uc3QgYWxsRmlsZXMgPSBtYW5pZmVzdFtyb3V0ZV0ubWFwKFxuICAgICAgKGVudHJ5KSA9PiBhc3NldFByZWZpeCArICcvX25leHQvJyArIGVuY29kZVVSSShlbnRyeSlcbiAgICApXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcmlwdHM6IGFsbEZpbGVzLmZpbHRlcigodikgPT4gdi5lbmRzV2l0aCgnLmpzJykpLFxuICAgICAgY3NzOiBhbGxGaWxlcy5maWx0ZXIoKHYpID0+IHYuZW5kc1dpdGgoJy5jc3MnKSksXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZUxvYWRlcihhc3NldFByZWZpeDogc3RyaW5nKTogUm91dGVMb2FkZXIge1xuICBjb25zdCBlbnRyeXBvaW50czogTWFwPFxuICAgIHN0cmluZyxcbiAgICBGdXR1cmU8Um91dGVFbnRyeXBvaW50PiB8IFJvdXRlRW50cnlwb2ludFxuICA+ID0gbmV3IE1hcCgpXG4gIGNvbnN0IGxvYWRlZFNjcmlwdHM6IE1hcDxzdHJpbmcsIFByb21pc2U8dW5rbm93bj4+ID0gbmV3IE1hcCgpXG4gIGNvbnN0IHN0eWxlU2hlZXRzOiBNYXA8c3RyaW5nLCBQcm9taXNlPFJvdXRlU3R5bGVTaGVldD4+ID0gbmV3IE1hcCgpXG4gIGNvbnN0IHJvdXRlczogTWFwPFxuICAgIHN0cmluZyxcbiAgICBGdXR1cmU8Um91dGVMb2FkZXJFbnRyeT4gfCBSb3V0ZUxvYWRlckVudHJ5XG4gID4gPSBuZXcgTWFwKClcblxuICBmdW5jdGlvbiBtYXliZUV4ZWN1dGVTY3JpcHQoc3JjOiBzdHJpbmcpOiBQcm9taXNlPHVua25vd24+IHtcbiAgICBsZXQgcHJvbTogUHJvbWlzZTx1bmtub3duPiB8IHVuZGVmaW5lZCA9IGxvYWRlZFNjcmlwdHMuZ2V0KHNyYylcbiAgICBpZiAocHJvbSkge1xuICAgICAgcmV0dXJuIHByb21cbiAgICB9XG5cbiAgICAvLyBTa2lwIGV4ZWN1dGluZyBzY3JpcHQgaWYgaXQncyBhbHJlYWR5IGluIHRoZSBET006XG4gICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHNjcmlwdFtzcmNePVwiJHtzcmN9XCJdYCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIGxvYWRlZFNjcmlwdHMuc2V0KHNyYywgKHByb20gPSBhcHBlbmRTY3JpcHQoc3JjKSkpXG4gICAgcmV0dXJuIHByb21cbiAgfVxuXG4gIGZ1bmN0aW9uIGZldGNoU3R5bGVTaGVldChocmVmOiBzdHJpbmcpOiBQcm9taXNlPFJvdXRlU3R5bGVTaGVldD4ge1xuICAgIGxldCBwcm9tOiBQcm9taXNlPFJvdXRlU3R5bGVTaGVldD4gfCB1bmRlZmluZWQgPSBzdHlsZVNoZWV0cy5nZXQoaHJlZilcbiAgICBpZiAocHJvbSkge1xuICAgICAgcmV0dXJuIHByb21cbiAgICB9XG5cbiAgICBzdHlsZVNoZWV0cy5zZXQoXG4gICAgICBocmVmLFxuICAgICAgKHByb20gPSBmZXRjaChocmVmKVxuICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3R5bGVzaGVldDogJHtocmVmfWApXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXMudGV4dCgpLnRoZW4oKHRleHQpID0+ICh7IGhyZWY6IGhyZWYsIGNvbnRlbnQ6IHRleHQgfSkpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbWFya0Fzc2V0RXJyb3IoZXJyKVxuICAgICAgICB9KSlcbiAgICApXG4gICAgcmV0dXJuIHByb21cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2hlbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZykge1xuICAgICAgcmV0dXJuIHdpdGhGdXR1cmUocm91dGUsIGVudHJ5cG9pbnRzKVxuICAgIH0sXG4gICAgb25FbnRyeXBvaW50KHJvdXRlOiBzdHJpbmcsIGV4ZWN1dGU6ICgpID0+IHVua25vd24pIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZShleGVjdXRlKVxuICAgICAgICAudGhlbigoZm4pID0+IGZuKCkpXG4gICAgICAgIC50aGVuKFxuICAgICAgICAgIChleHBvcnRzOiBhbnkpID0+ICh7XG4gICAgICAgICAgICBjb21wb25lbnQ6IChleHBvcnRzICYmIGV4cG9ydHMuZGVmYXVsdCkgfHwgZXhwb3J0cyxcbiAgICAgICAgICAgIGV4cG9ydHM6IGV4cG9ydHMsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgKGVycikgPT4gKHsgZXJyb3I6IGVyciB9KVxuICAgICAgICApXG4gICAgICAgIC50aGVuKChpbnB1dDogUm91dGVFbnRyeXBvaW50KSA9PiB7XG4gICAgICAgICAgY29uc3Qgb2xkID0gZW50cnlwb2ludHMuZ2V0KHJvdXRlKVxuICAgICAgICAgIGVudHJ5cG9pbnRzLnNldChyb3V0ZSwgaW5wdXQpXG4gICAgICAgICAgaWYgKG9sZCAmJiAncmVzb2x2ZScgaW4gb2xkKSBvbGQucmVzb2x2ZShpbnB1dClcbiAgICAgICAgfSlcbiAgICB9LFxuICAgIGxvYWRSb3V0ZShyb3V0ZTogc3RyaW5nKSB7XG4gICAgICByZXR1cm4gd2l0aEZ1dHVyZTxSb3V0ZUxvYWRlckVudHJ5Pihyb3V0ZSwgcm91dGVzLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBzY3JpcHRzLCBjc3MgfSA9IGF3YWl0IGdldEZpbGVzRm9yUm91dGUoYXNzZXRQcmVmaXgsIHJvdXRlKVxuICAgICAgICAgIGNvbnN0IFssIHN0eWxlc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBlbnRyeXBvaW50cy5oYXMocm91dGUpXG4gICAgICAgICAgICAgID8gW11cbiAgICAgICAgICAgICAgOiBQcm9taXNlLmFsbChzY3JpcHRzLm1hcChtYXliZUV4ZWN1dGVTY3JpcHQpKSxcbiAgICAgICAgICAgIFByb21pc2UuYWxsKGNzcy5tYXAoZmV0Y2hTdHlsZVNoZWV0KSksXG4gICAgICAgICAgXSBhcyBjb25zdClcblxuICAgICAgICAgIGNvbnN0IGVudHJ5cG9pbnQ6IFJvdXRlRW50cnlwb2ludCA9IGF3YWl0IHJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQoXG4gICAgICAgICAgICB0aGlzLndoZW5FbnRyeXBvaW50KHJvdXRlKSxcbiAgICAgICAgICAgIE1TX01BWF9JRExFX0RFTEFZLFxuICAgICAgICAgICAgbWFya0Fzc2V0RXJyb3IoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihgUm91dGUgZGlkIG5vdCBjb21wbGV0ZSBsb2FkaW5nOiAke3JvdXRlfWApXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgY29uc3QgcmVzOiBSb3V0ZUxvYWRlckVudHJ5ID0gT2JqZWN0LmFzc2lnbjxcbiAgICAgICAgICAgIHsgc3R5bGVzOiBSb3V0ZVN0eWxlU2hlZXRbXSB9LFxuICAgICAgICAgICAgUm91dGVFbnRyeXBvaW50XG4gICAgICAgICAgPih7IHN0eWxlcyB9LCBlbnRyeXBvaW50KVxuICAgICAgICAgIHJldHVybiAnZXJyb3InIGluIGVudHJ5cG9pbnQgPyBlbnRyeXBvaW50IDogcmVzXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiB7IGVycm9yOiBlcnIgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sXG4gICAgcHJlZmV0Y2gocm91dGU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvcXVpY2tsaW5rL2Jsb2IvNDUzYTY2MWZhMWZhOTQwZTJkMmUwNDQ0NTIzOThlMzhjNjdhOThmYi9zcmMvaW5kZXgubWpzI0wxMTUtTDExOFxuICAgICAgLy8gTGljZW5zZTogQXBhY2hlIDIuMFxuICAgICAgbGV0IGNuXG4gICAgICBpZiAoKGNuID0gKG5hdmlnYXRvciBhcyBhbnkpLmNvbm5lY3Rpb24pKSB7XG4gICAgICAgIC8vIERvbid0IHByZWZldGNoIGlmIHVzaW5nIDJHIG9yIGlmIFNhdmUtRGF0YSBpcyBlbmFibGVkLlxuICAgICAgICBpZiAoY24uc2F2ZURhdGEgfHwgLzJnLy50ZXN0KGNuLmVmZmVjdGl2ZVR5cGUpKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRGaWxlc0ZvclJvdXRlKGFzc2V0UHJlZml4LCByb3V0ZSlcbiAgICAgICAgLnRoZW4oKG91dHB1dCkgPT5cbiAgICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIGNhblByZWZldGNoXG4gICAgICAgICAgICAgID8gb3V0cHV0LnNjcmlwdHMubWFwKChzY3JpcHQpID0+IHByZWZldGNoVmlhRG9tKHNjcmlwdCwgJ3NjcmlwdCcpKVxuICAgICAgICAgICAgICA6IFtdXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHRoaXMubG9hZFJvdXRlKHJvdXRlKSlcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKFxuICAgICAgICAgIC8vIHN3YWxsb3cgcHJlZmV0Y2ggZXJyb3JzXG4gICAgICAgICAgKCkgPT4ge31cbiAgICAgICAgKVxuICAgIH0sXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUm91dGVMb2FkZXJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/route-loader.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nexports.__esModule = true;\nexports.useRouter = useRouter;\nexports.makePublicRouterInstance = makePublicRouterInstance;\nexports.createRouter = exports.withRouter = exports.default = void 0;\n\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\n\nvar _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ \"./node_modules/next/dist/next-server/lib/router/router.js\"));\n\nexports.Router = _router2.default;\nexports.NextRouter = _router2.NextRouter;\n\nvar _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ \"../next-server/lib/router-context\");\n\nvar _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ \"./node_modules/next/dist/client/with-router.js\"));\n\nexports.withRouter = _withRouter.default;\n/* global window */\n\nconst singletonRouter = {\n  router: null,\n  // holds the actual router instance\n  readyCallbacks: [],\n\n  ready(cb) {\n    if (this.router) return cb();\n\n    if (false) {}\n  }\n\n}; // Create public properties and methods of the router in the singletonRouter\n\nconst urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath', 'locale', 'locales', 'defaultLocale', 'isReady', 'isPreview', 'isLocaleDomain'];\nconst routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];\nconst coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it\n\nObject.defineProperty(singletonRouter, 'events', {\n  get() {\n    return _router2.default.events;\n  }\n\n});\nurlPropertyFields.forEach(field => {\n  // Here we need to use Object.defineProperty because, we need to return\n  // the property assigned to the actual router\n  // The value might get changed as we change routes and this is the\n  // proper way to access it\n  Object.defineProperty(singletonRouter, field, {\n    get() {\n      const router = getRouter();\n      return router[field];\n    }\n\n  });\n});\ncoreMethodFields.forEach(field => {\n  // We don't really know the types here, so we add them later instead\n  ;\n\n  singletonRouter[field] = (...args) => {\n    const router = getRouter();\n    return router[field](...args);\n  };\n});\nrouterEvents.forEach(event => {\n  singletonRouter.ready(() => {\n    _router2.default.events.on(event, (...args) => {\n      const eventField = `on${event.charAt(0).toUpperCase()}${event.substring(1)}`;\n      const _singletonRouter = singletonRouter;\n\n      if (_singletonRouter[eventField]) {\n        try {\n          _singletonRouter[eventField](...args);\n        } catch (err) {\n          console.error(`Error when running the Router event: ${eventField}`);\n          console.error(`${err.message}\\n${err.stack}`);\n        }\n      }\n    });\n  });\n});\n\nfunction getRouter() {\n  if (!singletonRouter.router) {\n    const message = 'No router instance found.\\n' + 'You should only use \"next/router\" inside the client side of your app.\\n';\n    throw new Error(message);\n  }\n\n  return singletonRouter.router;\n} // Export the singletonRouter and this is the public API.\n\n\nvar _default = singletonRouter; // Reexport the withRoute HOC\n\nexports.default = _default;\n\nfunction useRouter() {\n  return _react.default.useContext(_routerContext.RouterContext);\n} // INTERNAL APIS\n// -------------\n// (do not use following exports inside the app)\n// Create a router and assign it as the singleton instance.\n// This is used in client side when we are initilizing the app.\n// This should **not** use inside the server.\n\n\nconst createRouter = (...args) => {\n  singletonRouter.router = new _router2.default(...args);\n  singletonRouter.readyCallbacks.forEach(cb => cb());\n  singletonRouter.readyCallbacks = [];\n  return singletonRouter.router;\n}; // This function is used to create the `withRouter` router instance\n\n\nexports.createRouter = createRouter;\n\nfunction makePublicRouterInstance(router) {\n  const _router = router;\n  const instance = {};\n\n  for (const property of urlPropertyFields) {\n    if (typeof _router[property] === 'object') {\n      instance[property] = Object.assign(Array.isArray(_router[property]) ? [] : {}, _router[property]); // makes sure query is not stateful\n\n      continue;\n    }\n\n    instance[property] = _router[property];\n  } // Events is a static property on the router, the router doesn't have to be initialized to use it\n\n\n  instance.events = _router2.default.events;\n  coreMethodFields.forEach(field => {\n    instance[field] = (...args) => {\n      return _router[field](...args);\n    };\n  });\n  return instance;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L3JvdXRlci50cz8wNmZmIl0sIm5hbWVzIjpbInNpbmdsZXRvblJvdXRlciIsInJvdXRlciIsInJlYWR5Q2FsbGJhY2tzIiwicmVhZHkiLCJjYiIsInVybFByb3BlcnR5RmllbGRzIiwicm91dGVyRXZlbnRzIiwiY29yZU1ldGhvZEZpZWxkcyIsIk9iamVjdCIsImdldCIsIlJvdXRlciIsImZpZWxkIiwiZ2V0Um91dGVyIiwiZXZlbnQiLCJldmVudEZpZWxkIiwiX3NpbmdsZXRvblJvdXRlciIsImNvbnNvbGUiLCJlcnIiLCJtZXNzYWdlIiwic3RhY2siLCJSZWFjdCIsIlJvdXRlckNvbnRleHQiLCJjcmVhdGVSb3V0ZXIiLCJfcm91dGVyIiwiaW5zdGFuY2UiLCJBcnJheSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFDQTs7QUFDQTs7Ozs7QUFDQTs7QUF5SEE7OztBQTVIQTs7QUFtQkEsTUFBTUEsZUFBb0MsR0FBRztBQUMzQ0MsUUFBTSxFQURxQztBQUM3QjtBQUNkQyxnQkFBYyxFQUY2Qjs7QUFHM0NDLE9BQUssS0FBaUI7QUFDcEIsUUFBSSxLQUFKLFFBQWlCLE9BQU9DLEVBQVA7O0FBQ2pCLGVBQW1DLEVBR3BDO0FBUkg7O0FBQTZDLENBQTdDLEMsQ0FXQTs7QUFDQSxNQUFNQyxpQkFBaUIsR0FBRywrSUFBMUIsZ0JBQTBCLENBQTFCO0FBZUEsTUFBTUMsWUFBWSxHQUFHLDBHQUFyQixvQkFBcUIsQ0FBckI7QUFRQSxNQUFNQyxnQkFBZ0IsR0FBRyxrREFBekIsZ0JBQXlCLENBQXpCLEMsQ0FTQTs7QUFDQUMsTUFBTSxDQUFOQSwwQ0FBaUQ7QUFDL0NDLEtBQUcsR0FBRztBQUNKLFdBQU9DLGlCQUFQO0FBRkpGOztBQUFpRCxDQUFqREE7QUFNQUgsaUJBQWlCLENBQWpCQSxRQUEyQk0sS0FBRCxJQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBSCxRQUFNLENBQU5BLHVDQUE4QztBQUM1Q0MsT0FB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LCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgUm91dGVyLCB7IE5leHRSb3V0ZXIgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IFJvdXRlckNvbnRleHQgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyLWNvbnRleHQnXG5cbnR5cGUgQ2xhc3NBcmd1bWVudHM8VD4gPSBUIGV4dGVuZHMgbmV3ICguLi5hcmdzOiBpbmZlciBVKSA9PiBhbnkgPyBVIDogYW55XG5cbnR5cGUgUm91dGVyQXJncyA9IENsYXNzQXJndW1lbnRzPHR5cGVvZiBSb3V0ZXI+XG5cbnR5cGUgU2luZ2xldG9uUm91dGVyQmFzZSA9IHtcbiAgcm91dGVyOiBSb3V0ZXIgfCBudWxsXG4gIHJlYWR5Q2FsbGJhY2tzOiBBcnJheTwoKSA9PiBhbnk+XG4gIHJlYWR5KGNiOiAoKSA9PiBhbnkpOiB2b2lkXG59XG5cbmV4cG9ydCB7IFJvdXRlciwgTmV4dFJvdXRlciB9XG5cbmV4cG9ydCB0eXBlIFNpbmdsZXRvblJvdXRlciA9IFNpbmdsZXRvblJvdXRlckJhc2UgJiBOZXh0Um91dGVyXG5cbmNvbnN0IHNpbmdsZXRvblJvdXRlcjogU2luZ2xldG9uUm91dGVyQmFzZSA9IHtcbiAgcm91dGVyOiBudWxsLCAvLyBob2xkcyB0aGUgYWN0dWFsIHJvdXRlciBpbnN0YW5jZVxuICByZWFkeUNhbGxiYWNrczogW10sXG4gIHJlYWR5KGNiOiAoKSA9PiB2b2lkKSB7XG4gICAgaWYgKHRoaXMucm91dGVyKSByZXR1cm4gY2IoKVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5yZWFkeUNhbGxiYWNrcy5wdXNoKGNiKVxuICAgIH1cbiAgfSxcbn1cblxuLy8gQ3JlYXRlIHB1YmxpYyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIG9mIHRoZSByb3V0ZXIgaW4gdGhlIHNpbmdsZXRvblJvdXRlclxuY29uc3QgdXJsUHJvcGVydHlGaWVsZHMgPSBbXG4gICdwYXRobmFtZScsXG4gICdyb3V0ZScsXG4gICdxdWVyeScsXG4gICdhc1BhdGgnLFxuICAnY29tcG9uZW50cycsXG4gICdpc0ZhbGxiYWNrJyxcbiAgJ2Jhc2VQYXRoJyxcbiAgJ2xvY2FsZScsXG4gICdsb2NhbGVzJyxcbiAgJ2RlZmF1bHRMb2NhbGUnLFxuICAnaXNSZWFkeScsXG4gICdpc1ByZXZpZXcnLFxuICAnaXNMb2NhbGVEb21haW4nLFxuXVxuY29uc3Qgcm91dGVyRXZlbnRzID0gW1xuICAncm91dGVDaGFuZ2VTdGFydCcsXG4gICdiZWZvcmVIaXN0b3J5Q2hhbmdlJyxcbiAgJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLFxuICAncm91dGVDaGFuZ2VFcnJvcicsXG4gICdoYXNoQ2hhbmdlU3RhcnQnLFxuICAnaGFzaENoYW5nZUNvbXBsZXRlJyxcbl1cbmNvbnN0IGNvcmVNZXRob2RGaWVsZHMgPSBbXG4gICdwdXNoJyxcbiAgJ3JlcGxhY2UnLFxuICAncmVsb2FkJyxcbiAgJ2JhY2snLFxuICAncHJlZmV0Y2gnLFxuICAnYmVmb3JlUG9wU3RhdGUnLFxuXVxuXG4vLyBFdmVudHMgaXMgYSBzdGF0aWMgcHJvcGVydHkgb24gdGhlIHJvdXRlciwgdGhlIHJvdXRlciBkb2Vzbid0IGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gdXNlIGl0XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc2luZ2xldG9uUm91dGVyLCAnZXZlbnRzJywge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIFJvdXRlci5ldmVudHNcbiAgfSxcbn0pXG5cbnVybFByb3BlcnR5RmllbGRzLmZvckVhY2goKGZpZWxkOiBzdHJpbmcpID0+IHtcbiAgLy8gSGVyZSB3ZSBuZWVkIHRvIHVzZSBPYmplY3QuZGVmaW5lUHJvcGVydHkgYmVjYXVzZSwgd2UgbmVlZCB0byByZXR1cm5cbiAgLy8gdGhlIHByb3BlcnR5IGFzc2lnbmVkIHRvIHRoZSBhY3R1YWwgcm91dGVyXG4gIC8vIFRoZSB2YWx1ZSBtaWdodCBnZXQgY2hhbmdlZCBhcyB3ZSBjaGFuZ2Ugcm91dGVzIGFuZCB0aGlzIGlzIHRoZVxuICAvLyBwcm9wZXIgd2F5IHRvIGFjY2VzcyBpdFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2luZ2xldG9uUm91dGVyLCBmaWVsZCwge1xuICAgIGdldCgpIHtcbiAgICAgIGNvbnN0IHJvdXRlciA9IGdldFJvdXRlcigpIGFzIGFueVxuICAgICAgcmV0dXJuIHJvdXRlcltmaWVsZF0gYXMgc3RyaW5nXG4gICAgfSxcbiAgfSlcbn0pXG5cbmNvcmVNZXRob2RGaWVsZHMuZm9yRWFjaCgoZmllbGQ6IHN0cmluZykgPT4ge1xuICAvLyBXZSBkb24ndCByZWFsbHkga25vdyB0aGUgdHlwZXMgaGVyZSwgc28gd2UgYWRkIHRoZW0gbGF0ZXIgaW5zdGVhZFxuICA7KHNpbmdsZXRvblJvdXRlciBhcyBhbnkpW2ZpZWxkXSA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgIGNvbnN0IHJvdXRlciA9IGdldFJvdXRlcigpIGFzIGFueVxuICAgIHJldHVybiByb3V0ZXJbZmllbGRdKC4uLmFyZ3MpXG4gIH1cbn0pXG5cbnJvdXRlckV2ZW50cy5mb3JFYWNoKChldmVudDogc3RyaW5nKSA9PiB7XG4gIHNpbmdsZXRvblJvdXRlci5yZWFkeSgoKSA9PiB7XG4gICAgUm91dGVyLmV2ZW50cy5vbihldmVudCwgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50RmllbGQgPSBgb24ke2V2ZW50LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7ZXZlbnQuc3Vic3RyaW5nKFxuICAgICAgICAxXG4gICAgICApfWBcbiAgICAgIGNvbnN0IF9zaW5nbGV0b25Sb3V0ZXIgPSBzaW5nbGV0b25Sb3V0ZXIgYXMgYW55XG4gICAgICBpZiAoX3NpbmdsZXRvblJvdXRlcltldmVudEZpZWxkXSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF9zaW5nbGV0b25Sb3V0ZXJbZXZlbnRGaWVsZF0oLi4uYXJncylcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2hlbiBydW5uaW5nIHRoZSBSb3V0ZXIgZXZlbnQ6ICR7ZXZlbnRGaWVsZH1gKVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCR7ZXJyLm1lc3NhZ2V9XFxuJHtlcnIuc3RhY2t9YClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG59KVxuXG5mdW5jdGlvbiBnZXRSb3V0ZXIoKTogUm91dGVyIHtcbiAgaWYgKCFzaW5nbGV0b25Sb3V0ZXIucm91dGVyKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAnTm8gcm91dGVyIGluc3RhbmNlIGZvdW5kLlxcbicgK1xuICAgICAgJ1lvdSBzaG91bGQgb25seSB1c2UgXCJuZXh0L3JvdXRlclwiIGluc2lkZSB0aGUgY2xpZW50IHNpZGUgb2YgeW91ciBhcHAuXFxuJ1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICB9XG4gIHJldHVybiBzaW5nbGV0b25Sb3V0ZXIucm91dGVyXG59XG5cbi8vIEV4cG9ydCB0aGUgc2luZ2xldG9uUm91dGVyIGFuZCB0aGlzIGlzIHRoZSBwdWJsaWMgQVBJLlxuZXhwb3J0IGRlZmF1bHQgc2luZ2xldG9uUm91dGVyIGFzIFNpbmdsZXRvblJvdXRlclxuXG4vLyBSZWV4cG9ydCB0aGUgd2l0aFJvdXRlIEhPQ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB3aXRoUm91dGVyIH0gZnJvbSAnLi93aXRoLXJvdXRlcidcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJvdXRlcigpOiBOZXh0Um91dGVyIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoUm91dGVyQ29udGV4dClcbn1cblxuLy8gSU5URVJOQUwgQVBJU1xuLy8gLS0tLS0tLS0tLS0tLVxuLy8gKGRvIG5vdCB1c2UgZm9sbG93aW5nIGV4cG9ydHMgaW5zaWRlIHRoZSBhcHApXG5cbi8vIENyZWF0ZSBhIHJvdXRlciBhbmQgYXNzaWduIGl0IGFzIHRoZSBzaW5nbGV0b24gaW5zdGFuY2UuXG4vLyBUaGlzIGlzIHVzZWQgaW4gY2xpZW50IHNpZGUgd2hlbiB3ZSBhcmUgaW5pdGlsaXppbmcgdGhlIGFwcC5cbi8vIFRoaXMgc2hvdWxkICoqbm90KiogdXNlIGluc2lkZSB0aGUgc2VydmVyLlxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJvdXRlciA9ICguLi5hcmdzOiBSb3V0ZXJBcmdzKTogUm91dGVyID0+IHtcbiAgc2luZ2xldG9uUm91dGVyLnJvdXRlciA9IG5ldyBSb3V0ZXIoLi4uYXJncylcbiAgc2luZ2xldG9uUm91dGVyLnJlYWR5Q2FsbGJhY2tzLmZvckVhY2goKGNiKSA9PiBjYigpKVxuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHlDYWxsYmFja3MgPSBbXVxuXG4gIHJldHVybiBzaW5nbGV0b25Sb3V0ZXIucm91dGVyXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBjcmVhdGUgdGhlIGB3aXRoUm91dGVyYCByb3V0ZXIgaW5zdGFuY2VcbmV4cG9ydCBmdW5jdGlvbiBtYWtlUHVibGljUm91dGVySW5zdGFuY2Uocm91dGVyOiBSb3V0ZXIpOiBOZXh0Um91dGVyIHtcbiAgY29uc3QgX3JvdXRlciA9IHJvdXRlciBhcyBhbnlcbiAgY29uc3QgaW5zdGFuY2UgPSB7fSBhcyBhbnlcblxuICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHVybFByb3BlcnR5RmllbGRzKSB7XG4gICAgaWYgKHR5cGVvZiBfcm91dGVyW3Byb3BlcnR5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGluc3RhbmNlW3Byb3BlcnR5XSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIEFycmF5LmlzQXJyYXkoX3JvdXRlcltwcm9wZXJ0eV0pID8gW10gOiB7fSxcbiAgICAgICAgX3JvdXRlcltwcm9wZXJ0eV1cbiAgICAgICkgLy8gbWFrZXMgc3VyZSBxdWVyeSBpcyBub3Qgc3RhdGVmdWxcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaW5zdGFuY2VbcHJvcGVydHldID0gX3JvdXRlcltwcm9wZXJ0eV1cbiAgfVxuXG4gIC8vIEV2ZW50cyBpcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiB0aGUgcm91dGVyLCB0aGUgcm91dGVyIGRvZXNuJ3QgaGF2ZSB0byBiZSBpbml0aWFsaXplZCB0byB1c2UgaXRcbiAgaW5zdGFuY2UuZXZlbnRzID0gUm91dGVyLmV2ZW50c1xuXG4gIGNvcmVNZXRob2RGaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICBpbnN0YW5jZVtmaWVsZF0gPSAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICAgIHJldHVybiBfcm91dGVyW2ZpZWxkXSguLi5hcmdzKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gaW5zdGFuY2Vcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/router.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.useIntersection = useIntersection;\n\nvar _react = __webpack_require__(/*! react */ \"react\");\n\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\n\nconst hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';\n\nfunction useIntersection({\n  rootMargin,\n  disabled\n}) {\n  const isDisabled = disabled || !hasIntersectionObserver;\n  const unobserve = (0, _react.useRef)();\n  const [visible, setVisible] = (0, _react.useState)(false);\n  const setRef = (0, _react.useCallback)(el => {\n    if (unobserve.current) {\n      unobserve.current();\n      unobserve.current = undefined;\n    }\n\n    if (isDisabled || visible) return;\n\n    if (el && el.tagName) {\n      unobserve.current = observe(el, isVisible => isVisible && setVisible(isVisible), {\n        rootMargin\n      });\n    }\n  }, [isDisabled, rootMargin, visible]);\n  (0, _react.useEffect)(() => {\n    if (!hasIntersectionObserver) {\n      if (!visible) {\n        const idleCallback = (0, _requestIdleCallback.requestIdleCallback)(() => setVisible(true));\n        return () => (0, _requestIdleCallback.cancelIdleCallback)(idleCallback);\n      }\n    }\n  }, [visible]);\n  return [setRef, visible];\n}\n\nfunction observe(element, callback, options) {\n  const {\n    id,\n    observer,\n    elements\n  } = createObserver(options);\n  elements.set(element, callback);\n  observer.observe(element);\n  return function unobserve() {\n    elements.delete(element);\n    observer.unobserve(element); // Destroy observer when there's nothing left to watch:\n\n    if (elements.size === 0) {\n      observer.disconnect();\n      observers.delete(id);\n    }\n  };\n}\n\nconst observers = new Map();\n\nfunction createObserver(options) {\n  const id = options.rootMargin || '';\n  let instance = observers.get(id);\n\n  if (instance) {\n    return instance;\n  }\n\n  const elements = new Map();\n  const observer = new IntersectionObserver(entries => {\n    entries.forEach(entry => {\n      const callback = elements.get(entry.target);\n      const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n\n      if (callback && isVisible) {\n        callback(isVisible);\n      }\n    });\n  }, options);\n  observers.set(id, instance = {\n    id,\n    observer,\n    elements\n  });\n  return instance;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24udHN4PzkyOGIiXSwibmFtZXMiOlsiaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJpc0Rpc2FibGVkIiwiZGlzYWJsZWQiLCJ1bm9ic2VydmUiLCJzZXRSZWYiLCJlbCIsIm9ic2VydmUiLCJpc1Zpc2libGUiLCJzZXRWaXNpYmxlIiwiaWRsZUNhbGxiYWNrIiwiY3JlYXRlT2JzZXJ2ZXIiLCJlbGVtZW50cyIsIm9ic2VydmVyIiwib2JzZXJ2ZXJzIiwiaWQiLCJvcHRpb25zIiwiaW5zdGFuY2UiLCJlbnRyaWVzIiwiZW50cnkiLCJjYWxsYmFjayJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7QUFDQTs7QUFjQSxNQUFNQSx1QkFBdUIsR0FBRyxnQ0FBaEM7O0FBRU8seUJBQTRDO0FBQUE7QUFBNUM7QUFBNEMsQ0FBNUMsRUFHcUQ7QUFDMUQsUUFBTUMsVUFBbUIsR0FBR0MsUUFBUSxJQUFJLENBQXhDO0FBRUEsUUFBTUMsU0FBUyxHQUFHLFdBQWxCLE1BQWtCLEdBQWxCO0FBQ0EsUUFBTSx3QkFBd0IscUJBQTlCLEtBQThCLENBQTlCO0FBRUEsUUFBTUMsTUFBTSxHQUFHLHdCQUNaQyxFQUFELElBQWtCO0FBQ2hCLFFBQUlGLFNBQVMsQ0FBYixTQUF1QjtBQUNyQkEsZUFBUyxDQUFUQTtBQUNBQSxlQUFTLENBQVRBO0FBR0Y7O0FBQUEsUUFBSUYsVUFBVSxJQUFkLFNBQTJCOztBQUUzQixRQUFJSSxFQUFFLElBQUlBLEVBQUUsQ0FBWixTQUFzQjtBQUNwQkYsZUFBUyxDQUFUQSxVQUFvQkcsT0FBTyxLQUV4QkMsU0FBRCxJQUFlQSxTQUFTLElBQUlDLFVBQVUsQ0FGYixTQUVhLENBRmIsRUFHekI7QUFIRkw7QUFHRSxPQUh5QixDQUEzQkE7QUFNSDtBQWhCWSxLQWlCYix5QkFqQkYsT0FpQkUsQ0FqQmEsQ0FBZjtBQW9CQSx3QkFBVSxNQUFNO0FBQ2QsUUFBSSxDQUFKLHlCQUE4QjtBQUM1QixVQUFJLENBQUosU0FBYztBQUNaLGNBQU1NLFlBQVksR0FBRyw4Q0FBb0IsTUFBTUQsVUFBVSxDQUF6RCxJQUF5RCxDQUFwQyxDQUFyQjtBQUNBLGVBQU8sTUFBTSw2Q0FBYixZQUFhLENBQWI7QUFFSDtBQUNGO0FBUEQsS0FPRyxDQVBILE9BT0csQ0FQSDtBQVNBLFNBQU8sU0FBUCxPQUFPLENBQVA7QUFHRjs7QUFBQSw2Q0FJYztBQUNaLFFBQU07QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUE2QkUsY0FBYyxDQUFqRCxPQUFpRCxDQUFqRDtBQUNBQyxVQUFRLENBQVJBO0FBRUFDLFVBQVEsQ0FBUkE7QUFDQSxTQUFPLHFCQUEyQjtBQUNoQ0QsWUFBUSxDQUFSQTtBQUNBQyxZQUFRLENBQVJBLG1CQUZnQyxDQUloQzs7QUFDQSxRQUFJRCxRQUFRLENBQVJBLFNBQUosR0FBeUI7QUFDdkJDLGNBQVEsQ0FBUkE7QUFDQUMsZUFBUyxDQUFUQTtBQUVIO0FBVEQ7QUFZRjs7QUFBQSxNQUFNQSxTQUFTLEdBQUcsSUFBbEIsR0FBa0IsRUFBbEI7O0FBQ0EsaUNBQXdFO0FBQ3RFLFFBQU1DLEVBQUUsR0FBR0MsT0FBTyxDQUFQQSxjQUFYO0FBQ0EsTUFBSUMsUUFBUSxHQUFHSCxTQUFTLENBQVRBLElBQWYsRUFBZUEsQ0FBZjs7QUFDQSxnQkFBYztBQUNaO0FBR0Y7O0FBQUEsUUFBTUYsUUFBUSxHQUFHLElBQWpCLEdBQWlCLEVBQWpCO0FBQ0EsUUFBTUMsUUFBUSxHQUFHLHlCQUEwQkssT0FBRCxJQUFhO0FBQ3JEQSxXQUFPLENBQVBBLFFBQWlCQyxLQUFELElBQVc7QUFDekIsWUFBTUMsUUFBUSxHQUFHUixRQUFRLENBQVJBLElBQWFPLEtBQUssQ0FBbkMsTUFBaUJQLENBQWpCO0FBQ0EsWUFBTUosU0FBUyxHQUFHVyxLQUFLLENBQUxBLGtCQUF3QkEsS0FBSyxDQUFMQSxvQkFBMUM7O0FBQ0EsVUFBSUMsUUFBUSxJQUFaLFdBQTJCO0FBQ3pCQSxnQkFBUSxDQUFSQSxTQUFRLENBQVJBO0FBRUg7QUFOREY7QUFEZSxLQUFqQixPQUFpQixDQUFqQjtBQVVBSixXQUFTLENBQVRBLFFBRUdHLFFBQVEsR0FBRztBQUFBO0FBQUE7QUFGZEg7QUFFYyxHQUZkQTtBQVFBO0FBQ0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHtcbiAgcmVxdWVzdElkbGVDYWxsYmFjayxcbiAgY2FuY2VsSWRsZUNhbGxiYWNrLFxufSBmcm9tICcuL3JlcXVlc3QtaWRsZS1jYWxsYmFjaydcblxudHlwZSBVc2VJbnRlcnNlY3Rpb25PYnNlcnZlckluaXQgPSBQaWNrPEludGVyc2VjdGlvbk9ic2VydmVySW5pdCwgJ3Jvb3RNYXJnaW4nPlxudHlwZSBVc2VJbnRlcnNlY3Rpb24gPSB7IGRpc2FibGVkPzogYm9vbGVhbiB9ICYgVXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0XG50eXBlIE9ic2VydmVDYWxsYmFjayA9IChpc1Zpc2libGU6IGJvb2xlYW4pID0+IHZvaWRcbnR5cGUgT2JzZXJ2ZXIgPSB7XG4gIGlkOiBzdHJpbmdcbiAgb2JzZXJ2ZXI6IEludGVyc2VjdGlvbk9ic2VydmVyXG4gIGVsZW1lbnRzOiBNYXA8RWxlbWVudCwgT2JzZXJ2ZUNhbGxiYWNrPlxufVxuXG5jb25zdCBoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCdcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbjxUIGV4dGVuZHMgRWxlbWVudD4oe1xuICByb290TWFyZ2luLFxuICBkaXNhYmxlZCxcbn06IFVzZUludGVyc2VjdGlvbik6IFsoZWxlbWVudDogVCB8IG51bGwpID0+IHZvaWQsIGJvb2xlYW5dIHtcbiAgY29uc3QgaXNEaXNhYmxlZDogYm9vbGVhbiA9IGRpc2FibGVkIHx8ICFoYXNJbnRlcnNlY3Rpb25PYnNlcnZlclxuXG4gIGNvbnN0IHVub2JzZXJ2ZSA9IHVzZVJlZjxGdW5jdGlvbj4oKVxuICBjb25zdCBbdmlzaWJsZSwgc2V0VmlzaWJsZV0gPSB1c2VTdGF0ZShmYWxzZSlcblxuICBjb25zdCBzZXRSZWYgPSB1c2VDYWxsYmFjayhcbiAgICAoZWw6IFQgfCBudWxsKSA9PiB7XG4gICAgICBpZiAodW5vYnNlcnZlLmN1cnJlbnQpIHtcbiAgICAgICAgdW5vYnNlcnZlLmN1cnJlbnQoKVxuICAgICAgICB1bm9ic2VydmUuY3VycmVudCA9IHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICBpZiAoaXNEaXNhYmxlZCB8fCB2aXNpYmxlKSByZXR1cm5cblxuICAgICAgaWYgKGVsICYmIGVsLnRhZ05hbWUpIHtcbiAgICAgICAgdW5vYnNlcnZlLmN1cnJlbnQgPSBvYnNlcnZlKFxuICAgICAgICAgIGVsLFxuICAgICAgICAgIChpc1Zpc2libGUpID0+IGlzVmlzaWJsZSAmJiBzZXRWaXNpYmxlKGlzVmlzaWJsZSksXG4gICAgICAgICAgeyByb290TWFyZ2luIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0sXG4gICAgW2lzRGlzYWJsZWQsIHJvb3RNYXJnaW4sIHZpc2libGVdXG4gIClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgICBjb25zdCBpZGxlQ2FsbGJhY2sgPSByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHNldFZpc2libGUodHJ1ZSkpXG4gICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxJZGxlQ2FsbGJhY2soaWRsZUNhbGxiYWNrKVxuICAgICAgfVxuICAgIH1cbiAgfSwgW3Zpc2libGVdKVxuXG4gIHJldHVybiBbc2V0UmVmLCB2aXNpYmxlXVxufVxuXG5mdW5jdGlvbiBvYnNlcnZlKFxuICBlbGVtZW50OiBFbGVtZW50LFxuICBjYWxsYmFjazogT2JzZXJ2ZUNhbGxiYWNrLFxuICBvcHRpb25zOiBVc2VJbnRlcnNlY3Rpb25PYnNlcnZlckluaXRcbik6ICgpID0+IHZvaWQge1xuICBjb25zdCB7IGlkLCBvYnNlcnZlciwgZWxlbWVudHMgfSA9IGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpXG4gIGVsZW1lbnRzLnNldChlbGVtZW50LCBjYWxsYmFjaylcblxuICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQpXG4gIHJldHVybiBmdW5jdGlvbiB1bm9ic2VydmUoKTogdm9pZCB7XG4gICAgZWxlbWVudHMuZGVsZXRlKGVsZW1lbnQpXG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpXG5cbiAgICAvLyBEZXN0cm95IG9ic2VydmVyIHdoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gd2F0Y2g6XG4gICAgaWYgKGVsZW1lbnRzLnNpemUgPT09IDApIHtcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShpZClcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgb2JzZXJ2ZXJzID0gbmV3IE1hcDxzdHJpbmcsIE9ic2VydmVyPigpXG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlcihvcHRpb25zOiBVc2VJbnRlcnNlY3Rpb25PYnNlcnZlckluaXQpOiBPYnNlcnZlciB7XG4gIGNvbnN0IGlkID0gb3B0aW9ucy5yb290TWFyZ2luIHx8ICcnXG4gIGxldCBpbnN0YW5jZSA9IG9ic2VydmVycy5nZXQoaWQpXG4gIGlmIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZVxuICB9XG5cbiAgY29uc3QgZWxlbWVudHMgPSBuZXcgTWFwPEVsZW1lbnQsIE9ic2VydmVDYWxsYmFjaz4oKVxuICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gZWxlbWVudHMuZ2V0KGVudHJ5LnRhcmdldClcbiAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMFxuICAgICAgaWYgKGNhbGxiYWNrICYmIGlzVmlzaWJsZSkge1xuICAgICAgICBjYWxsYmFjayhpc1Zpc2libGUpXG4gICAgICB9XG4gICAgfSlcbiAgfSwgb3B0aW9ucylcblxuICBvYnNlcnZlcnMuc2V0KFxuICAgIGlkLFxuICAgIChpbnN0YW5jZSA9IHtcbiAgICAgIGlkLFxuICAgICAgb2JzZXJ2ZXIsXG4gICAgICBlbGVtZW50cyxcbiAgICB9KVxuICApXG4gIHJldHVybiBpbnN0YW5jZVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/use-intersection.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nexports.__esModule = true;\nexports.default = withRouter;\n\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\n\nvar _router = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\n\nfunction withRouter(ComposedComponent) {\n  function WithRouterWrapper(props) {\n    return /*#__PURE__*/_react.default.createElement(ComposedComponent, Object.assign({\n      router: (0, _router.useRouter)()\n    }, props));\n  }\n\n  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app\n  ;\n  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;\n\n  if (true) {\n    const name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';\n    WithRouterWrapper.displayName = `withRouter(${name})`;\n  }\n\n  return WithRouterWrapper;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L3dpdGgtcm91dGVyLnRzeD80ZmNiIl0sIm5hbWVzIjpbIkNvbXBvc2VkQ29tcG9uZW50IiwiZ2V0SW5pdGlhbFByb3BzIiwiV2l0aFJvdXRlcldyYXBwZXIiLCJuYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBRUE7O0FBV2UsdUNBSytCO0FBQzVDLG9DQUFvRDtBQUNsRCx3QkFBTztBQUFtQixZQUFNLEVBQUUsWUFBM0IsU0FBMkI7QUFBM0IsT0FBUCxLQUFPLEVBQVA7QUFHRjs7QUFBQSxtQkFBaUIsQ0FBakIsa0JBQW9DQSxpQkFBaUIsQ0FBQ0MsZUFBdEQsQ0FDQTtBQURBO0FBRUVDLG1CQUFELG9CQUFDQSxHQUFpREYsaUJBQUQsQ0FBakQsbUJBQUNFOztBQUNGLFlBQTJDO0FBQ3pDLFVBQU1DLElBQUksR0FDUkgsaUJBQWlCLENBQWpCQSxlQUFpQ0EsaUJBQWlCLENBQWxEQSxRQURGO0FBRUFFLHFCQUFpQixDQUFqQkEsY0FBaUMsY0FBYUMsSUFBOUNEO0FBR0Y7O0FBQUE7QUFDRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3dpdGgtcm91dGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgTmV4dENvbXBvbmVudFR5cGUsIE5leHRQYWdlQ29udGV4dCB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi91dGlscydcbmltcG9ydCB7IE5leHRSb3V0ZXIsIHVzZVJvdXRlciB9IGZyb20gJy4vcm91dGVyJ1xuXG5leHBvcnQgdHlwZSBXaXRoUm91dGVyUHJvcHMgPSB7XG4gIHJvdXRlcjogTmV4dFJvdXRlclxufVxuXG5leHBvcnQgdHlwZSBFeGNsdWRlUm91dGVyUHJvcHM8UD4gPSBQaWNrPFxuICBQLFxuICBFeGNsdWRlPGtleW9mIFAsIGtleW9mIFdpdGhSb3V0ZXJQcm9wcz5cbj5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2l0aFJvdXRlcjxcbiAgUCBleHRlbmRzIFdpdGhSb3V0ZXJQcm9wcyxcbiAgQyA9IE5leHRQYWdlQ29udGV4dFxuPihcbiAgQ29tcG9zZWRDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPEMsIGFueSwgUD5cbik6IFJlYWN0LkNvbXBvbmVudFR5cGU8RXhjbHVkZVJvdXRlclByb3BzPFA+PiB7XG4gIGZ1bmN0aW9uIFdpdGhSb3V0ZXJXcmFwcGVyKHByb3BzOiBhbnkpOiBKU1guRWxlbWVudCB7XG4gICAgcmV0dXJuIDxDb21wb3NlZENvbXBvbmVudCByb3V0ZXI9e3VzZVJvdXRlcigpfSB7Li4ucHJvcHN9IC8+XG4gIH1cblxuICBXaXRoUm91dGVyV3JhcHBlci5nZXRJbml0aWFsUHJvcHMgPSBDb21wb3NlZENvbXBvbmVudC5nZXRJbml0aWFsUHJvcHNcbiAgLy8gVGhpcyBpcyBuZWVkZWQgdG8gYWxsb3cgY2hlY2tpbmcgZm9yIGN1c3RvbSBnZXRJbml0aWFsUHJvcHMgaW4gX2FwcFxuICA7KFdpdGhSb3V0ZXJXcmFwcGVyIGFzIGFueSkub3JpZ0dldEluaXRpYWxQcm9wcyA9IChDb21wb3NlZENvbXBvbmVudCBhcyBhbnkpLm9yaWdHZXRJbml0aWFsUHJvcHNcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBuYW1lID1cbiAgICAgIENvbXBvc2VkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvc2VkQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nXG4gICAgV2l0aFJvdXRlcldyYXBwZXIuZGlzcGxheU5hbWUgPSBgd2l0aFJvdXRlcigke25hbWV9KWBcbiAgfVxuXG4gIHJldHVybiBXaXRoUm91dGVyV3JhcHBlclxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/with-router.js\n");

/***/ }),

/***/ "./node_modules/next/dist/compiled/path-to-regexp/index.js":
/*!*****************************************!*\
  !*** (webpack)/path-to-regexp/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \" + i);\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \" + j);\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \" + j);\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \" + i);\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \" + i);\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\" + escapeString(options.delimiter || \"/#?\") + \"]+?\";\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \" + nextType + \" at \" + index + \", expected \" + type);\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        // tslint:disable-next-line\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\nexports.parse = parse;\n/**\n * Compile a string to a template function for the path.\n */\nfunction compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\nexports.compile = compile;\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n        }\n        return path;\n    };\n}\nexports.tokensToFunction = tokensToFunction;\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nfunction match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\nexports.match = match;\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nfunction regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            // tslint:disable-next-line\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\nexports.regexpToFunction = regexpToFunction;\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    // Use a negative lookahead to match only capturing groups.\n    var groups = path.source.match(/\\((?!\\?)/g);\n    if (groups) {\n        for (var i = 0; i < groups.length; i++) {\n            keys.push({\n                name: i,\n                prefix: \"\",\n                suffix: \"\",\n                modifier: \"\",\n                pattern: \"\"\n            });\n        }\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;\n    var endsWith = \"[\" + escapeString(options.endsWith || \"\") + \"]|$\";\n    var delimiter = \"[\" + escapeString(options.delimiter || \"/#?\") + \"]\";\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\" + prefix + \"((?:\" + token.pattern + \")(?:\" + suffix + prefix + \"(?:\" + token.pattern + \"))*)\" + suffix + \")\" + mod;\n                    }\n                    else {\n                        route += \"(?:\" + prefix + \"(\" + token.pattern + \")\" + suffix + \")\" + token.modifier;\n                    }\n                }\n                else {\n                    route += \"(\" + token.pattern + \")\" + token.modifier;\n                }\n            }\n            else {\n                route += \"(?:\" + prefix + suffix + \")\" + token.modifier;\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += delimiter + \"?\";\n        route += !options.endsWith ? \"$\" : \"(?=\" + endsWith + \")\";\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n            : // tslint:disable-next-line\n                endToken === undefined;\n        if (!strict) {\n            route += \"(?:\" + delimiter + \"(?=\" + endsWith + \"))?\";\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\" + delimiter + \"|\" + endsWith + \")\";\n        }\n    }\n    return new RegExp(route, flags(options));\n}\nexports.tokensToRegexp = tokensToRegexp;\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nfunction pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\nexports.pathToRegexp = pathToRegexp;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzP2Y3NDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOENBQThDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvREFBb0Q7QUFDN0U7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix5QkFBeUIsMENBQTBDO0FBQ25FO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIseUJBQXlCLDJDQUEyQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNDQUFzQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBNEM7QUFDckU7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBDQUEwQztBQUMvRDtBQUNBLGlCQUFpQixtQ0FBbUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQSxvRUFBb0UsVUFBVSxFQUFFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDLG9FQUFvRSxVQUFVLEVBQUU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaURBQWlELEVBQUU7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0Msd09BQXdPLFVBQVUsRUFBRTtBQUNwUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2REFBNkQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFRva2VuaXplIGlucHV0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gbGV4ZXIoc3RyKSB7XG4gICAgdmFyIHRva2VucyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBzdHJbaV07XG4gICAgICAgIGlmIChjaGFyID09PSBcIipcIiB8fCBjaGFyID09PSBcIitcIiB8fCBjaGFyID09PSBcIj9cIikge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIk1PRElGSUVSXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJFU0NBUEVEX0NIQVJcIiwgaW5kZXg6IGkrKywgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwie1wiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiT1BFTlwiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwifVwiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiQ0xPU0VcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIjpcIikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGogPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaik7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIGAwLTlgXG4gICAgICAgICAgICAgICAgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYEEtWmBcbiAgICAgICAgICAgICAgICAgICAgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYGEtemBcbiAgICAgICAgICAgICAgICAgICAgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIGBfYFxuICAgICAgICAgICAgICAgICAgICBjb2RlID09PSA5NSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lICs9IHN0cltqKytdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1pc3NpbmcgcGFyYW1ldGVyIG5hbWUgYXQgXCIgKyBpKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJOQU1FXCIsIGluZGV4OiBpLCB2YWx1ZTogbmFtZSB9KTtcbiAgICAgICAgICAgIGkgPSBqO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAxO1xuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGogPSBpICsgMTtcbiAgICAgICAgICAgIGlmIChzdHJbal0gPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhdHRlcm4gY2Fubm90IHN0YXJ0IHdpdGggXFxcIj9cXFwiIGF0IFwiICsgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaiA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyW2pdID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHN0cltqKytdICsgc3RyW2orK107XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RyW2pdID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0cltqXSA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cltqICsgMV0gIT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FwdHVyaW5nIGdyb3VwcyBhcmUgbm90IGFsbG93ZWQgYXQgXCIgKyBqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHN0cltqKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmJhbGFuY2VkIHBhdHRlcm4gYXQgXCIgKyBpKTtcbiAgICAgICAgICAgIGlmICghcGF0dGVybilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzc2luZyBwYXR0ZXJuIGF0IFwiICsgaSk7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiUEFUVEVSTlwiLCBpbmRleDogaSwgdmFsdWU6IHBhdHRlcm4gfSk7XG4gICAgICAgICAgICBpID0gajtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJDSEFSXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgfVxuICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJFTkRcIiwgaW5kZXg6IGksIHZhbHVlOiBcIlwiIH0pO1xuICAgIHJldHVybiB0b2tlbnM7XG59XG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqL1xuZnVuY3Rpb24gcGFyc2Uoc3RyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgdG9rZW5zID0gbGV4ZXIoc3RyKTtcbiAgICB2YXIgX2EgPSBvcHRpb25zLnByZWZpeGVzLCBwcmVmaXhlcyA9IF9hID09PSB2b2lkIDAgPyBcIi4vXCIgOiBfYTtcbiAgICB2YXIgZGVmYXVsdFBhdHRlcm4gPSBcIlteXCIgKyBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgXCIvIz9cIikgKyBcIl0rP1wiO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIga2V5ID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHBhdGggPSBcIlwiO1xuICAgIHZhciB0cnlDb25zdW1lID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgaWYgKGkgPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tpXS50eXBlID09PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRva2Vuc1tpKytdLnZhbHVlO1xuICAgIH07XG4gICAgdmFyIG11c3RDb25zdW1lID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdHJ5Q29uc3VtZSh0eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhciBfYSA9IHRva2Vuc1tpXSwgbmV4dFR5cGUgPSBfYS50eXBlLCBpbmRleCA9IF9hLmluZGV4O1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBcIiArIG5leHRUeXBlICsgXCIgYXQgXCIgKyBpbmRleCArIFwiLCBleHBlY3RlZCBcIiArIHR5cGUpO1xuICAgIH07XG4gICAgdmFyIGNvbnN1bWVUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgd2hpbGUgKCh2YWx1ZSA9IHRyeUNvbnN1bWUoXCJDSEFSXCIpIHx8IHRyeUNvbnN1bWUoXCJFU0NBUEVEX0NIQVJcIikpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHdoaWxlIChpIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICB2YXIgY2hhciA9IHRyeUNvbnN1bWUoXCJDSEFSXCIpO1xuICAgICAgICB2YXIgbmFtZSA9IHRyeUNvbnN1bWUoXCJOQU1FXCIpO1xuICAgICAgICB2YXIgcGF0dGVybiA9IHRyeUNvbnN1bWUoXCJQQVRURVJOXCIpO1xuICAgICAgICBpZiAobmFtZSB8fCBwYXR0ZXJuKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gY2hhciB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKHByZWZpeGVzLmluZGV4T2YocHJlZml4KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IHByZWZpeDtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgICBwYXRoID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lIHx8IGtleSsrLFxuICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgICAgIHN1ZmZpeDogXCJcIixcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuIHx8IGRlZmF1bHRQYXR0ZXJuLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyOiB0cnlDb25zdW1lKFwiTU9ESUZJRVJcIikgfHwgXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBjaGFyIHx8IHRyeUNvbnN1bWUoXCJFU0NBUEVEX0NIQVJcIik7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcGF0aCArPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXRoKTtcbiAgICAgICAgICAgIHBhdGggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVuID0gdHJ5Q29uc3VtZShcIk9QRU5cIik7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0cnlDb25zdW1lKFwiTkFNRVwiKSB8fCBcIlwiO1xuICAgICAgICAgICAgdmFyIHBhdHRlcm5fMSA9IHRyeUNvbnN1bWUoXCJQQVRURVJOXCIpIHx8IFwiXCI7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgIG11c3RDb25zdW1lKFwiQ0xPU0VcIik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZV8xIHx8IChwYXR0ZXJuXzEgPyBrZXkrKyA6IFwiXCIpLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IG5hbWVfMSAmJiAhcGF0dGVybl8xID8gZGVmYXVsdFBhdHRlcm4gOiBwYXR0ZXJuXzEsXG4gICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBzdWZmaXgsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IHRyeUNvbnN1bWUoXCJNT0RJRklFUlwiKSB8fCBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG11c3RDb25zdW1lKFwiRU5EXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICovXG5mdW5jdGlvbiBjb21waWxlKHN0ciwgb3B0aW9ucykge1xuICAgIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucyksIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZTtcbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24odG9rZW5zLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgcmVGbGFncyA9IGZsYWdzKG9wdGlvbnMpO1xuICAgIHZhciBfYSA9IG9wdGlvbnMuZW5jb2RlLCBlbmNvZGUgPSBfYSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0gOiBfYSwgX2IgPSBvcHRpb25zLnZhbGlkYXRlLCB2YWxpZGF0ZSA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2I7XG4gICAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gICAgdmFyIG1hdGNoZXMgPSB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHRva2VuLnBhdHRlcm4gKyBcIikkXCIsIHJlRmxhZ3MpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBwYXRoID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IHRva2VuO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0YSA/IGRhdGFbdG9rZW4ubmFtZV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgb3B0aW9uYWwgPSB0b2tlbi5tb2RpZmllciA9PT0gXCI/XCIgfHwgdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiO1xuICAgICAgICAgICAgdmFyIHJlcGVhdCA9IHRva2VuLm1vZGlmaWVyID09PSBcIipcIiB8fCB0b2tlbi5tb2RpZmllciA9PT0gXCIrXCI7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcGVhdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBub3QgcmVwZWF0LCBidXQgZ290IGFuIGFycmF5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25hbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBub3QgYmUgZW1wdHlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0sIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlICYmICFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhbGwgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBtYXRjaCBcXFwiXCIgKyB0b2tlbi5wYXR0ZXJuICsgXCJcXFwiLCBidXQgZ290IFxcXCJcIiArIHNlZ21lbnQgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50ICsgdG9rZW4uc3VmZml4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBlbmNvZGUoU3RyaW5nKHZhbHVlKSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZSAmJiAhbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIG1hdGNoIFxcXCJcIiArIHRva2VuLnBhdHRlcm4gKyBcIlxcXCIsIGJ1dCBnb3QgXFxcIlwiICsgc2VnbWVudCArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50ICsgdG9rZW4uc3VmZml4O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbmFsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHR5cGVPZk1lc3NhZ2UgPSByZXBlYXQgPyBcImFuIGFycmF5XCIgOiBcImEgc3RyaW5nXCI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBiZSBcIiArIHR5cGVPZk1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG59XG5leHBvcnRzLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uO1xuLyoqXG4gKiBDcmVhdGUgcGF0aCBtYXRjaCBmdW5jdGlvbiBmcm9tIGBwYXRoLXRvLXJlZ2V4cGAgc3BlYy5cbiAqL1xuZnVuY3Rpb24gbWF0Y2goc3RyLCBvcHRpb25zKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICB2YXIgcmUgPSBwYXRoVG9SZWdleHAoc3RyLCBrZXlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcmVnZXhwVG9GdW5jdGlvbihyZSwga2V5cywgb3B0aW9ucyk7XG59XG5leHBvcnRzLm1hdGNoID0gbWF0Y2g7XG4vKipcbiAqIENyZWF0ZSBhIHBhdGggbWF0Y2ggZnVuY3Rpb24gZnJvbSBgcGF0aC10by1yZWdleHBgIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9GdW5jdGlvbihyZSwga2V5cywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIF9hID0gb3B0aW9ucy5kZWNvZGUsIGRlY29kZSA9IF9hID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9hO1xuICAgIHJldHVybiBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICAgICAgdmFyIG0gPSByZS5leGVjKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCFtKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgcGF0aCA9IG1bMF0sIGluZGV4ID0gbS5pbmRleDtcbiAgICAgICAgdmFyIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgaWYgKG1baV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaSAtIDFdO1xuICAgICAgICAgICAgaWYgKGtleS5tb2RpZmllciA9PT0gXCIqXCIgfHwga2V5Lm1vZGlmaWVyID09PSBcIitcIikge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trZXkubmFtZV0gPSBtW2ldLnNwbGl0KGtleS5wcmVmaXggKyBrZXkuc3VmZml4KS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGUodmFsdWUsIGtleSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5Lm5hbWVdID0gZGVjb2RlKG1baV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwYXRoOiBwYXRoLCBpbmRleDogaW5kZXgsIHBhcmFtczogcGFyYW1zIH07XG4gICAgfTtcbn1cbmV4cG9ydHMucmVnZXhwVG9GdW5jdGlvbiA9IHJlZ2V4cFRvRnVuY3Rpb247XG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18L1xcXFxdKS9nLCBcIlxcXFwkMVwiKTtcbn1cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZmxhZ3Mob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuc2Vuc2l0aXZlID8gXCJcIiA6IFwiaVwiO1xufVxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIGtleXMpIHtcbiAgICBpZiAoIWtleXMpXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gICAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpO1xuICAgIGlmIChncm91cHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGtleXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogaSxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IFwiXCIsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyOiBcIlwiLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cChwYXRocywga2V5cywgb3B0aW9ucykge1xuICAgIHZhciBwYXJ0cyA9IHBhdGhzLm1hcChmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gcGF0aFRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpLnNvdXJjZTsgfSk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCIoPzpcIiArIHBhcnRzLmpvaW4oXCJ8XCIpICsgXCIpXCIsIGZsYWdzKG9wdGlvbnMpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdG9rZW5zVG9SZWdleHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ2V4cCh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IG9wdGlvbnMuc3RyaWN0LCBzdHJpY3QgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYSwgX2IgPSBvcHRpb25zLnN0YXJ0LCBzdGFydCA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIF9jID0gb3B0aW9ucy5lbmQsIGVuZCA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gb3B0aW9ucy5lbmNvZGUsIGVuY29kZSA9IF9kID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9kO1xuICAgIHZhciBlbmRzV2l0aCA9IFwiW1wiICsgZXNjYXBlU3RyaW5nKG9wdGlvbnMuZW5kc1dpdGggfHwgXCJcIikgKyBcIl18JFwiO1xuICAgIHZhciBkZWxpbWl0ZXIgPSBcIltcIiArIGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCBcIi8jP1wiKSArIFwiXVwiO1xuICAgIHZhciByb3V0ZSA9IHN0YXJ0ID8gXCJeXCIgOiBcIlwiO1xuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gICAgZm9yICh2YXIgX2kgPSAwLCB0b2tlbnNfMSA9IHRva2VuczsgX2kgPCB0b2tlbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zXzFbX2ldO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcoZW5jb2RlKHRva2VuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKGVuY29kZSh0b2tlbi5wcmVmaXgpKTtcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSBlc2NhcGVTdHJpbmcoZW5jb2RlKHRva2VuLnN1ZmZpeCkpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cylcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZml4IHx8IHN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4ubW9kaWZpZXIgPT09IFwiK1wiIHx8IHRva2VuLm1vZGlmaWVyID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZCA9IHRva2VuLm1vZGlmaWVyID09PSBcIipcIiA/IFwiP1wiIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBwcmVmaXggKyBcIigoPzpcIiArIHRva2VuLnBhdHRlcm4gKyBcIikoPzpcIiArIHN1ZmZpeCArIHByZWZpeCArIFwiKD86XCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpKSopXCIgKyBzdWZmaXggKyBcIilcIiArIG1vZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBwcmVmaXggKyBcIihcIiArIHRva2VuLnBhdHRlcm4gKyBcIilcIiArIHN1ZmZpeCArIFwiKVwiICsgdG9rZW4ubW9kaWZpZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKFwiICsgdG9rZW4ucGF0dGVybiArIFwiKVwiICsgdG9rZW4ubW9kaWZpZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIiArIHByZWZpeCArIHN1ZmZpeCArIFwiKVwiICsgdG9rZW4ubW9kaWZpZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZCkge1xuICAgICAgICBpZiAoIXN0cmljdClcbiAgICAgICAgICAgIHJvdXRlICs9IGRlbGltaXRlciArIFwiP1wiO1xuICAgICAgICByb3V0ZSArPSAhb3B0aW9ucy5lbmRzV2l0aCA/IFwiJFwiIDogXCIoPz1cIiArIGVuZHNXaXRoICsgXCIpXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZW5kVG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgaXNFbmREZWxpbWl0ZWQgPSB0eXBlb2YgZW5kVG9rZW4gPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gZGVsaW1pdGVyLmluZGV4T2YoZW5kVG9rZW5bZW5kVG9rZW4ubGVuZ3RoIC0gMV0pID4gLTFcbiAgICAgICAgICAgIDogLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgZW5kVG9rZW4gPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBkZWxpbWl0ZXIgKyBcIig/PVwiICsgZW5kc1dpdGggKyBcIikpP1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNFbmREZWxpbWl0ZWQpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IFwiKD89XCIgKyBkZWxpbWl0ZXIgKyBcInxcIiArIGVuZHNXaXRoICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocm91dGUsIGZsYWdzKG9wdGlvbnMpKTtcbn1cbmV4cG9ydHMudG9rZW5zVG9SZWdleHAgPSB0b2tlbnNUb1JlZ2V4cDtcbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAgICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIGtleXMpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKVxuICAgICAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gc3RyaW5nVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucyk7XG59XG5leHBvcnRzLnBhdGhUb1JlZ2V4cCA9IHBhdGhUb1JlZ2V4cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/path-to-regexp/index.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.normalizeLocalePath = normalizeLocalePath;\n\nfunction normalizeLocalePath(pathname, locales) {\n  let detectedLocale; // first item will be empty string from splitting at first char\n\n  const pathnameParts = pathname.split('/');\n  (locales || []).some(locale => {\n    if (pathnameParts[1].toLowerCase() === locale.toLowerCase()) {\n      detectedLocale = locale;\n      pathnameParts.splice(1, 1);\n      pathname = pathnameParts.join('/') || '/';\n      return true;\n    }\n\n    return false;\n  });\n  return {\n    pathname,\n    detectedLocale\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoLnRzP2U4ZWIiXSwibmFtZXMiOlsicGF0aG5hbWVQYXJ0cyIsInBhdGhuYW1lIiwibG9jYWxlcyIsImxvY2FsZSIsImRldGVjdGVkTG9jYWxlIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFPLGdEQU1MO0FBQ0EscUJBREEsQ0FFQTs7QUFDQSxRQUFNQSxhQUFhLEdBQUdDLFFBQVEsQ0FBUkEsTUFBdEIsR0FBc0JBLENBQXRCO0FBRUMsR0FBQ0MsT0FBTyxJQUFSLFNBQXNCQyxNQUFELElBQVk7QUFDaEMsUUFBSUgsYUFBYSxDQUFiQSxDQUFhLENBQWJBLG1CQUFtQ0csTUFBTSxDQUE3QyxXQUF1Q0EsRUFBdkMsRUFBNkQ7QUFDM0RDLG9CQUFjLEdBQWRBO0FBQ0FKLG1CQUFhLENBQWJBO0FBQ0FDLGNBQVEsR0FBR0QsYUFBYSxDQUFiQSxhQUFYQztBQUNBO0FBRUY7O0FBQUE7QUFQRDtBQVVELFNBQU87QUFBQTtBQUFQO0FBQU8sR0FBUDtBQUlEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9uZXh0LXNlcnZlci9saWIvaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlUGF0aChcbiAgcGF0aG5hbWU6IHN0cmluZyxcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4pOiB7XG4gIGRldGVjdGVkTG9jYWxlPzogc3RyaW5nXG4gIHBhdGhuYW1lOiBzdHJpbmdcbn0ge1xuICBsZXQgZGV0ZWN0ZWRMb2NhbGU6IHN0cmluZyB8IHVuZGVmaW5lZFxuICAvLyBmaXJzdCBpdGVtIHdpbGwgYmUgZW1wdHkgc3RyaW5nIGZyb20gc3BsaXR0aW5nIGF0IGZpcnN0IGNoYXJcbiAgY29uc3QgcGF0aG5hbWVQYXJ0cyA9IHBhdGhuYW1lLnNwbGl0KCcvJylcblxuICA7KGxvY2FsZXMgfHwgW10pLnNvbWUoKGxvY2FsZSkgPT4ge1xuICAgIGlmIChwYXRobmFtZVBhcnRzWzFdLnRvTG93ZXJDYXNlKCkgPT09IGxvY2FsZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBkZXRlY3RlZExvY2FsZSA9IGxvY2FsZVxuICAgICAgcGF0aG5hbWVQYXJ0cy5zcGxpY2UoMSwgMSlcbiAgICAgIHBhdGhuYW1lID0gcGF0aG5hbWVQYXJ0cy5qb2luKCcvJykgfHwgJy8nXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfSlcblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lLFxuICAgIGRldGVjdGVkTG9jYWxlLFxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/mitt.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/mitt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.default = mitt;\n/*\nMIT License\nCopyright (c) Jason Miller (https://jasonformat.com/)\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n// This file is based on https://github.com/developit/mitt/blob/v1.1.3/src/index.js\n// It's been edited for the needs of this script\n// See the LICENSE at the top of the file\n\nfunction mitt() {\n  const all = Object.create(null);\n  return {\n    on(type, handler) {\n      ;\n      (all[type] || (all[type] = [])).push(handler);\n    },\n\n    off(type, handler) {\n      if (all[type]) {\n        all[type].splice(all[type].indexOf(handler) >>> 0, 1);\n      }\n    },\n\n    emit(type, ...evts) {\n      // eslint-disable-next-line array-callback-return\n      ;\n      (all[type] || []).slice().map(handler => {\n        handler(...evts);\n      });\n    }\n\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL21pdHQudHM/ZjRlYyJdLCJuYW1lcyI6WyJhbGwiLCJPYmplY3QiLCJvbiIsIm9mZiIsImVtaXQiLCJoYW5kbGVyIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7O0FBVWUsZ0JBQTZCO0FBQzFDLFFBQU1BLEdBQStCLEdBQUdDLE1BQU0sQ0FBTkEsT0FBeEMsSUFBd0NBLENBQXhDO0FBRUEsU0FBTztBQUNMQyxNQUFFLGdCQUFpQztBQUNqQztBQUFDLE9BQUNGLEdBQUcsQ0FBSEEsSUFBRyxDQUFIQSxLQUFjQSxHQUFHLENBQUhBLElBQUcsQ0FBSEEsR0FBZixFQUFDQSxDQUFEO0FBRkU7O0FBS0xHLE9BQUcsZ0JBQWlDO0FBQ2xDLFVBQUlILEdBQUcsQ0FBUCxJQUFPLENBQVAsRUFBZTtBQUNiQSxXQUFHLENBQUhBLElBQUcsQ0FBSEEsUUFBaUJBLEdBQUcsQ0FBSEEsSUFBRyxDQUFIQSxzQkFBakJBO0FBRUg7QUFUSTs7QUFXTEksUUFBSSxPQUFlLEdBQWYsTUFBK0I7QUFDakM7QUFDQTtBQUFDLE9BQUNKLEdBQUcsQ0FBSEEsSUFBRyxDQUFIQSxJQUFELGdCQUErQkssT0FBRCxJQUFzQjtBQUNuREEsZUFBTyxDQUFDLEdBQVJBLElBQU8sQ0FBUEE7QUFERDtBQWJMOztBQUFPLEdBQVA7QUFrQkQiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi9taXR0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgSmFzb24gTWlsbGVyIChodHRwczovL2phc29uZm9ybWF0LmNvbS8pXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbi8vIFRoaXMgZmlsZSBpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L21pdHQvYmxvYi92MS4xLjMvc3JjL2luZGV4LmpzXG4vLyBJdCdzIGJlZW4gZWRpdGVkIGZvciB0aGUgbmVlZHMgb2YgdGhpcyBzY3JpcHRcbi8vIFNlZSB0aGUgTElDRU5TRSBhdCB0aGUgdG9wIG9mIHRoZSBmaWxlXG5cbnR5cGUgSGFuZGxlciA9ICguLi5ldnRzOiBhbnlbXSkgPT4gdm9pZFxuXG5leHBvcnQgdHlwZSBNaXR0RW1pdHRlciA9IHtcbiAgb24odHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKTogdm9pZFxuICBvZmYodHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKTogdm9pZFxuICBlbWl0KHR5cGU6IHN0cmluZywgLi4uZXZ0czogYW55W10pOiB2b2lkXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1pdHQoKTogTWl0dEVtaXR0ZXIge1xuICBjb25zdCBhbGw6IHsgW3M6IHN0cmluZ106IEhhbmRsZXJbXSB9ID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIHJldHVybiB7XG4gICAgb24odHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKSB7XG4gICAgICA7KGFsbFt0eXBlXSB8fCAoYWxsW3R5cGVdID0gW10pKS5wdXNoKGhhbmRsZXIpXG4gICAgfSxcblxuICAgIG9mZih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpIHtcbiAgICAgIGlmIChhbGxbdHlwZV0pIHtcbiAgICAgICAgYWxsW3R5cGVdLnNwbGljZShhbGxbdHlwZV0uaW5kZXhPZihoYW5kbGVyKSA+Pj4gMCwgMSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW1pdCh0eXBlOiBzdHJpbmcsIC4uLmV2dHM6IGFueVtdKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgICA7KGFsbFt0eXBlXSB8fCBbXSkuc2xpY2UoKS5tYXAoKGhhbmRsZXI6IEhhbmRsZXIpID0+IHtcbiAgICAgICAgaGFuZGxlciguLi5ldnRzKVxuICAgICAgfSlcbiAgICB9LFxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/mitt.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/router.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.getDomainLocale = getDomainLocale;\nexports.addLocale = addLocale;\nexports.delLocale = delLocale;\nexports.hasBasePath = hasBasePath;\nexports.addBasePath = addBasePath;\nexports.delBasePath = delBasePath;\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports.default = void 0;\n\nvar _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\n\nvar _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\n\nvar _denormalizePagePath = __webpack_require__(/*! ../../server/denormalize-page-path */ \"./node_modules/next/dist/next-server/server/denormalize-page-path.js\");\n\nvar _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js\");\n\nvar _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/next-server/lib/mitt.js\"));\n\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/next-server/lib/utils.js\");\n\nvar _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js\");\n\nvar _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js\");\n\nvar _querystring = __webpack_require__(/*! ./utils/querystring */ \"./node_modules/next/dist/next-server/lib/router/utils/querystring.js\");\n\nvar _resolveRewrites = _interopRequireDefault(__webpack_require__(/*! ./utils/resolve-rewrites */ \"./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js\"));\n\nvar _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js\");\n\nvar _routeRegex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/next-server/lib/router/utils/route-regex.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/* global __NEXT_DATA__ */\n// tslint:disable:no-console\n\n\nlet detectDomainLocale;\n\nif (false) {}\n\nconst basePath =  false || '';\n\nfunction buildCancellationError() {\n  return Object.assign(new Error('Route Cancelled'), {\n    cancelled: true\n  });\n}\n\nfunction addPathPrefix(path, prefix) {\n  return prefix && path.startsWith('/') ? path === '/' ? (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(prefix) : `${prefix}${pathNoQueryHash(path) === '/' ? path.substring(1) : path}` : path;\n}\n\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n  if (false) {}\n\n  return false;\n}\n\nfunction addLocale(path, locale, defaultLocale) {\n  if (false) {}\n\n  return path;\n}\n\nfunction delLocale(path, locale) {\n  if (false) {}\n\n  return path;\n}\n\nfunction pathNoQueryHash(path) {\n  const queryIndex = path.indexOf('?');\n  const hashIndex = path.indexOf('#');\n\n  if (queryIndex > -1 || hashIndex > -1) {\n    path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);\n  }\n\n  return path;\n}\n\nfunction hasBasePath(path) {\n  path = pathNoQueryHash(path);\n  return path === basePath || path.startsWith(basePath + '/');\n}\n\nfunction addBasePath(path) {\n  // we only add the basepath on relative urls\n  return addPathPrefix(path, basePath);\n}\n\nfunction delBasePath(path) {\n  path = path.slice(basePath.length);\n  if (!path.startsWith('/')) path = `/${path}`;\n  return path;\n}\n/**\n* Detects whether a given url is routable by the Next.js router (browser only).\n*/\n\n\nfunction isLocalURL(url) {\n  // prevent a hydration mismatch on href for url with anchor refs\n  if (url.startsWith('/') || url.startsWith('#')) return true;\n\n  try {\n    // absolute urls can be local if they are on the same origin\n    const locationOrigin = (0, _utils.getLocationOrigin)();\n    const resolved = new URL(url, locationOrigin);\n    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction interpolateAs(route, asPathname, query) {\n  let interpolatedRoute = '';\n  const dynamicRegex = (0, _routeRegex.getRouteRegex)(route);\n  const dynamicGroups = dynamicRegex.groups;\n  const dynamicMatches = // Try to match the dynamic route against the asPath\n  (asPathname !== route ? (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href\n  // TODO: should this take priority; also need to change in the router.\n  query;\n  interpolatedRoute = route;\n  const params = Object.keys(dynamicGroups);\n\n  if (!params.every(param => {\n    let value = dynamicMatches[param] || '';\n    const {\n      repeat,\n      optional\n    } = dynamicGroups[param]; // support single-level catch-all\n    // TODO: more robust handling for user-error (passing `/`)\n\n    let replaced = `[${repeat ? '...' : ''}${param}]`;\n\n    if (optional) {\n      replaced = `${!value ? '/' : ''}[${replaced}]`;\n    }\n\n    if (repeat && !Array.isArray(value)) value = [value];\n    return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present\n    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map( // these values should be fully encoded instead of just\n    // path delimiter escaped since they are being inserted\n    // into the URL and we expect URL encoded segments\n    // when parsing dynamic route params\n    segment => encodeURIComponent(segment)).join('/') : encodeURIComponent(value)) || '/');\n  })) {\n    interpolatedRoute = ''; // did not satisfy all requirements\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n  }\n\n  return {\n    params,\n    result: interpolatedRoute\n  };\n}\n\nfunction omitParmsFromQuery(query, params) {\n  const filteredQuery = {};\n  Object.keys(query).forEach(key => {\n    if (!params.includes(key)) {\n      filteredQuery[key] = query[key];\n    }\n  });\n  return filteredQuery;\n}\n/**\n* Resolves a given hyperlink with a certain router state (basePath not included).\n* Preserves absolute urls.\n*/\n\n\nfunction resolveHref(currentPath, href, resolveAs) {\n  // we use a dummy base url for relative urls\n  const base = new URL(currentPath, 'http://n');\n  const urlAsString = typeof href === 'string' ? href : (0, _utils.formatWithValidation)(href); // Return because it cannot be routed by the Next.js router\n\n  if (!isLocalURL(urlAsString)) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n\n  try {\n    const finalUrl = new URL(urlAsString, base);\n    finalUrl.pathname = (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(finalUrl.pathname);\n    let interpolatedAs = '';\n\n    if ((0, _isDynamic.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n      const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n      const {\n        result,\n        params\n      } = interpolateAs(finalUrl.pathname, finalUrl.pathname, query);\n\n      if (result) {\n        interpolatedAs = (0, _utils.formatWithValidation)({\n          pathname: result,\n          hash: finalUrl.hash,\n          query: omitParmsFromQuery(query, params)\n        });\n      }\n    } // if the origin didn't change, it means we received a relative href\n\n\n    const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;\n  } catch (_) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n}\n\nfunction stripOrigin(url) {\n  const origin = (0, _utils.getLocationOrigin)();\n  return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\n\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  let [resolvedHref, resolvedAs] = resolveHref(router.pathname, url, true);\n  const origin = (0, _utils.getLocationOrigin)();\n  const hrefHadOrigin = resolvedHref.startsWith(origin);\n  const asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n  resolvedHref = stripOrigin(resolvedHref);\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n  const preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);\n  const preparedAs = as ? stripOrigin(resolveHref(router.pathname, as)) : resolvedAs || resolvedHref;\n  return {\n    url: preparedUrl,\n    as: asHadOrigin ? preparedAs : addBasePath(preparedAs)\n  };\n}\n\nfunction resolveDynamicRoute(pathname, pages) {\n  const cleanPathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)((0, _denormalizePagePath.denormalizePagePath)(pathname));\n\n  if (cleanPathname === '/404' || cleanPathname === '/_error') {\n    return pathname;\n  } // handle resolving href for dynamic routes\n\n\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some(page => {\n      if ((0, _isDynamic.isDynamicRoute)(page) && (0, _routeRegex.getRouteRegex)(page).re.test(cleanPathname)) {\n        pathname = page;\n        return true;\n      }\n    });\n  }\n\n  return (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);\n}\n\nconst manualScrollRestoration =  false && false;\nconst SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\n\nfunction fetchRetry(url, attempts) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` wont send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: 'same-origin'\n  }).then(res => {\n    if (!res.ok) {\n      if (attempts > 1 && res.status >= 500) {\n        return fetchRetry(url, attempts - 1);\n      }\n\n      if (res.status === 404) {\n        return res.json().then(data => {\n          if (data.notFound) {\n            return {\n              notFound: SSG_DATA_NOT_FOUND\n            };\n          }\n\n          throw new Error(`Failed to load static props`);\n        });\n      }\n\n      throw new Error(`Failed to load static props`);\n    }\n\n    return res.json();\n  });\n}\n\nfunction fetchNextData(dataHref, isServerRender) {\n  return fetchRetry(dataHref, isServerRender ? 3 : 1).catch(err => {\n    // We should only trigger a server-side transition if this was caused\n    // on a client-side transition. Otherwise, we'd get into an infinite\n    // loop.\n    if (!isServerRender) {\n      (0, _routeLoader.markAssetError)(err);\n    }\n\n    throw err;\n  });\n}\n\nclass Router {\n  /**\n  * Map of all components loaded in `Router`\n  */\n  // Static Data Cache\n  // In-flight Server Data Requests, for deduping\n  constructor(_pathname, _query, _as, {\n    initialProps,\n    pageLoader,\n    App,\n    wrapApp,\n    Component,\n    err,\n    subscription,\n    isFallback,\n    locale,\n    locales,\n    defaultLocale,\n    domainLocales,\n    isPreview\n  }) {\n    this.route = void 0;\n    this.pathname = void 0;\n    this.query = void 0;\n    this.asPath = void 0;\n    this.basePath = void 0;\n    this.components = void 0;\n    this.sdc = {};\n    this.sdr = {};\n    this.sub = void 0;\n    this.clc = void 0;\n    this.pageLoader = void 0;\n    this._bps = void 0;\n    this.events = void 0;\n    this._wrapApp = void 0;\n    this.isSsr = void 0;\n    this.isFallback = void 0;\n    this._inFlightRoute = void 0;\n    this._shallow = void 0;\n    this.locale = void 0;\n    this.locales = void 0;\n    this.defaultLocale = void 0;\n    this.domainLocales = void 0;\n    this.isReady = void 0;\n    this.isPreview = void 0;\n    this.isLocaleDomain = void 0;\n    this._idx = 0;\n\n    this.onPopState = e => {\n      const state = e.state;\n\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        const {\n          pathname,\n          query\n        } = this;\n        this.changeState('replaceState', (0, _utils.formatWithValidation)({\n          pathname: addBasePath(pathname),\n          query\n        }), (0, _utils.getURL)());\n        return;\n      }\n\n      if (!state.__N) {\n        return;\n      }\n\n      let forcedScroll;\n      const {\n        url,\n        as,\n        options,\n        idx\n      } = state;\n\n      if (false) {}\n\n      this._idx = idx;\n      const {\n        pathname\n      } = (0, _parseRelativeUrl.parseRelativeUrl)(url); // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n\n      if (this.isSsr && as === this.asPath && pathname === this.pathname) {\n        return;\n      } // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n\n\n      if (this._bps && !this._bps(state)) {\n        return;\n      }\n\n      this.change('replaceState', url, as, Object.assign({}, options, {\n        shallow: options.shallow && this._shallow,\n        locale: options.locale || this.defaultLocale\n      }), forcedScroll);\n    }; // represents the current component key\n\n\n    this.route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(_pathname); // set up the component cache (by route keys)\n\n    this.components = {}; // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n\n    if (_pathname !== '/_error') {\n      this.components[this.route] = {\n        Component,\n        initial: true,\n        props: initialProps,\n        err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP\n      };\n    }\n\n    this.components['/_app'] = {\n      Component: App,\n      styleSheets: [\n        /* /_app does not need its stylesheets managed */\n      ]\n    }; // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n\n    this.events = Router.events;\n    this.pageLoader = pageLoader;\n    this.pathname = _pathname;\n    this.query = _query; // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n\n    const autoExportDynamic = (0, _isDynamic.isDynamicRoute)(_pathname) && self.__NEXT_DATA__.autoExport;\n\n    this.asPath = autoExportDynamic ? _pathname : _as;\n    this.basePath = basePath;\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating\n    // back from external site\n\n    this.isSsr = true;\n    this.isFallback = isFallback;\n    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || !autoExportDynamic && !self.location.search);\n    this.isPreview = !!isPreview;\n    this.isLocaleDomain = false;\n\n    if (false) {}\n\n    if (false) {}\n  }\n\n  reload() {\n    window.location.reload();\n  }\n  /**\n  * Go back in history\n  */\n\n\n  back() {\n    window.history.back();\n  }\n  /**\n  * Performs a `pushState` with arguments\n  * @param url of the route\n  * @param as masks `url` for the browser\n  * @param options object you can define `shallow` and other options\n  */\n\n\n  push(url, as, options = {}) {\n    if (false) {}\n\n    ;\n    ({\n      url,\n      as\n    } = prepareUrlAs(this, url, as));\n    return this.change('pushState', url, as, options);\n  }\n  /**\n  * Performs a `replaceState` with arguments\n  * @param url of the route\n  * @param as masks `url` for the browser\n  * @param options object you can define `shallow` and other options\n  */\n\n\n  replace(url, as, options = {}) {\n    ;\n    ({\n      url,\n      as\n    } = prepareUrlAs(this, url, as));\n    return this.change('replaceState', url, as, options);\n  }\n\n  async change(method, url, as, options, forcedScroll) {\n    var _options$scroll;\n\n    if (!isLocalURL(url)) {\n      window.location.href = url;\n      return false;\n    } // for static pages with query params in the URL we delay\n    // marking the router ready until after the query is updated\n\n\n    if (options._h) {\n      this.isReady = true;\n    } // Default to scroll reset behavior unless explicitly specified to be\n    // `false`! This makes the behavior between using `Router#push` and a\n    // `<Link />` consistent.\n\n\n    options.scroll = !!((_options$scroll = options.scroll) != null ? _options$scroll : true);\n    let localeChange = options.locale !== this.locale;\n\n    if (false) { var _this$locales; }\n\n    if (!options._h) {\n      this.isSsr = false;\n    } // marking route changes as a navigation start entry\n\n\n    if (_utils.ST) {\n      performance.mark('routeChange');\n    }\n\n    const {\n      shallow = false\n    } = options;\n    const routeProps = {\n      shallow\n    };\n\n    if (this._inFlightRoute) {\n      this.abortComponentLoad(this._inFlightRoute, routeProps);\n    }\n\n    as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));\n    const cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);\n    this._inFlightRoute = as; // If the url change is only related to a hash change\n    // We should not proceed. We should only change the state.\n    // WARNING: `_h` is an internal option for handing Next.js client-side\n    // hydration. Your app should _never_ use this property. It may change at\n    // any time without notice.\n\n    if (!options._h && this.onlyAHashChange(cleanedAs)) {\n      this.asPath = cleanedAs;\n      Router.events.emit('hashChangeStart', as, routeProps); // TODO: do we need the resolved href when only a hash change?\n\n      this.changeState(method, url, as, options);\n      this.scrollToHash(cleanedAs);\n      this.notify(this.components[this.route], null);\n      Router.events.emit('hashChangeComplete', as, routeProps);\n      return true;\n    }\n\n    let parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);\n    let {\n      pathname,\n      query\n    } = parsed; // The build manifest needs to be loaded before auto-static dynamic pages\n    // get their query parameters to allow ensuring they can be parsed properly\n    // when rewritten to\n\n    let pages, rewrites;\n\n    try {\n      pages = await this.pageLoader.getPageList();\n      ({\n        __rewrites: rewrites\n      } = await (0, _routeLoader.getClientBuildManifest)());\n    } catch (err) {\n      // If we fail to resolve the page list or client-build manifest, we must\n      // do a server-side transition:\n      window.location.href = as;\n      return false;\n    } // If asked to change the current URL we should reload the current page\n    // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n    // We also need to set the method = replaceState always\n    // as this should not go into the history (That's how browsers work)\n    // We should compare the new asPath to the current asPath, not the url\n\n\n    if (!this.urlIsNew(cleanedAs) && !localeChange) {\n      method = 'replaceState';\n    } // we need to resolve the as value using rewrites for dynamic SSG\n    // pages to allow building the data URL correctly\n\n\n    let resolvedAs = as; // url and as should always be prefixed with basePath by this\n    // point by either next/link or router.push/replace so strip the\n    // basePath from the pathname to match the pages dir 1-to-1\n\n    pathname = pathname ? (0, _normalizeTrailingSlash.removePathTrailingSlash)(delBasePath(pathname)) : pathname;\n\n    if (pathname !== '/_error') {\n      if ( true && as.startsWith('/')) {\n        const rewritesResult = (0, _resolveRewrites.default)(addBasePath(addLocale(delBasePath(as), this.locale)), pages, rewrites, query, p => resolveDynamicRoute(p, pages), this.locales);\n        resolvedAs = rewritesResult.asPath;\n\n        if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n          // if this directly matches a page we need to update the href to\n          // allow the correct page chunk to be loaded\n          pathname = rewritesResult.resolvedHref;\n          parsed.pathname = pathname;\n          url = (0, _utils.formatWithValidation)(parsed);\n        }\n      } else {\n        parsed.pathname = resolveDynamicRoute(pathname, pages);\n\n        if (parsed.pathname !== pathname) {\n          pathname = parsed.pathname;\n          url = (0, _utils.formatWithValidation)(parsed);\n        }\n      }\n    }\n\n    const route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);\n\n    if (!isLocalURL(as)) {\n      if (true) {\n        throw new Error(`Invalid href: \"${url}\" and as: \"${as}\", received relative href and external as` + `\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as`);\n      }\n\n      window.location.href = as;\n      return false;\n    }\n\n    resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);\n\n    if ((0, _isDynamic.isDynamicRoute)(route)) {\n      const parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(resolvedAs);\n      const asPathname = parsedAs.pathname;\n      const routeRegex = (0, _routeRegex.getRouteRegex)(route);\n      const routeMatch = (0, _routeMatcher.getRouteMatcher)(routeRegex)(asPathname);\n      const shouldInterpolate = route === asPathname;\n      const interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};\n\n      if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n        const missingParams = Object.keys(routeRegex.groups).filter(param => !query[param]);\n\n        if (missingParams.length > 0) {\n          if (true) {\n            console.warn(`${shouldInterpolate ? `Interpolating href` : `Mismatching \\`as\\` and \\`href\\``} failed to manually provide ` + `the params: ${missingParams.join(', ')} in the \\`href\\`'s \\`query\\``);\n          }\n\n          throw new Error((shouldInterpolate ? `The provided \\`href\\` (${url}) value is missing query values (${missingParams.join(', ')}) to be interpolated properly. ` : `The provided \\`as\\` value (${asPathname}) is incompatible with the \\`href\\` value (${route}). `) + `Read more: https://nextjs.org/docs/messages/${shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'}`);\n        }\n      } else if (shouldInterpolate) {\n        as = (0, _utils.formatWithValidation)(Object.assign({}, parsedAs, {\n          pathname: interpolatedAs.result,\n          query: omitParmsFromQuery(query, interpolatedAs.params)\n        }));\n      } else {\n        // Merge params into `query`, overwriting any specified in search\n        Object.assign(query, routeMatch);\n      }\n    }\n\n    Router.events.emit('routeChangeStart', as, routeProps);\n\n    try {\n      var _self$__NEXT_DATA__$p, _self$__NEXT_DATA__$p2;\n\n      let routeInfo = await this.getRouteInfo(route, pathname, query, as, resolvedAs, routeProps);\n      let {\n        error,\n        props,\n        __N_SSG,\n        __N_SSP\n      } = routeInfo; // handle redirect on client-transition\n\n      if ((__N_SSG || __N_SSP) && props) {\n        if (props.pageProps && props.pageProps.__N_REDIRECT) {\n          const destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt\n          // client-navigation if it is falling back to hard navigation if\n          // it's not\n\n          if (destination.startsWith('/')) {\n            const parsedHref = (0, _parseRelativeUrl.parseRelativeUrl)(destination);\n            parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n\n            if (pages.includes(parsedHref.pathname)) {\n              const {\n                url: newUrl,\n                as: newAs\n              } = prepareUrlAs(this, destination, destination);\n              return this.change(method, newUrl, newAs, options);\n            }\n          }\n\n          window.location.href = destination;\n          return new Promise(() => {});\n        }\n\n        this.isPreview = !!props.__N_PREVIEW; // handle SSG data 404\n\n        if (props.notFound === SSG_DATA_NOT_FOUND) {\n          let notFoundRoute;\n\n          try {\n            await this.fetchComponent('/404');\n            notFoundRoute = '/404';\n          } catch (_) {\n            notFoundRoute = '/_error';\n          }\n\n          routeInfo = await this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, resolvedAs, {\n            shallow: false\n          });\n        }\n      }\n\n      Router.events.emit('beforeHistoryChange', as, routeProps);\n      this.changeState(method, url, as, options);\n\n      if (true) {\n        const appComp = this.components['/_app'].Component;\n        window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;\n      } // shallow routing is only allowed for same page URL changes.\n\n\n      const isValidShallowRoute = options.shallow && this.route === route;\n\n      if (options._h && pathname === '/_error' && ((_self$__NEXT_DATA__$p = self.__NEXT_DATA__.props) == null ? void 0 : (_self$__NEXT_DATA__$p2 = _self$__NEXT_DATA__$p.pageProps) == null ? void 0 : _self$__NEXT_DATA__$p2.statusCode) === 500 && props != null && props.pageProps) {\n        // ensure statusCode is still correct for static 500 page\n        // when updating query information\n        props.pageProps.statusCode = 500;\n      }\n\n      await this.set(route, pathname, query, cleanedAs, routeInfo, forcedScroll || (isValidShallowRoute || !options.scroll ? null : {\n        x: 0,\n        y: 0\n      })).catch(e => {\n        if (e.cancelled) error = error || e;else throw e;\n      });\n\n      if (error) {\n        Router.events.emit('routeChangeError', error, cleanedAs, routeProps);\n        throw error;\n      }\n\n      if (false) {}\n\n      Router.events.emit('routeChangeComplete', as, routeProps);\n      return true;\n    } catch (err) {\n      if (err.cancelled) {\n        return false;\n      }\n\n      throw err;\n    }\n  }\n\n  changeState(method, url, as, options = {}) {\n    if (true) {\n      if (typeof window.history === 'undefined') {\n        console.error(`Warning: window.history is not available.`);\n        return;\n      }\n\n      if (typeof window.history[method] === 'undefined') {\n        console.error(`Warning: window.history.${method} is not available`);\n        return;\n      }\n    }\n\n    if (method !== 'pushState' || (0, _utils.getURL)() !== as) {\n      this._shallow = options.shallow;\n      window.history[method]({\n        url,\n        as,\n        options,\n        __N: true,\n        idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1\n      }, // Most browsers currently ignores this parameter, although they may use it in the future.\n      // Passing the empty string here should be safe against future changes to the method.\n      // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n      '', as);\n    }\n  }\n\n  async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n    if (err.cancelled) {\n      // bubble up cancellation errors\n      throw err;\n    }\n\n    if ((0, _routeLoader.isAssetError)(err) || loadErrorFail) {\n      Router.events.emit('routeChangeError', err, as, routeProps); // If we can't load the page it could be one of following reasons\n      //  1. Page doesn't exists\n      //  2. Page does exist in a different zone\n      //  3. Internal error while loading the page\n      // So, doing a hard reload is the proper way to deal with this.\n\n      window.location.href = as; // Changing the URL doesn't block executing the current code path.\n      // So let's throw a cancellation error stop the routing logic.\n\n      throw buildCancellationError();\n    }\n\n    try {\n      let Component;\n      let styleSheets;\n      let props;\n\n      if (typeof Component === 'undefined' || typeof styleSheets === 'undefined') {\n        ;\n        ({\n          page: Component,\n          styleSheets\n        } = await this.fetchComponent('/_error'));\n      }\n\n      const routeInfo = {\n        props,\n        Component,\n        styleSheets,\n        err,\n        error: err\n      };\n\n      if (!routeInfo.props) {\n        try {\n          routeInfo.props = await this.getInitialProps(Component, {\n            err,\n            pathname,\n            query\n          });\n        } catch (gipErr) {\n          console.error('Error in error page `getInitialProps`: ', gipErr);\n          routeInfo.props = {};\n        }\n      }\n\n      return routeInfo;\n    } catch (routeInfoErr) {\n      return this.handleRouteInfoError(routeInfoErr, pathname, query, as, routeProps, true);\n    }\n  }\n\n  async getRouteInfo(route, pathname, query, as, resolvedAs, routeProps) {\n    try {\n      const existingRouteInfo = this.components[route];\n\n      if (routeProps.shallow && existingRouteInfo && this.route === route) {\n        return existingRouteInfo;\n      }\n\n      const cachedRouteInfo = existingRouteInfo && 'initial' in existingRouteInfo ? undefined : existingRouteInfo;\n      const routeInfo = cachedRouteInfo ? cachedRouteInfo : await this.fetchComponent(route).then(res => ({\n        Component: res.page,\n        styleSheets: res.styleSheets,\n        __N_SSG: res.mod.__N_SSG,\n        __N_SSP: res.mod.__N_SSP\n      }));\n      const {\n        Component,\n        __N_SSG,\n        __N_SSP\n      } = routeInfo;\n\n      if (true) {\n        const {\n          isValidElementType\n        } = __webpack_require__(/*! react-is */ \"react-is\");\n\n        if (!isValidElementType(Component)) {\n          throw new Error(`The default export is not a React Component in page: \"${pathname}\"`);\n        }\n      }\n\n      let dataHref;\n\n      if (__N_SSG || __N_SSP) {\n        dataHref = this.pageLoader.getDataHref((0, _utils.formatWithValidation)({\n          pathname,\n          query\n        }), resolvedAs, __N_SSG, this.locale);\n      }\n\n      const props = await this._getData(() => __N_SSG ? this._getStaticData(dataHref) : __N_SSP ? this._getServerData(dataHref) : this.getInitialProps(Component, // we provide AppTree later so this needs to be `any`\n      {\n        pathname,\n        query,\n        asPath: as\n      }));\n      routeInfo.props = props;\n      this.components[route] = routeInfo;\n      return routeInfo;\n    } catch (err) {\n      return this.handleRouteInfoError(err, pathname, query, as, routeProps);\n    }\n  }\n\n  set(route, pathname, query, as, data, resetScroll) {\n    this.isFallback = false;\n    this.route = route;\n    this.pathname = pathname;\n    this.query = query;\n    this.asPath = as;\n    return this.notify(data, resetScroll);\n  }\n  /**\n  * Callback to execute before replacing router state\n  * @param cb callback to be executed\n  */\n\n\n  beforePopState(cb) {\n    this._bps = cb;\n  }\n\n  onlyAHashChange(as) {\n    if (!this.asPath) return false;\n    const [oldUrlNoHash, oldHash] = this.asPath.split('#');\n    const [newUrlNoHash, newHash] = as.split('#'); // Makes sure we scroll to the provided hash if the url/hash are the same\n\n    if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n      return true;\n    } // If the urls are change, there's more than a hash change\n\n\n    if (oldUrlNoHash !== newUrlNoHash) {\n      return false;\n    } // If the hash has changed, then it's a hash only change.\n    // This check is necessary to handle both the enter and\n    // leave hash === '' cases. The identity case falls through\n    // and is treated as a next reload.\n\n\n    return oldHash !== newHash;\n  }\n\n  scrollToHash(as) {\n    const [, hash] = as.split('#'); // Scroll to top if the hash is just `#` with no value or `#top`\n    // To mirror browsers\n\n    if (hash === '' || hash === 'top') {\n      window.scrollTo(0, 0);\n      return;\n    } // First we check if the element by id is found\n\n\n    const idEl = document.getElementById(hash);\n\n    if (idEl) {\n      idEl.scrollIntoView();\n      return;\n    } // If there's no element with the id, we check the `name` property\n    // To mirror browsers\n\n\n    const nameEl = document.getElementsByName(hash)[0];\n\n    if (nameEl) {\n      nameEl.scrollIntoView();\n    }\n  }\n\n  urlIsNew(asPath) {\n    return this.asPath !== asPath;\n  }\n  /**\n  * Prefetch page code, you may wait for the data during page rendering.\n  * This feature only works in production!\n  * @param url the href of prefetched page\n  * @param asPath the as path of the prefetched page\n  */\n\n\n  async prefetch(url, asPath = url, options = {}) {\n    let parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);\n    let {\n      pathname\n    } = parsed;\n\n    if (false) {}\n\n    const pages = await this.pageLoader.getPageList();\n    let resolvedAs = asPath;\n\n    if ( true && asPath.startsWith('/')) {\n      let rewrites;\n      ({\n        __rewrites: rewrites\n      } = await (0, _routeLoader.getClientBuildManifest)());\n      const rewritesResult = (0, _resolveRewrites.default)(addBasePath(addLocale(asPath, this.locale)), pages, rewrites, parsed.query, p => resolveDynamicRoute(p, pages), this.locales);\n      resolvedAs = delLocale(delBasePath(rewritesResult.asPath), this.locale);\n\n      if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n        // if this directly matches a page we need to update the href to\n        // allow the correct page chunk to be loaded\n        pathname = rewritesResult.resolvedHref;\n        parsed.pathname = pathname;\n        url = (0, _utils.formatWithValidation)(parsed);\n      }\n    } else {\n      parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n\n      if (parsed.pathname !== pathname) {\n        pathname = parsed.pathname;\n        url = (0, _utils.formatWithValidation)(parsed);\n      }\n    }\n\n    const route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname); // Prefetch is not supported in development mode because it would trigger on-demand-entries\n\n    if (true) {\n      return;\n    }\n\n    await Promise.all([this.pageLoader._isSsg(route).then(isSsg => {\n      return isSsg ? this._getStaticData(this.pageLoader.getDataHref(url, resolvedAs, true, typeof options.locale !== 'undefined' ? options.locale : this.locale)) : false;\n    }), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);\n  }\n\n  async fetchComponent(route) {\n    let cancelled = false;\n\n    const cancel = this.clc = () => {\n      cancelled = true;\n    };\n\n    const componentResult = await this.pageLoader.loadPage(route);\n\n    if (cancelled) {\n      const error = new Error(`Abort fetching component for route: \"${route}\"`);\n      error.cancelled = true;\n      throw error;\n    }\n\n    if (cancel === this.clc) {\n      this.clc = null;\n    }\n\n    return componentResult;\n  }\n\n  _getData(fn) {\n    let cancelled = false;\n\n    const cancel = () => {\n      cancelled = true;\n    };\n\n    this.clc = cancel;\n    return fn().then(data => {\n      if (cancel === this.clc) {\n        this.clc = null;\n      }\n\n      if (cancelled) {\n        const err = new Error('Loading initial props cancelled');\n        err.cancelled = true;\n        throw err;\n      }\n\n      return data;\n    });\n  }\n\n  _getStaticData(dataHref) {\n    const {\n      href: cacheKey\n    } = new URL(dataHref, window.location.href);\n\n    if (false) {}\n\n    return fetchNextData(dataHref, this.isSsr).then(data => {\n      this.sdc[cacheKey] = data;\n      return data;\n    });\n  }\n\n  _getServerData(dataHref) {\n    const {\n      href: resourceKey\n    } = new URL(dataHref, window.location.href);\n\n    if (this.sdr[resourceKey]) {\n      return this.sdr[resourceKey];\n    }\n\n    return this.sdr[resourceKey] = fetchNextData(dataHref, this.isSsr).then(data => {\n      delete this.sdr[resourceKey];\n      return data;\n    }).catch(err => {\n      delete this.sdr[resourceKey];\n      throw err;\n    });\n  }\n\n  getInitialProps(Component, ctx) {\n    const {\n      Component: App\n    } = this.components['/_app'];\n\n    const AppTree = this._wrapApp(App);\n\n    ctx.AppTree = AppTree;\n    return (0, _utils.loadGetInitialProps)(App, {\n      AppTree,\n      Component,\n      router: this,\n      ctx\n    });\n  }\n\n  abortComponentLoad(as, routeProps) {\n    if (this.clc) {\n      Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);\n      this.clc();\n      this.clc = null;\n    }\n  }\n\n  notify(data, resetScroll) {\n    return this.sub(data, this.components['/_app'].Component, resetScroll);\n  }\n\n}\n\nexports.default = Router;\nRouter.events = (0, _mitt.default)();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXIudHM/MzViOCJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiYmFzZVBhdGgiLCJPYmplY3QiLCJjYW5jZWxsZWQiLCJwcmVmaXgiLCJwYXRoIiwicGF0aE5vUXVlcnlIYXNoIiwicXVlcnlJbmRleCIsImhhc2hJbmRleCIsImFkZFBhdGhQcmVmaXgiLCJ1cmwiLCJsb2NhdGlvbk9yaWdpbiIsInJlc29sdmVkIiwiaGFzQmFzZVBhdGgiLCJpbnRlcnBvbGF0ZWRSb3V0ZSIsImR5bmFtaWNSZWdleCIsImR5bmFtaWNHcm91cHMiLCJkeW5hbWljTWF0Y2hlcyIsImFzUGF0aG5hbWUiLCJwYXJhbXMiLCJwYXJhbSIsInZhbHVlIiwicmVwbGFjZWQiLCJyZXBlYXQiLCJBcnJheSIsIm9wdGlvbmFsIiwic2VnbWVudCIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlc3VsdCIsImZpbHRlcmVkUXVlcnkiLCJrZXkiLCJxdWVyeSIsImJhc2UiLCJ1cmxBc1N0cmluZyIsImlzTG9jYWxVUkwiLCJyZXNvbHZlQXMiLCJmaW5hbFVybCIsImludGVycG9sYXRlZEFzIiwiaW50ZXJwb2xhdGVBcyIsInBhdGhuYW1lIiwiaGFzaCIsIm9taXRQYXJtc0Zyb21RdWVyeSIsInJlc29sdmVkSHJlZiIsIm9yaWdpbiIsInJlc29sdmVIcmVmIiwicm91dGVyIiwiaHJlZkhhZE9yaWdpbiIsImFzSGFkT3JpZ2luIiwicmVzb2x2ZWRBcyIsInN0cmlwT3JpZ2luIiwicHJlcGFyZWRVcmwiLCJhZGRCYXNlUGF0aCIsInByZXBhcmVkQXMiLCJhcyIsImNsZWFuUGF0aG5hbWUiLCJwYWdlcyIsInBhZ2UiLCJtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiIsIlNTR19EQVRBX05PVF9GT1VORCIsIlN5bWJvbCIsImNyZWRlbnRpYWxzIiwicmVzIiwiYXR0ZW1wdHMiLCJmZXRjaFJldHJ5IiwiZGF0YSIsIm5vdEZvdW5kIiwiaXNTZXJ2ZXJSZW5kZXIiLCJlcnIiLCJSb3V0ZXIiLCJjb25zdHJ1Y3RvciIsInJvdXRlIiwiYXNQYXRoIiwiY29tcG9uZW50cyIsInNkYyIsInNkciIsInN1YiIsImNsYyIsInBhZ2VMb2FkZXIiLCJfYnBzIiwiZXZlbnRzIiwiX3dyYXBBcHAiLCJpc1NzciIsImlzRmFsbGJhY2siLCJfaW5GbGlnaHRSb3V0ZSIsIl9zaGFsbG93IiwibG9jYWxlIiwibG9jYWxlcyIsImRlZmF1bHRMb2NhbGUiLCJkb21haW5Mb2NhbGVzIiwiaXNSZWFkeSIsImlzUHJldmlldyIsImlzTG9jYWxlRG9tYWluIiwiX2lkeCIsImUiLCJzdGF0ZSIsInNoYWxsb3ciLCJvcHRpb25zIiwiaW5pdGlhbCIsInByb3BzIiwiX19OX1NTRyIsImluaXRpYWxQcm9wcyIsIl9fTl9TU1AiLCJDb21wb25lbnQiLCJzdHlsZVNoZWV0cyIsImF1dG9FeHBvcnREeW5hbWljIiwic2VsZiIsInJlbG9hZCIsIndpbmRvdyIsImJhY2siLCJwdXNoIiwicHJlcGFyZVVybEFzIiwicmVwbGFjZSIsImxvY2FsZUNoYW5nZSIsIlNUIiwicGVyZm9ybWFuY2UiLCJyb3V0ZVByb3BzIiwiYWRkTG9jYWxlIiwiZGVsQmFzZVBhdGgiLCJjbGVhbmVkQXMiLCJkZWxMb2NhbGUiLCJwYXJzZWQiLCJfX3Jld3JpdGVzIiwibWV0aG9kIiwicmV3cml0ZXNSZXN1bHQiLCJwIiwicmVzb2x2ZUR5bmFtaWNSb3V0ZSIsInBhcnNlZEFzIiwicm91dGVSZWdleCIsInJvdXRlTWF0Y2giLCJzaG91bGRJbnRlcnBvbGF0ZSIsIm1pc3NpbmdQYXJhbXMiLCJjb25zb2xlIiwicm91dGVJbmZvIiwiZGVzdGluYXRpb24iLCJwYXJzZWRIcmVmIiwibm90Rm91bmRSb3V0ZSIsImFwcENvbXAiLCJpc1ZhbGlkU2hhbGxvd1JvdXRlIiwiZm9yY2VkU2Nyb2xsIiwieCIsInkiLCJlcnJvciIsImNoYW5nZVN0YXRlIiwiX19OIiwiaWR4IiwiYnVpbGRDYW5jZWxsYXRpb25FcnJvciIsImV4aXN0aW5nUm91dGVJbmZvIiwiY2FjaGVkUm91dGVJbmZvIiwicmVxdWlyZSIsImlzVmFsaWRFbGVtZW50VHlwZSIsImRhdGFIcmVmIiwic2V0IiwiYmVmb3JlUG9wU3RhdGUiLCJvbmx5QUhhc2hDaGFuZ2UiLCJuZXdIYXNoIiwib2xkVXJsTm9IYXNoIiwib2xkSGFzaCIsInNjcm9sbFRvSGFzaCIsImlkRWwiLCJkb2N1bWVudCIsIm5hbWVFbCIsInVybElzTmV3IiwiUHJvbWlzZSIsImlzU3NnIiwiY2FuY2VsIiwiY29tcG9uZW50UmVzdWx0IiwiX2dldERhdGEiLCJmbiIsIl9nZXRTdGF0aWNEYXRhIiwiaHJlZiIsImZldGNoTmV4dERhdGEiLCJfZ2V0U2VydmVyRGF0YSIsImdldEluaXRpYWxQcm9wcyIsIkFwcFRyZWUiLCJjdHgiLCJhYm9ydENvbXBvbmVudExvYWQiLCJub3RpZnkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBS0E7O0FBS0E7O0FBTUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBVUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQWxDQTtBQUFBO0FBQ0E7OztBQStEQTs7QUFFQSxJQUFJQSxLQUFKLEVBQXFDLEVBS3JDOztBQUFBLE1BQU1DLFFBQVEsR0FBSUQsVUFBbEI7O0FBRUEsa0NBQWtDO0FBQ2hDLFNBQU9FLE1BQU0sQ0FBTkEsT0FBYyxVQUFkQSxpQkFBYyxDQUFkQSxFQUE0QztBQUNqREMsYUFBUyxFQURYO0FBQW1ELEdBQTVDRCxDQUFQO0FBS0Y7O0FBQUEscUNBQXNEO0FBQ3BELFNBQU9FLE1BQU0sSUFBSUMsSUFBSSxDQUFKQSxXQUFWRCxHQUFVQyxDQUFWRCxHQUNIQyxJQUFJLEtBQUpBLE1BQ0Usd0RBREZBLE1BQ0UsQ0FERkEsR0FFRyxHQUFFRCxNQUFPLEdBQUVFLGVBQWUsQ0FBZkEsSUFBZSxDQUFmQSxXQUFnQ0QsSUFBSSxDQUFKQSxVQUFoQ0MsQ0FBZ0NELENBQWhDQyxHQUFvREQsSUFIL0RELEtBQVA7QUFP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S0FBYSxDQUFiQSxNQUN2QjFHLElBQUQsSUFBVTtBQUNkLGFBQU8sU0FBUCxXQUFPLENBQVA7QUFDQTtBQUg0QjBHLGFBS3RCdkcsR0FBRCxJQUFTO0FBQ2QsYUFBTyxTQUFQLFdBQU8sQ0FBUDtBQUNBO0FBUEosS0FBZ0N1RyxDQUFoQztBQVdGRTs7QUFBQUEsaUJBQWUsaUJBR0M7QUFDZCxVQUFNO0FBQUV0RSxlQUFTLEVBQVg7QUFBQSxRQUFxQixnQkFBM0IsT0FBMkIsQ0FBM0I7O0FBQ0EsVUFBTXVFLE9BQU8sR0FBRyxjQUFoQixHQUFnQixDQUFoQjs7QUFDQUMsT0FBRyxDQUFIQTtBQUNBLFdBQU8scUNBQWlEO0FBQUE7QUFBQTtBQUd0RGpJLFlBQU0sRUFIZ0Q7QUFBeEQ7QUFBd0QsS0FBakQsQ0FBUDtBQVFGa0k7O0FBQUFBLG9CQUFrQixpQkFBZ0Q7QUFDaEUsUUFBSSxLQUFKLEtBQWM7QUFDWjNHLFlBQU0sQ0FBTkEsZ0NBRUU2RSxzQkFGRjdFO0FBTUE7QUFDQTtBQUVIO0FBRUQ0Rzs7QUFBQUEsUUFBTSxvQkFHVztBQUNmLFdBQU8sZUFFTCx5QkFGSyxXQUFQLFdBQU8sQ0FBUDtBQXpvQzhDOztBQUFBOzs7QUFBN0I1RyxNLENBb0NaVyxNQXBDWVgsR0FvQ1Usb0JBcENWQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgX19ORVhUX0RBVEFfXyAqL1xuLy8gdHNsaW50OmRpc2FibGU6bm8tY29uc29sZVxuaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7XG4gIG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoLFxuICByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCxcbn0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaCdcbmltcG9ydCB7IEdvb2RQYWdlQ2FjaGUsIFN0eWxlU2hlZXRUdXBsZSB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9wYWdlLWxvYWRlcidcbmltcG9ydCB7XG4gIGdldENsaWVudEJ1aWxkTWFuaWZlc3QsXG4gIGlzQXNzZXRFcnJvcixcbiAgbWFya0Fzc2V0RXJyb3IsXG59IGZyb20gJy4uLy4uLy4uL2NsaWVudC9yb3V0ZS1sb2FkZXInXG5pbXBvcnQgeyBEb21haW5Mb2NhbGVzIH0gZnJvbSAnLi4vLi4vc2VydmVyL2NvbmZpZydcbmltcG9ydCB7IGRlbm9ybWFsaXplUGFnZVBhdGggfSBmcm9tICcuLi8uLi9zZXJ2ZXIvZGVub3JtYWxpemUtcGFnZS1wYXRoJ1xuaW1wb3J0IHsgbm9ybWFsaXplTG9jYWxlUGF0aCB9IGZyb20gJy4uL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoJ1xuaW1wb3J0IG1pdHQsIHsgTWl0dEVtaXR0ZXIgfSBmcm9tICcuLi9taXR0J1xuaW1wb3J0IHtcbiAgQXBwQ29udGV4dFR5cGUsXG4gIGZvcm1hdFdpdGhWYWxpZGF0aW9uLFxuICBnZXRMb2NhdGlvbk9yaWdpbixcbiAgZ2V0VVJMLFxuICBsb2FkR2V0SW5pdGlhbFByb3BzLFxuICBOZXh0UGFnZUNvbnRleHQsXG4gIFNULFxuICBORVhUX0RBVEEsXG59IGZyb20gJy4uL3V0aWxzJ1xuaW1wb3J0IHsgaXNEeW5hbWljUm91dGUgfSBmcm9tICcuL3V0aWxzL2lzLWR5bmFtaWMnXG5pbXBvcnQgeyBwYXJzZVJlbGF0aXZlVXJsIH0gZnJvbSAnLi91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmwnXG5pbXBvcnQgeyBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IH0gZnJvbSAnLi91dGlscy9xdWVyeXN0cmluZydcbmltcG9ydCByZXNvbHZlUmV3cml0ZXMgZnJvbSAnLi91dGlscy9yZXNvbHZlLXJld3JpdGVzJ1xuaW1wb3J0IHsgZ2V0Um91dGVNYXRjaGVyIH0gZnJvbSAnLi91dGlscy9yb3V0ZS1tYXRjaGVyJ1xuaW1wb3J0IHsgZ2V0Um91dGVSZWdleCB9IGZyb20gJy4vdXRpbHMvcm91dGUtcmVnZXgnXG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgLyogcHJvZCAqL1xuICAgIF9fTkVYVF9EQVRBX186IE5FWFRfREFUQVxuICB9XG59XG5cbmludGVyZmFjZSBSb3V0ZVByb3BlcnRpZXMge1xuICBzaGFsbG93OiBib29sZWFuXG59XG5cbmludGVyZmFjZSBUcmFuc2l0aW9uT3B0aW9ucyB7XG4gIHNoYWxsb3c/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG4gIHNjcm9sbD86IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIE5leHRIaXN0b3J5U3RhdGUge1xuICB1cmw6IHN0cmluZ1xuICBhczogc3RyaW5nXG4gIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zXG59XG5cbnR5cGUgSGlzdG9yeVN0YXRlID1cbiAgfCBudWxsXG4gIHwgeyBfX046IGZhbHNlIH1cbiAgfCAoeyBfX046IHRydWU7IGlkeDogbnVtYmVyIH0gJiBOZXh0SGlzdG9yeVN0YXRlKVxuXG5sZXQgZGV0ZWN0RG9tYWluTG9jYWxlOiB0eXBlb2YgaW1wb3J0KCcuLi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlJykuZGV0ZWN0RG9tYWluTG9jYWxlXG5cbmlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gIGRldGVjdERvbWFpbkxvY2FsZSA9IHJlcXVpcmUoJy4uL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnKVxuICAgIC5kZXRlY3REb21haW5Mb2NhbGVcbn1cblxuY29uc3QgYmFzZVBhdGggPSAocHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCBhcyBzdHJpbmcpIHx8ICcnXG5cbmZ1bmN0aW9uIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignUm91dGUgQ2FuY2VsbGVkJyksIHtcbiAgICBjYW5jZWxsZWQ6IHRydWUsXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGFkZFBhdGhQcmVmaXgocGF0aDogc3RyaW5nLCBwcmVmaXg/OiBzdHJpbmcpIHtcbiAgcmV0dXJuIHByZWZpeCAmJiBwYXRoLnN0YXJ0c1dpdGgoJy8nKVxuICAgID8gcGF0aCA9PT0gJy8nXG4gICAgICA/IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKHByZWZpeClcbiAgICAgIDogYCR7cHJlZml4fSR7cGF0aE5vUXVlcnlIYXNoKHBhdGgpID09PSAnLycgPyBwYXRoLnN1YnN0cmluZygxKSA6IHBhdGh9YFxuICAgIDogcGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RG9tYWluTG9jYWxlKFxuICBwYXRoOiBzdHJpbmcsXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlLFxuICBsb2NhbGVzPzogc3RyaW5nW10sXG4gIGRvbWFpbkxvY2FsZXM/OiBEb21haW5Mb2NhbGVzXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICBsb2NhbGUgPSBsb2NhbGUgfHwgbm9ybWFsaXplTG9jYWxlUGF0aChwYXRoLCBsb2NhbGVzKS5kZXRlY3RlZExvY2FsZVxuXG4gICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUoZG9tYWluTG9jYWxlcywgdW5kZWZpbmVkLCBsb2NhbGUpXG5cbiAgICBpZiAoZGV0ZWN0ZWREb21haW4pIHtcbiAgICAgIHJldHVybiBgaHR0cCR7ZGV0ZWN0ZWREb21haW4uaHR0cCA/ICcnIDogJ3MnfTovLyR7ZGV0ZWN0ZWREb21haW4uZG9tYWlufSR7XG4gICAgICAgIGJhc2VQYXRoIHx8ICcnXG4gICAgICB9JHtsb2NhbGUgPT09IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGUgPyAnJyA6IGAvJHtsb2NhbGV9YH0ke3BhdGh9YFxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkTG9jYWxlKFxuICBwYXRoOiBzdHJpbmcsXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlLFxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICByZXR1cm4gbG9jYWxlICYmXG4gICAgICBsb2NhbGUgIT09IGRlZmF1bHRMb2NhbGUgJiZcbiAgICAgICFwYXRoLnN0YXJ0c1dpdGgoJy8nICsgbG9jYWxlICsgJy8nKSAmJlxuICAgICAgcGF0aCAhPT0gJy8nICsgbG9jYWxlXG4gICAgICA/IGFkZFBhdGhQcmVmaXgocGF0aCwgJy8nICsgbG9jYWxlKVxuICAgICAgOiBwYXRoXG4gIH1cbiAgcmV0dXJuIHBhdGhcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbExvY2FsZShwYXRoOiBzdHJpbmcsIGxvY2FsZT86IHN0cmluZykge1xuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgIHJldHVybiBsb2NhbGUgJiZcbiAgICAgIChwYXRoLnN0YXJ0c1dpdGgoJy8nICsgbG9jYWxlICsgJy8nKSB8fCBwYXRoID09PSAnLycgKyBsb2NhbGUpXG4gICAgICA/IHBhdGguc3Vic3RyKGxvY2FsZS5sZW5ndGggKyAxKSB8fCAnLydcbiAgICAgIDogcGF0aFxuICB9XG4gIHJldHVybiBwYXRoXG59XG5cbmZ1bmN0aW9uIHBhdGhOb1F1ZXJ5SGFzaChwYXRoOiBzdHJpbmcpIHtcbiAgY29uc3QgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZignPycpXG4gIGNvbnN0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZignIycpXG5cbiAgaWYgKHF1ZXJ5SW5kZXggPiAtMSB8fCBoYXNoSW5kZXggPiAtMSkge1xuICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBxdWVyeUluZGV4ID4gLTEgPyBxdWVyeUluZGV4IDogaGFzaEluZGV4KVxuICB9XG4gIHJldHVybiBwYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNCYXNlUGF0aChwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcGF0aCA9IHBhdGhOb1F1ZXJ5SGFzaChwYXRoKVxuICByZXR1cm4gcGF0aCA9PT0gYmFzZVBhdGggfHwgcGF0aC5zdGFydHNXaXRoKGJhc2VQYXRoICsgJy8nKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQmFzZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gd2Ugb25seSBhZGQgdGhlIGJhc2VwYXRoIG9uIHJlbGF0aXZlIHVybHNcbiAgcmV0dXJuIGFkZFBhdGhQcmVmaXgocGF0aCwgYmFzZVBhdGgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxCYXNlUGF0aChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICBwYXRoID0gcGF0aC5zbGljZShiYXNlUGF0aC5sZW5ndGgpXG4gIGlmICghcGF0aC5zdGFydHNXaXRoKCcvJykpIHBhdGggPSBgLyR7cGF0aH1gXG4gIHJldHVybiBwYXRoXG59XG5cbi8qKlxuICogRGV0ZWN0cyB3aGV0aGVyIGEgZ2l2ZW4gdXJsIGlzIHJvdXRhYmxlIGJ5IHRoZSBOZXh0LmpzIHJvdXRlciAoYnJvd3NlciBvbmx5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTG9jYWxVUkwodXJsOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgLy8gcHJldmVudCBhIGh5ZHJhdGlvbiBtaXNtYXRjaCBvbiBocmVmIGZvciB1cmwgd2l0aCBhbmNob3IgcmVmc1xuICBpZiAodXJsLnN0YXJ0c1dpdGgoJy8nKSB8fCB1cmwuc3RhcnRzV2l0aCgnIycpKSByZXR1cm4gdHJ1ZVxuICB0cnkge1xuICAgIC8vIGFic29sdXRlIHVybHMgY2FuIGJlIGxvY2FsIGlmIHRoZXkgYXJlIG9uIHRoZSBzYW1lIG9yaWdpblxuICAgIGNvbnN0IGxvY2F0aW9uT3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuICAgIGNvbnN0IHJlc29sdmVkID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uT3JpZ2luKVxuICAgIHJldHVybiByZXNvbHZlZC5vcmlnaW4gPT09IGxvY2F0aW9uT3JpZ2luICYmIGhhc0Jhc2VQYXRoKHJlc29sdmVkLnBhdGhuYW1lKVxuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxudHlwZSBVcmwgPSBVcmxPYmplY3QgfCBzdHJpbmdcblxuZXhwb3J0IGZ1bmN0aW9uIGludGVycG9sYXRlQXMoXG4gIHJvdXRlOiBzdHJpbmcsXG4gIGFzUGF0aG5hbWU6IHN0cmluZyxcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4pIHtcbiAgbGV0IGludGVycG9sYXRlZFJvdXRlID0gJydcblxuICBjb25zdCBkeW5hbWljUmVnZXggPSBnZXRSb3V0ZVJlZ2V4KHJvdXRlKVxuICBjb25zdCBkeW5hbWljR3JvdXBzID0gZHluYW1pY1JlZ2V4Lmdyb3Vwc1xuICBjb25zdCBkeW5hbWljTWF0Y2hlcyA9XG4gICAgLy8gVHJ5IHRvIG1hdGNoIHRoZSBkeW5hbWljIHJvdXRlIGFnYWluc3QgdGhlIGFzUGF0aFxuICAgIChhc1BhdGhuYW1lICE9PSByb3V0ZSA/IGdldFJvdXRlTWF0Y2hlcihkeW5hbWljUmVnZXgpKGFzUGF0aG5hbWUpIDogJycpIHx8XG4gICAgLy8gRmFsbCBiYWNrIHRvIHJlYWRpbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBocmVmXG4gICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgdGFrZSBwcmlvcml0eTsgYWxzbyBuZWVkIHRvIGNoYW5nZSBpbiB0aGUgcm91dGVyLlxuICAgIHF1ZXJ5XG5cbiAgaW50ZXJwb2xhdGVkUm91dGUgPSByb3V0ZVxuICBjb25zdCBwYXJhbXMgPSBPYmplY3Qua2V5cyhkeW5hbWljR3JvdXBzKVxuXG4gIGlmIChcbiAgICAhcGFyYW1zLmV2ZXJ5KChwYXJhbSkgPT4ge1xuICAgICAgbGV0IHZhbHVlID0gZHluYW1pY01hdGNoZXNbcGFyYW1dIHx8ICcnXG4gICAgICBjb25zdCB7IHJlcGVhdCwgb3B0aW9uYWwgfSA9IGR5bmFtaWNHcm91cHNbcGFyYW1dXG5cbiAgICAgIC8vIHN1cHBvcnQgc2luZ2xlLWxldmVsIGNhdGNoLWFsbFxuICAgICAgLy8gVE9ETzogbW9yZSByb2J1c3QgaGFuZGxpbmcgZm9yIHVzZXItZXJyb3IgKHBhc3NpbmcgYC9gKVxuICAgICAgbGV0IHJlcGxhY2VkID0gYFske3JlcGVhdCA/ICcuLi4nIDogJyd9JHtwYXJhbX1dYFxuICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgIHJlcGxhY2VkID0gYCR7IXZhbHVlID8gJy8nIDogJyd9WyR7cmVwbGFjZWR9XWBcbiAgICAgIH1cbiAgICAgIGlmIChyZXBlYXQgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB2YWx1ZSA9IFt2YWx1ZV1cblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKG9wdGlvbmFsIHx8IHBhcmFtIGluIGR5bmFtaWNNYXRjaGVzKSAmJlxuICAgICAgICAvLyBJbnRlcnBvbGF0ZSBncm91cCBpbnRvIGRhdGEgVVJMIGlmIHByZXNlbnRcbiAgICAgICAgKGludGVycG9sYXRlZFJvdXRlID1cbiAgICAgICAgICBpbnRlcnBvbGF0ZWRSb3V0ZSEucmVwbGFjZShcbiAgICAgICAgICAgIHJlcGxhY2VkLFxuICAgICAgICAgICAgcmVwZWF0XG4gICAgICAgICAgICAgID8gKHZhbHVlIGFzIHN0cmluZ1tdKVxuICAgICAgICAgICAgICAgICAgLm1hcChcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlc2UgdmFsdWVzIHNob3VsZCBiZSBmdWxseSBlbmNvZGVkIGluc3RlYWQgb2YganVzdFxuICAgICAgICAgICAgICAgICAgICAvLyBwYXRoIGRlbGltaXRlciBlc2NhcGVkIHNpbmNlIHRoZXkgYXJlIGJlaW5nIGluc2VydGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGludG8gdGhlIFVSTCBhbmQgd2UgZXhwZWN0IFVSTCBlbmNvZGVkIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gcGFyc2luZyBkeW5hbWljIHJvdXRlIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAoc2VnbWVudCkgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHNlZ21lbnQpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAuam9pbignLycpXG4gICAgICAgICAgICAgIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlIGFzIHN0cmluZylcbiAgICAgICAgICApIHx8ICcvJylcbiAgICAgIClcbiAgICB9KVxuICApIHtcbiAgICBpbnRlcnBvbGF0ZWRSb3V0ZSA9ICcnIC8vIGRpZCBub3Qgc2F0aXNmeSBhbGwgcmVxdWlyZW1lbnRzXG5cbiAgICAvLyBuLmIuIFdlIGlnbm9yZSB0aGlzIGVycm9yIGJlY2F1c2Ugd2UgaGFuZGxlIHdhcm5pbmcgZm9yIHRoaXMgY2FzZSBpblxuICAgIC8vIGRldmVsb3BtZW50IGluIHRoZSBgPExpbms+YCBjb21wb25lbnQgZGlyZWN0bHkuXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwYXJhbXMsXG4gICAgcmVzdWx0OiBpbnRlcnBvbGF0ZWRSb3V0ZSxcbiAgfVxufVxuXG5mdW5jdGlvbiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnk6IFBhcnNlZFVybFF1ZXJ5LCBwYXJhbXM6IHN0cmluZ1tdKSB7XG4gIGNvbnN0IGZpbHRlcmVkUXVlcnk6IFBhcnNlZFVybFF1ZXJ5ID0ge31cblxuICBPYmplY3Qua2V5cyhxdWVyeSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKCFwYXJhbXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgZmlsdGVyZWRRdWVyeVtrZXldID0gcXVlcnlba2V5XVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIGZpbHRlcmVkUXVlcnlcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyBhIGdpdmVuIGh5cGVybGluayB3aXRoIGEgY2VydGFpbiByb3V0ZXIgc3RhdGUgKGJhc2VQYXRoIG5vdCBpbmNsdWRlZCkuXG4gKiBQcmVzZXJ2ZXMgYWJzb2x1dGUgdXJscy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVIcmVmKFxuICBjdXJyZW50UGF0aDogc3RyaW5nLFxuICBocmVmOiBVcmwsXG4gIHJlc29sdmVBcz86IGJvb2xlYW5cbik6IHN0cmluZyB7XG4gIC8vIHdlIHVzZSBhIGR1bW15IGJhc2UgdXJsIGZvciByZWxhdGl2ZSB1cmxzXG4gIGNvbnN0IGJhc2UgPSBuZXcgVVJMKGN1cnJlbnRQYXRoLCAnaHR0cDovL24nKVxuICBjb25zdCB1cmxBc1N0cmluZyA9XG4gICAgdHlwZW9mIGhyZWYgPT09ICdzdHJpbmcnID8gaHJlZiA6IGZvcm1hdFdpdGhWYWxpZGF0aW9uKGhyZWYpXG4gIC8vIFJldHVybiBiZWNhdXNlIGl0IGNhbm5vdCBiZSByb3V0ZWQgYnkgdGhlIE5leHQuanMgcm91dGVyXG4gIGlmICghaXNMb2NhbFVSTCh1cmxBc1N0cmluZykpIHtcbiAgICByZXR1cm4gKHJlc29sdmVBcyA/IFt1cmxBc1N0cmluZ10gOiB1cmxBc1N0cmluZykgYXMgc3RyaW5nXG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBmaW5hbFVybCA9IG5ldyBVUkwodXJsQXNTdHJpbmcsIGJhc2UpXG4gICAgZmluYWxVcmwucGF0aG5hbWUgPSBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaChmaW5hbFVybC5wYXRobmFtZSlcbiAgICBsZXQgaW50ZXJwb2xhdGVkQXMgPSAnJ1xuXG4gICAgaWYgKFxuICAgICAgaXNEeW5hbWljUm91dGUoZmluYWxVcmwucGF0aG5hbWUpICYmXG4gICAgICBmaW5hbFVybC5zZWFyY2hQYXJhbXMgJiZcbiAgICAgIHJlc29sdmVBc1xuICAgICkge1xuICAgICAgY29uc3QgcXVlcnkgPSBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KGZpbmFsVXJsLnNlYXJjaFBhcmFtcylcblxuICAgICAgY29uc3QgeyByZXN1bHQsIHBhcmFtcyB9ID0gaW50ZXJwb2xhdGVBcyhcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUsXG4gICAgICAgIGZpbmFsVXJsLnBhdGhuYW1lLFxuICAgICAgICBxdWVyeVxuICAgICAgKVxuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGludGVycG9sYXRlZEFzID0gZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgIHBhdGhuYW1lOiByZXN1bHQsXG4gICAgICAgICAgaGFzaDogZmluYWxVcmwuaGFzaCxcbiAgICAgICAgICBxdWVyeTogb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBwYXJhbXMpLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSBvcmlnaW4gZGlkbid0IGNoYW5nZSwgaXQgbWVhbnMgd2UgcmVjZWl2ZWQgYSByZWxhdGl2ZSBocmVmXG4gICAgY29uc3QgcmVzb2x2ZWRIcmVmID1cbiAgICAgIGZpbmFsVXJsLm9yaWdpbiA9PT0gYmFzZS5vcmlnaW5cbiAgICAgICAgPyBmaW5hbFVybC5ocmVmLnNsaWNlKGZpbmFsVXJsLm9yaWdpbi5sZW5ndGgpXG4gICAgICAgIDogZmluYWxVcmwuaHJlZlxuXG4gICAgcmV0dXJuIChyZXNvbHZlQXNcbiAgICAgID8gW3Jlc29sdmVkSHJlZiwgaW50ZXJwb2xhdGVkQXMgfHwgcmVzb2x2ZWRIcmVmXVxuICAgICAgOiByZXNvbHZlZEhyZWYpIGFzIHN0cmluZ1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIChyZXNvbHZlQXMgPyBbdXJsQXNTdHJpbmddIDogdXJsQXNTdHJpbmcpIGFzIHN0cmluZ1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmlwT3JpZ2luKHVybDogc3RyaW5nKSB7XG4gIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcblxuICByZXR1cm4gdXJsLnN0YXJ0c1dpdGgob3JpZ2luKSA/IHVybC5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aCkgOiB1cmxcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVVybEFzKHJvdXRlcjogTmV4dFJvdXRlciwgdXJsOiBVcmwsIGFzPzogVXJsKSB7XG4gIC8vIElmIHVybCBhbmQgYXMgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uLFxuICAvLyB3ZSdsbCBmb3JtYXQgdGhlbSBpbnRvIHRoZSBzdHJpbmcgdmVyc2lvbiBoZXJlLlxuICBsZXQgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSByZXNvbHZlSHJlZihyb3V0ZXIucGF0aG5hbWUsIHVybCwgdHJ1ZSlcbiAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuICBjb25zdCBocmVmSGFkT3JpZ2luID0gcmVzb2x2ZWRIcmVmLnN0YXJ0c1dpdGgob3JpZ2luKVxuICBjb25zdCBhc0hhZE9yaWdpbiA9IHJlc29sdmVkQXMgJiYgcmVzb2x2ZWRBcy5zdGFydHNXaXRoKG9yaWdpbilcblxuICByZXNvbHZlZEhyZWYgPSBzdHJpcE9yaWdpbihyZXNvbHZlZEhyZWYpXG4gIHJlc29sdmVkQXMgPSByZXNvbHZlZEFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZWRBcykgOiByZXNvbHZlZEFzXG5cbiAgY29uc3QgcHJlcGFyZWRVcmwgPSBocmVmSGFkT3JpZ2luID8gcmVzb2x2ZWRIcmVmIDogYWRkQmFzZVBhdGgocmVzb2x2ZWRIcmVmKVxuICBjb25zdCBwcmVwYXJlZEFzID0gYXNcbiAgICA/IHN0cmlwT3JpZ2luKHJlc29sdmVIcmVmKHJvdXRlci5wYXRobmFtZSwgYXMpKVxuICAgIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWZcblxuICByZXR1cm4ge1xuICAgIHVybDogcHJlcGFyZWRVcmwsXG4gICAgYXM6IGFzSGFkT3JpZ2luID8gcHJlcGFyZWRBcyA6IGFkZEJhc2VQYXRoKHByZXBhcmVkQXMpLFxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWU6IHN0cmluZywgcGFnZXM6IHN0cmluZ1tdKSB7XG4gIGNvbnN0IGNsZWFuUGF0aG5hbWUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChkZW5vcm1hbGl6ZVBhZ2VQYXRoKHBhdGhuYW1lISkpXG5cbiAgaWYgKGNsZWFuUGF0aG5hbWUgPT09ICcvNDA0JyB8fCBjbGVhblBhdGhuYW1lID09PSAnL19lcnJvcicpIHtcbiAgICByZXR1cm4gcGF0aG5hbWVcbiAgfVxuXG4gIC8vIGhhbmRsZSByZXNvbHZpbmcgaHJlZiBmb3IgZHluYW1pYyByb3V0ZXNcbiAgaWYgKCFwYWdlcy5pbmNsdWRlcyhjbGVhblBhdGhuYW1lISkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgcGFnZXMuc29tZSgocGFnZSkgPT4ge1xuICAgICAgaWYgKGlzRHluYW1pY1JvdXRlKHBhZ2UpICYmIGdldFJvdXRlUmVnZXgocGFnZSkucmUudGVzdChjbGVhblBhdGhuYW1lISkpIHtcbiAgICAgICAgcGF0aG5hbWUgPSBwYWdlXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICByZXR1cm4gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG59XG5cbmV4cG9ydCB0eXBlIEJhc2VSb3V0ZXIgPSB7XG4gIHJvdXRlOiBzdHJpbmdcbiAgcGF0aG5hbWU6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYXNQYXRoOiBzdHJpbmdcbiAgYmFzZVBhdGg6IHN0cmluZ1xuICBsb2NhbGU/OiBzdHJpbmdcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgZG9tYWluTG9jYWxlcz86IERvbWFpbkxvY2FsZXNcbiAgaXNMb2NhbGVEb21haW46IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgTmV4dFJvdXRlciA9IEJhc2VSb3V0ZXIgJlxuICBQaWNrPFxuICAgIFJvdXRlcixcbiAgICB8ICdwdXNoJ1xuICAgIHwgJ3JlcGxhY2UnXG4gICAgfCAncmVsb2FkJ1xuICAgIHwgJ2JhY2snXG4gICAgfCAncHJlZmV0Y2gnXG4gICAgfCAnYmVmb3JlUG9wU3RhdGUnXG4gICAgfCAnZXZlbnRzJ1xuICAgIHwgJ2lzRmFsbGJhY2snXG4gICAgfCAnaXNSZWFkeSdcbiAgICB8ICdpc1ByZXZpZXcnXG4gID5cblxuZXhwb3J0IHR5cGUgUHJlZmV0Y2hPcHRpb25zID0ge1xuICBwcmlvcml0eT86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2Vcbn1cblxuZXhwb3J0IHR5cGUgUHJpdmF0ZVJvdXRlSW5mbyA9XG4gIHwgKE9taXQ8Q29tcGxldGVQcml2YXRlUm91dGVJbmZvLCAnc3R5bGVTaGVldHMnPiAmIHsgaW5pdGlhbDogdHJ1ZSB9KVxuICB8IENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mb1xuXG5leHBvcnQgdHlwZSBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8gPSB7XG4gIENvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICBzdHlsZVNoZWV0czogU3R5bGVTaGVldFR1cGxlW11cbiAgX19OX1NTRz86IGJvb2xlYW5cbiAgX19OX1NTUD86IGJvb2xlYW5cbiAgcHJvcHM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIGVycj86IEVycm9yXG4gIGVycm9yPzogYW55XG59XG5cbmV4cG9ydCB0eXBlIEFwcFByb3BzID0gUGljazxDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8sICdDb21wb25lbnQnIHwgJ2Vycic+ICYge1xuICByb3V0ZXI6IFJvdXRlclxufSAmIFJlY29yZDxzdHJpbmcsIGFueT5cbmV4cG9ydCB0eXBlIEFwcENvbXBvbmVudCA9IENvbXBvbmVudFR5cGU8QXBwUHJvcHM+XG5cbnR5cGUgU3Vic2NyaXB0aW9uID0gKFxuICBkYXRhOiBQcml2YXRlUm91dGVJbmZvLFxuICBBcHA6IEFwcENvbXBvbmVudCxcbiAgcmVzZXRTY3JvbGw6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB8IG51bGxcbikgPT4gUHJvbWlzZTx2b2lkPlxuXG50eXBlIEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2sgPSAoc3RhdGU6IE5leHRIaXN0b3J5U3RhdGUpID0+IGJvb2xlYW5cblxudHlwZSBDb21wb25lbnRMb2FkQ2FuY2VsID0gKCgpID0+IHZvaWQpIHwgbnVsbFxuXG50eXBlIEhpc3RvcnlNZXRob2QgPSAncmVwbGFjZVN0YXRlJyB8ICdwdXNoU3RhdGUnXG5cbmNvbnN0IG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uID1cbiAgcHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiAmJlxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAnc2Nyb2xsUmVzdG9yYXRpb24nIGluIHdpbmRvdy5oaXN0b3J5ICYmXG4gICEhKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IHYgPSAnX19uZXh0J1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0odiwgdiksIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odiksIHRydWVcbiAgICB9IGNhdGNoIChuKSB7fVxuICB9KSgpXG5cbmNvbnN0IFNTR19EQVRBX05PVF9GT1VORCA9IFN5bWJvbCgnU1NHX0RBVEFfTk9UX0ZPVU5EJylcblxuZnVuY3Rpb24gZmV0Y2hSZXRyeSh1cmw6IHN0cmluZywgYXR0ZW1wdHM6IG51bWJlcik6IFByb21pc2U8YW55PiB7XG4gIHJldHVybiBmZXRjaCh1cmwsIHtcbiAgICAvLyBDb29raWVzIGFyZSByZXF1aXJlZCB0byBiZSBwcmVzZW50IGZvciBOZXh0LmpzJyBTU0cgXCJQcmV2aWV3IE1vZGVcIi5cbiAgICAvLyBDb29raWVzIG1heSBhbHNvIGJlIHJlcXVpcmVkIGZvciBgZ2V0U2VydmVyU2lkZVByb3BzYC5cbiAgICAvL1xuICAgIC8vID4gYGZldGNoYCB3b27igJl0IHNlbmQgY29va2llcywgdW5sZXNzIHlvdSBzZXQgdGhlIGNyZWRlbnRpYWxzIGluaXRcbiAgICAvLyA+IG9wdGlvbi5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmV0Y2hfQVBJL1VzaW5nX0ZldGNoXG4gICAgLy9cbiAgICAvLyA+IEZvciBtYXhpbXVtIGJyb3dzZXIgY29tcGF0aWJpbGl0eSB3aGVuIGl0IGNvbWVzIHRvIHNlbmRpbmcgJlxuICAgIC8vID4gcmVjZWl2aW5nIGNvb2tpZXMsIGFsd2F5cyBzdXBwbHkgdGhlIGBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ2BcbiAgICAvLyA+IG9wdGlvbiBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gdGhlIGRlZmF1bHQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaCNjYXZlYXRzXG4gICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gIH0pLnRoZW4oKHJlcykgPT4ge1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBpZiAoYXR0ZW1wdHMgPiAxICYmIHJlcy5zdGF0dXMgPj0gNTAwKSB7XG4gICAgICAgIHJldHVybiBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMgLSAxKVxuICAgICAgfVxuICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4gcmVzLmpzb24oKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKGRhdGEubm90Rm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5vdEZvdW5kOiBTU0dfREFUQV9OT1RfRk9VTkQgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc2ApXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc2ApXG4gICAgfVxuICAgIHJldHVybiByZXMuanNvbigpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGZldGNoTmV4dERhdGEoZGF0YUhyZWY6IHN0cmluZywgaXNTZXJ2ZXJSZW5kZXI6IGJvb2xlYW4pIHtcbiAgcmV0dXJuIGZldGNoUmV0cnkoZGF0YUhyZWYsIGlzU2VydmVyUmVuZGVyID8gMyA6IDEpLmNhdGNoKChlcnI6IEVycm9yKSA9PiB7XG4gICAgLy8gV2Ugc2hvdWxkIG9ubHkgdHJpZ2dlciBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb24gaWYgdGhpcyB3YXMgY2F1c2VkXG4gICAgLy8gb24gYSBjbGllbnQtc2lkZSB0cmFuc2l0aW9uLiBPdGhlcndpc2UsIHdlJ2QgZ2V0IGludG8gYW4gaW5maW5pdGVcbiAgICAvLyBsb29wLlxuXG4gICAgaWYgKCFpc1NlcnZlclJlbmRlcikge1xuICAgICAgbWFya0Fzc2V0RXJyb3IoZXJyKVxuICAgIH1cbiAgICB0aHJvdyBlcnJcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm91dGVyIGltcGxlbWVudHMgQmFzZVJvdXRlciB7XG4gIHJvdXRlOiBzdHJpbmdcbiAgcGF0aG5hbWU6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYXNQYXRoOiBzdHJpbmdcbiAgYmFzZVBhdGg6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgYWxsIGNvbXBvbmVudHMgbG9hZGVkIGluIGBSb3V0ZXJgXG4gICAqL1xuICBjb21wb25lbnRzOiB7IFtwYXRobmFtZTogc3RyaW5nXTogUHJpdmF0ZVJvdXRlSW5mbyB9XG4gIC8vIFN0YXRpYyBEYXRhIENhY2hlXG4gIHNkYzogeyBbYXNQYXRoOiBzdHJpbmddOiBvYmplY3QgfSA9IHt9XG4gIC8vIEluLWZsaWdodCBTZXJ2ZXIgRGF0YSBSZXF1ZXN0cywgZm9yIGRlZHVwaW5nXG4gIHNkcjogeyBbYXNQYXRoOiBzdHJpbmddOiBQcm9taXNlPG9iamVjdD4gfSA9IHt9XG5cbiAgc3ViOiBTdWJzY3JpcHRpb25cbiAgY2xjOiBDb21wb25lbnRMb2FkQ2FuY2VsXG4gIHBhZ2VMb2FkZXI6IGFueVxuICBfYnBzOiBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrIHwgdW5kZWZpbmVkXG4gIGV2ZW50czogTWl0dEVtaXR0ZXJcbiAgX3dyYXBBcHA6IChBcHA6IEFwcENvbXBvbmVudCkgPT4gYW55XG4gIGlzU3NyOiBib29sZWFuXG4gIGlzRmFsbGJhY2s6IGJvb2xlYW5cbiAgX2luRmxpZ2h0Um91dGU/OiBzdHJpbmdcbiAgX3NoYWxsb3c/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZ1xuICBsb2NhbGVzPzogc3RyaW5nW11cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICBkb21haW5Mb2NhbGVzPzogRG9tYWluTG9jYWxlc1xuICBpc1JlYWR5OiBib29sZWFuXG4gIGlzUHJldmlldzogYm9vbGVhblxuICBpc0xvY2FsZURvbWFpbjogYm9vbGVhblxuXG4gIHByaXZhdGUgX2lkeDogbnVtYmVyID0gMFxuXG4gIHN0YXRpYyBldmVudHM6IE1pdHRFbWl0dGVyID0gbWl0dCgpXG5cbiAgY29uc3RydWN0b3IoXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICB7XG4gICAgICBpbml0aWFsUHJvcHMsXG4gICAgICBwYWdlTG9hZGVyLFxuICAgICAgQXBwLFxuICAgICAgd3JhcEFwcCxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIGVycixcbiAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgIGlzRmFsbGJhY2ssXG4gICAgICBsb2NhbGUsXG4gICAgICBsb2NhbGVzLFxuICAgICAgZGVmYXVsdExvY2FsZSxcbiAgICAgIGRvbWFpbkxvY2FsZXMsXG4gICAgICBpc1ByZXZpZXcsXG4gICAgfToge1xuICAgICAgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb25cbiAgICAgIGluaXRpYWxQcm9wczogYW55XG4gICAgICBwYWdlTG9hZGVyOiBhbnlcbiAgICAgIENvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICAgICAgQXBwOiBBcHBDb21wb25lbnRcbiAgICAgIHdyYXBBcHA6IChBcHA6IEFwcENvbXBvbmVudCkgPT4gYW55XG4gICAgICBlcnI/OiBFcnJvclxuICAgICAgaXNGYWxsYmFjazogYm9vbGVhblxuICAgICAgbG9jYWxlPzogc3RyaW5nXG4gICAgICBsb2NhbGVzPzogc3RyaW5nW11cbiAgICAgIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgICAgIGRvbWFpbkxvY2FsZXM/OiBEb21haW5Mb2NhbGVzXG4gICAgICBpc1ByZXZpZXc/OiBib29sZWFuXG4gICAgfVxuICApIHtcbiAgICAvLyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGNvbXBvbmVudCBrZXlcbiAgICB0aGlzLnJvdXRlID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG5cbiAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcbiAgICB0aGlzLmNvbXBvbmVudHMgPSB7fVxuICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAvLyBPdGhlcndpc2UsIHRoaXMgY2F1c2UgaXNzdWVzIHdoZW4gd2hlbiBnb2luZyBiYWNrIGFuZFxuICAgIC8vIGNvbWUgYWdhaW4gdG8gdGhlIGVycm9yZWQgcGFnZS5cbiAgICBpZiAocGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgdGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdID0ge1xuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgIHByb3BzOiBpbml0aWFsUHJvcHMsXG4gICAgICAgIGVycixcbiAgICAgICAgX19OX1NTRzogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NHLFxuICAgICAgICBfX05fU1NQOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU1AsXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb21wb25lbnRzWycvX2FwcCddID0ge1xuICAgICAgQ29tcG9uZW50OiBBcHAgYXMgQ29tcG9uZW50VHlwZSxcbiAgICAgIHN0eWxlU2hlZXRzOiBbXG4gICAgICAgIC8qIC9fYXBwIGRvZXMgbm90IG5lZWQgaXRzIHN0eWxlc2hlZXRzIG1hbmFnZWQgKi9cbiAgICAgIF0sXG4gICAgfVxuXG4gICAgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3IgUm91dGVyLnJvdXRlci5ldmVudHNcbiAgICAvLyBUT0RPOiBTaG91bGQgYmUgcmVtb3ZlIHRoZSBmb2xsb3dpbmcgbWFqb3IgdmVyc2lvbiBhcyBpdCB3YXMgbmV2ZXIgZG9jdW1lbnRlZFxuICAgIHRoaXMuZXZlbnRzID0gUm91dGVyLmV2ZW50c1xuXG4gICAgdGhpcy5wYWdlTG9hZGVyID0gcGFnZUxvYWRlclxuICAgIHRoaXMucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgIHRoaXMucXVlcnkgPSBxdWVyeVxuICAgIC8vIGlmIGF1dG8gcHJlcmVuZGVyZWQgYW5kIGR5bmFtaWMgcm91dGUgd2FpdCB0byB1cGRhdGUgYXNQYXRoXG4gICAgLy8gdW50aWwgYWZ0ZXIgbW91bnQgdG8gcHJldmVudCBoeWRyYXRpb24gbWlzbWF0Y2hcbiAgICBjb25zdCBhdXRvRXhwb3J0RHluYW1pYyA9XG4gICAgICBpc0R5bmFtaWNSb3V0ZShwYXRobmFtZSkgJiYgc2VsZi5fX05FWFRfREFUQV9fLmF1dG9FeHBvcnRcblxuICAgIHRoaXMuYXNQYXRoID0gYXV0b0V4cG9ydER5bmFtaWMgPyBwYXRobmFtZSA6IGFzXG4gICAgdGhpcy5iYXNlUGF0aCA9IGJhc2VQYXRoXG4gICAgdGhpcy5zdWIgPSBzdWJzY3JpcHRpb25cbiAgICB0aGlzLmNsYyA9IG51bGxcbiAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcFxuICAgIC8vIG1ha2Ugc3VyZSB0byBpZ25vcmUgZXh0cmEgcG9wU3RhdGUgaW4gc2FmYXJpIG9uIG5hdmlnYXRpbmdcbiAgICAvLyBiYWNrIGZyb20gZXh0ZXJuYWwgc2l0ZVxuICAgIHRoaXMuaXNTc3IgPSB0cnVlXG5cbiAgICB0aGlzLmlzRmFsbGJhY2sgPSBpc0ZhbGxiYWNrXG5cbiAgICB0aGlzLmlzUmVhZHkgPSAhIShcbiAgICAgIHNlbGYuX19ORVhUX0RBVEFfXy5nc3NwIHx8XG4gICAgICBzZWxmLl9fTkVYVF9EQVRBX18uZ2lwIHx8XG4gICAgICAoIWF1dG9FeHBvcnREeW5hbWljICYmICFzZWxmLmxvY2F0aW9uLnNlYXJjaClcbiAgICApXG4gICAgdGhpcy5pc1ByZXZpZXcgPSAhIWlzUHJldmlld1xuICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSBmYWxzZVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgIHRoaXMubG9jYWxlID0gbG9jYWxlXG4gICAgICB0aGlzLmxvY2FsZXMgPSBsb2NhbGVzXG4gICAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlXG4gICAgICB0aGlzLmRvbWFpbkxvY2FsZXMgPSBkb21haW5Mb2NhbGVzXG4gICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gISFkZXRlY3REb21haW5Mb2NhbGUoXG4gICAgICAgIGRvbWFpbkxvY2FsZXMsXG4gICAgICAgIHNlbGYubG9jYXRpb24uaG9zdG5hbWVcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBcImFzXCIgZG9lc24ndCBzdGFydCB3aXRoIGRvdWJsZSBzbGFzaGVzIG9yIGVsc2UgaXQgY2FuXG4gICAgICAvLyB0aHJvdyBhbiBlcnJvciBhcyBpdCdzIGNvbnNpZGVyZWQgaW52YWxpZFxuICAgICAgaWYgKGFzLnN1YnN0cigwLCAyKSAhPT0gJy8vJykge1xuICAgICAgICAvLyBpbiBvcmRlciBmb3IgYGUuc3RhdGVgIHRvIHdvcmsgb24gdGhlIGBvbnBvcHN0YXRlYCBldmVudFxuICAgICAgICAvLyB3ZSBoYXZlIHRvIHJlZ2lzdGVyIHRoZSBpbml0aWFsIHJvdXRlIHVwb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgICBmb3JtYXRXaXRoVmFsaWRhdGlvbih7IHBhdGhuYW1lOiBhZGRCYXNlUGF0aChwYXRobmFtZSksIHF1ZXJ5IH0pLFxuICAgICAgICAgIGdldFVSTCgpLFxuICAgICAgICAgIHsgbG9jYWxlIH1cbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLm9uUG9wU3RhdGUpXG5cbiAgICAgIC8vIGVuYWJsZSBjdXN0b20gc2Nyb2xsIHJlc3RvcmF0aW9uIGhhbmRsaW5nIHdoZW4gYXZhaWxhYmxlXG4gICAgICAvLyBvdGhlcndpc2UgZmFsbGJhY2sgdG8gYnJvd3NlcidzIGRlZmF1bHQgaGFuZGxpbmdcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gJ21hbnVhbCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uUG9wU3RhdGUgPSAoZTogUG9wU3RhdGVFdmVudCk6IHZvaWQgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gZS5zdGF0ZSBhcyBIaXN0b3J5U3RhdGVcblxuICAgIGlmICghc3RhdGUpIHtcbiAgICAgIC8vIFdlIGdldCBzdGF0ZSBhcyB1bmRlZmluZWQgZm9yIHR3byByZWFzb25zLlxuICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXG4gICAgICAvLyAgMi4gV2hlbiB0aGUgVVJMIGNoYW5nZWQgd2l0aCAjXG4gICAgICAvL1xuICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cbiAgICAgIC8vIChhcyBpdCdzIGFscmVhZHkgY2hhbmdlZClcbiAgICAgIC8vIEJ1dCB3ZSBjYW4gc2ltcGx5IHJlcGxhY2UgdGhlIHN0YXRlIHdpdGggdGhlIG5ldyBjaGFuZ2VzLlxuICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxuICAgICAgLy8gU28sIGRvaW5nIHRoZSBmb2xsb3dpbmcgZm9yICgxKSBkb2VzIG5vIGhhcm0uXG4gICAgICBjb25zdCB7IHBhdGhuYW1lLCBxdWVyeSB9ID0gdGhpc1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSwgcXVlcnkgfSksXG4gICAgICAgIGdldFVSTCgpXG4gICAgICApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIXN0YXRlLl9fTikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGZvcmNlZFNjcm9sbDogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgdW5kZWZpbmVkXG4gICAgY29uc3QgeyB1cmwsIGFzLCBvcHRpb25zLCBpZHggfSA9IHN0YXRlXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICBpZiAodGhpcy5faWR4ICE9PSBpZHgpIHtcbiAgICAgICAgICAvLyBTbmFwc2hvdCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgICAgICAgJ19fbmV4dF9zY3JvbGxfJyArIHRoaXMuX2lkeCxcbiAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoeyB4OiBzZWxmLnBhZ2VYT2Zmc2V0LCB5OiBzZWxmLnBhZ2VZT2Zmc2V0IH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSBjYXRjaCB7fVxuXG4gICAgICAgICAgLy8gUmVzdG9yZSBvbGQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnX19uZXh0X3Njcm9sbF8nICsgaWR4KVxuICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0gSlNPTi5wYXJzZSh2ISlcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IHsgeDogMCwgeTogMCB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2lkeCA9IGlkeFxuXG4gICAgY29uc3QgeyBwYXRobmFtZSB9ID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgcmUtcmVuZGVyIG9uIGluaXRpYWwgbG9hZCxcbiAgICAvLyBjYW4gYmUgY2F1c2VkIGJ5IG5hdmlnYXRpbmcgYmFjayBmcm9tIGFuIGV4dGVybmFsIHNpdGVcbiAgICBpZiAodGhpcy5pc1NzciAmJiBhcyA9PT0gdGhpcy5hc1BhdGggJiYgcGF0aG5hbWUgPT09IHRoaXMucGF0aG5hbWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cbiAgICAvLyBUaGV5IHdpbGwgdGhlbiBiZSByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGhlIGV2ZW50LlxuICAgIGlmICh0aGlzLl9icHMgJiYgIXRoaXMuX2JwcyhzdGF0ZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY2hhbmdlKFxuICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICB1cmwsXG4gICAgICBhcyxcbiAgICAgIE9iamVjdC5hc3NpZ248e30sIFRyYW5zaXRpb25PcHRpb25zLCBUcmFuc2l0aW9uT3B0aW9ucz4oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgc2hhbGxvdzogb3B0aW9ucy5zaGFsbG93ICYmIHRoaXMuX3NoYWxsb3csXG4gICAgICAgIGxvY2FsZTogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlLFxuICAgICAgfSksXG4gICAgICBmb3JjZWRTY3JvbGxcbiAgICApXG4gIH1cblxuICByZWxvYWQoKTogdm9pZCB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gIH1cblxuICAvKipcbiAgICogR28gYmFjayBpbiBoaXN0b3J5XG4gICAqL1xuICBiYWNrKCkge1xuICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHB1c2hTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqL1xuICBwdXNoKHVybDogVXJsLCBhcz86IFVybCwgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAvLyBUT0RPOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSB3aGVuIHdlIHVwZGF0ZSBoaXN0b3J5IGJlZm9yZSByb3V0ZSBjaGFuZ2VcbiAgICAgIC8vIGlzIGNvbXBsZXRlLCBhcyB0aGUgcG9wc3RhdGUgZXZlbnQgc2hvdWxkIGhhbmRsZSB0aGlzIGNhcHR1cmUuXG4gICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBTbmFwc2hvdCBzY3JvbGwgcG9zaXRpb24gcmlnaHQgYmVmb3JlIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZTpcbiAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgICAgJ19fbmV4dF9zY3JvbGxfJyArIHRoaXMuX2lkeCxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHsgeDogc2VsZi5wYWdlWE9mZnNldCwgeTogc2VsZi5wYWdlWU9mZnNldCB9KVxuICAgICAgICAgIClcbiAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgfVxuICAgIH1cbiAgICA7KHsgdXJsLCBhcyB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKVxuICAgIHJldHVybiB0aGlzLmNoYW5nZSgncHVzaFN0YXRlJywgdXJsLCBhcywgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIGByZXBsYWNlU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi9cbiAgcmVwbGFjZSh1cmw6IFVybCwgYXM/OiBVcmwsIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zID0ge30pIHtcbiAgICA7KHsgdXJsLCBhcyB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKVxuICAgIHJldHVybiB0aGlzLmNoYW5nZSgncmVwbGFjZVN0YXRlJywgdXJsLCBhcywgb3B0aW9ucylcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY2hhbmdlKFxuICAgIG1ldGhvZDogSGlzdG9yeU1ldGhvZCxcbiAgICB1cmw6IHN0cmluZyxcbiAgICBhczogc3RyaW5nLFxuICAgIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zLFxuICAgIGZvcmNlZFNjcm9sbD86IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfVxuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoIWlzTG9jYWxVUkwodXJsKSkge1xuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmxcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIGZvciBzdGF0aWMgcGFnZXMgd2l0aCBxdWVyeSBwYXJhbXMgaW4gdGhlIFVSTCB3ZSBkZWxheVxuICAgIC8vIG1hcmtpbmcgdGhlIHJvdXRlciByZWFkeSB1bnRpbCBhZnRlciB0aGUgcXVlcnkgaXMgdXBkYXRlZFxuICAgIGlmICgob3B0aW9ucyBhcyBhbnkpLl9oKSB7XG4gICAgICB0aGlzLmlzUmVhZHkgPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byBzY3JvbGwgcmVzZXQgYmVoYXZpb3IgdW5sZXNzIGV4cGxpY2l0bHkgc3BlY2lmaWVkIHRvIGJlXG4gICAgLy8gYGZhbHNlYCEgVGhpcyBtYWtlcyB0aGUgYmVoYXZpb3IgYmV0d2VlbiB1c2luZyBgUm91dGVyI3B1c2hgIGFuZCBhXG4gICAgLy8gYDxMaW5rIC8+YCBjb25zaXN0ZW50LlxuICAgIG9wdGlvbnMuc2Nyb2xsID0gISEob3B0aW9ucy5zY3JvbGwgPz8gdHJ1ZSlcblxuICAgIGxldCBsb2NhbGVDaGFuZ2UgPSBvcHRpb25zLmxvY2FsZSAhPT0gdGhpcy5sb2NhbGVcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICB0aGlzLmxvY2FsZSA9XG4gICAgICAgIG9wdGlvbnMubG9jYWxlID09PSBmYWxzZVxuICAgICAgICAgID8gdGhpcy5kZWZhdWx0TG9jYWxlXG4gICAgICAgICAgOiBvcHRpb25zLmxvY2FsZSB8fCB0aGlzLmxvY2FsZVxuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvcHRpb25zLmxvY2FsZSA9IHRoaXMubG9jYWxlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChoYXNCYXNlUGF0aChhcykgPyBkZWxCYXNlUGF0aChhcykgOiBhcylcbiAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSBub3JtYWxpemVMb2NhbGVQYXRoKFxuICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSxcbiAgICAgICAgdGhpcy5sb2NhbGVzXG4gICAgICApXG5cbiAgICAgIGlmIChsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlKSB7XG4gICAgICAgIHRoaXMubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZVxuICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGFkZEJhc2VQYXRoKHBhcnNlZEFzLnBhdGhuYW1lKVxuICAgICAgICBhcyA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKVxuICAgICAgICB1cmwgPSBhZGRCYXNlUGF0aChcbiAgICAgICAgICBub3JtYWxpemVMb2NhbGVQYXRoKFxuICAgICAgICAgICAgaGFzQmFzZVBhdGgodXJsKSA/IGRlbEJhc2VQYXRoKHVybCkgOiB1cmwsXG4gICAgICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgICAgICApLnBhdGhuYW1lXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGxldCBkaWROYXZpZ2F0ZSA9IGZhbHNlXG5cbiAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAvLyBpZiB0aGUgbG9jYWxlIGlzbid0IGNvbmZpZ3VyZWQgaGFyZCBuYXZpZ2F0ZSB0byBzaG93IDQwNCBwYWdlXG4gICAgICAgIGlmICghdGhpcy5sb2NhbGVzPy5pbmNsdWRlcyh0aGlzLmxvY2FsZSEpKSB7XG4gICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBhZGRMb2NhbGUocGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlKVxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpXG4gICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKFxuICAgICAgICB0aGlzLmRvbWFpbkxvY2FsZXMsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdGhpcy5sb2NhbGVcbiAgICAgIClcblxuICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIC8vIGlmIHdlIGFyZSBuYXZpZ2F0aW5nIHRvIGEgZG9tYWluIGxvY2FsZSBlbnN1cmUgd2UgcmVkaXJlY3QgdG8gdGhlXG4gICAgICAgIC8vIGNvcnJlY3QgZG9tYWluXG4gICAgICAgIGlmIChcbiAgICAgICAgICAhZGlkTmF2aWdhdGUgJiZcbiAgICAgICAgICBkZXRlY3RlZERvbWFpbiAmJlxuICAgICAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gJiZcbiAgICAgICAgICBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICE9PSBkZXRlY3RlZERvbWFpbi5kb21haW5cbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgYXNOb0Jhc2VQYXRoID0gZGVsQmFzZVBhdGgoYXMpXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBgaHR0cCR7ZGV0ZWN0ZWREb21haW4uaHR0cCA/ICcnIDogJ3MnfTovLyR7XG4gICAgICAgICAgICBkZXRlY3RlZERvbWFpbi5kb21haW5cbiAgICAgICAgICB9JHthZGRCYXNlUGF0aChcbiAgICAgICAgICAgIGAke1xuICAgICAgICAgICAgICB0aGlzLmxvY2FsZSA9PT0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZVxuICAgICAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgICAgICA6IGAvJHt0aGlzLmxvY2FsZX1gXG4gICAgICAgICAgICB9JHthc05vQmFzZVBhdGggPT09ICcvJyA/ICcnIDogYXNOb0Jhc2VQYXRofWAgfHwgJy8nXG4gICAgICAgICAgKX1gXG4gICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWROYXZpZ2F0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge30pXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEob3B0aW9ucyBhcyBhbnkpLl9oKSB7XG4gICAgICB0aGlzLmlzU3NyID0gZmFsc2VcbiAgICB9XG4gICAgLy8gbWFya2luZyByb3V0ZSBjaGFuZ2VzIGFzIGEgbmF2aWdhdGlvbiBzdGFydCBlbnRyeVxuICAgIGlmIChTVCkge1xuICAgICAgcGVyZm9ybWFuY2UubWFyaygncm91dGVDaGFuZ2UnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2hhbGxvdyA9IGZhbHNlIH0gPSBvcHRpb25zXG4gICAgY29uc3Qgcm91dGVQcm9wcyA9IHsgc2hhbGxvdyB9XG5cbiAgICBpZiAodGhpcy5faW5GbGlnaHRSb3V0ZSkge1xuICAgICAgdGhpcy5hYm9ydENvbXBvbmVudExvYWQodGhpcy5faW5GbGlnaHRSb3V0ZSwgcm91dGVQcm9wcylcbiAgICB9XG5cbiAgICBhcyA9IGFkZEJhc2VQYXRoKFxuICAgICAgYWRkTG9jYWxlKFxuICAgICAgICBoYXNCYXNlUGF0aChhcykgPyBkZWxCYXNlUGF0aChhcykgOiBhcyxcbiAgICAgICAgb3B0aW9ucy5sb2NhbGUsXG4gICAgICAgIHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgKVxuICAgIClcbiAgICBjb25zdCBjbGVhbmVkQXMgPSBkZWxMb2NhbGUoXG4gICAgICBoYXNCYXNlUGF0aChhcykgPyBkZWxCYXNlUGF0aChhcykgOiBhcyxcbiAgICAgIHRoaXMubG9jYWxlXG4gICAgKVxuICAgIHRoaXMuX2luRmxpZ2h0Um91dGUgPSBhc1xuXG4gICAgLy8gSWYgdGhlIHVybCBjaGFuZ2UgaXMgb25seSByZWxhdGVkIHRvIGEgaGFzaCBjaGFuZ2VcbiAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXG5cbiAgICAvLyBXQVJOSU5HOiBgX2hgIGlzIGFuIGludGVybmFsIG9wdGlvbiBmb3IgaGFuZGluZyBOZXh0LmpzIGNsaWVudC1zaWRlXG4gICAgLy8gaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS4gSXQgbWF5IGNoYW5nZSBhdFxuICAgIC8vIGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgIGlmICghKG9wdGlvbnMgYXMgYW55KS5faCAmJiB0aGlzLm9ubHlBSGFzaENoYW5nZShjbGVhbmVkQXMpKSB7XG4gICAgICB0aGlzLmFzUGF0aCA9IGNsZWFuZWRBc1xuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlU3RhcnQnLCBhcywgcm91dGVQcm9wcylcbiAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdGhlIHJlc29sdmVkIGhyZWYgd2hlbiBvbmx5IGEgaGFzaCBjaGFuZ2U/XG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucylcbiAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGNsZWFuZWRBcylcbiAgICAgIHRoaXMubm90aWZ5KHRoaXMuY29tcG9uZW50c1t0aGlzLnJvdXRlXSwgbnVsbClcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZUNvbXBsZXRlJywgYXMsIHJvdXRlUHJvcHMpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGxldCBwYXJzZWQgPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcbiAgICBsZXQgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHBhcnNlZFxuXG4gICAgLy8gVGhlIGJ1aWxkIG1hbmlmZXN0IG5lZWRzIHRvIGJlIGxvYWRlZCBiZWZvcmUgYXV0by1zdGF0aWMgZHluYW1pYyBwYWdlc1xuICAgIC8vIGdldCB0aGVpciBxdWVyeSBwYXJhbWV0ZXJzIHRvIGFsbG93IGVuc3VyaW5nIHRoZXkgY2FuIGJlIHBhcnNlZCBwcm9wZXJseVxuICAgIC8vIHdoZW4gcmV3cml0dGVuIHRvXG4gICAgbGV0IHBhZ2VzOiBhbnksIHJld3JpdGVzOiBhbnlcbiAgICB0cnkge1xuICAgICAgcGFnZXMgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKVxuICAgICAgOyh7IF9fcmV3cml0ZXM6IHJld3JpdGVzIH0gPSBhd2FpdCBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJZiB3ZSBmYWlsIHRvIHJlc29sdmUgdGhlIHBhZ2UgbGlzdCBvciBjbGllbnQtYnVpbGQgbWFuaWZlc3QsIHdlIG11c3RcbiAgICAgIC8vIGRvIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbjpcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXNcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIGFza2VkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBVUkwgd2Ugc2hvdWxkIHJlbG9hZCB0aGUgY3VycmVudCBwYWdlXG4gICAgLy8gKG5vdCBsb2NhdGlvbi5yZWxvYWQoKSBidXQgcmVsb2FkIGdldEluaXRpYWxQcm9wcyBhbmQgb3RoZXIgTmV4dC5qcyBzdHVmZnMpXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIHNldCB0aGUgbWV0aG9kID0gcmVwbGFjZVN0YXRlIGFsd2F5c1xuICAgIC8vIGFzIHRoaXMgc2hvdWxkIG5vdCBnbyBpbnRvIHRoZSBoaXN0b3J5IChUaGF0J3MgaG93IGJyb3dzZXJzIHdvcmspXG4gICAgLy8gV2Ugc2hvdWxkIGNvbXBhcmUgdGhlIG5ldyBhc1BhdGggdG8gdGhlIGN1cnJlbnQgYXNQYXRoLCBub3QgdGhlIHVybFxuICAgIGlmICghdGhpcy51cmxJc05ldyhjbGVhbmVkQXMpICYmICFsb2NhbGVDaGFuZ2UpIHtcbiAgICAgIG1ldGhvZCA9ICdyZXBsYWNlU3RhdGUnXG4gICAgfVxuXG4gICAgLy8gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBhcyB2YWx1ZSB1c2luZyByZXdyaXRlcyBmb3IgZHluYW1pYyBTU0dcbiAgICAvLyBwYWdlcyB0byBhbGxvdyBidWlsZGluZyB0aGUgZGF0YSBVUkwgY29ycmVjdGx5XG4gICAgbGV0IHJlc29sdmVkQXMgPSBhc1xuXG4gICAgLy8gdXJsIGFuZCBhcyBzaG91bGQgYWx3YXlzIGJlIHByZWZpeGVkIHdpdGggYmFzZVBhdGggYnkgdGhpc1xuICAgIC8vIHBvaW50IGJ5IGVpdGhlciBuZXh0L2xpbmsgb3Igcm91dGVyLnB1c2gvcmVwbGFjZSBzbyBzdHJpcCB0aGVcbiAgICAvLyBiYXNlUGF0aCBmcm9tIHRoZSBwYXRobmFtZSB0byBtYXRjaCB0aGUgcGFnZXMgZGlyIDEtdG8tMVxuICAgIHBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgID8gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goZGVsQmFzZVBhdGgocGF0aG5hbWUpKVxuICAgICAgOiBwYXRobmFtZVxuXG4gICAgaWYgKHBhdGhuYW1lICE9PSAnL19lcnJvcicpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTICYmIGFzLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICBjb25zdCByZXdyaXRlc1Jlc3VsdCA9IHJlc29sdmVSZXdyaXRlcyhcbiAgICAgICAgICBhZGRCYXNlUGF0aChhZGRMb2NhbGUoZGVsQmFzZVBhdGgoYXMpLCB0aGlzLmxvY2FsZSkpLFxuICAgICAgICAgIHBhZ2VzLFxuICAgICAgICAgIHJld3JpdGVzLFxuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIChwOiBzdHJpbmcpID0+IHJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLFxuICAgICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgICApXG4gICAgICAgIHJlc29sdmVkQXMgPSByZXdyaXRlc1Jlc3VsdC5hc1BhdGhcblxuICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWZcbiAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgICAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZSwgcGFnZXMpXG5cbiAgICAgICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZVxuICAgICAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJvdXRlID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG5cbiAgICBpZiAoIWlzTG9jYWxVUkwoYXMpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgaHJlZjogXCIke3VybH1cIiBhbmQgYXM6IFwiJHthc31cIiwgcmVjZWl2ZWQgcmVsYXRpdmUgaHJlZiBhbmQgZXh0ZXJuYWwgYXNgICtcbiAgICAgICAgICAgIGBcXG5TZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLXJlbGF0aXZlLXVybC1leHRlcm5hbC1hc2BcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXNvbHZlZEFzID0gZGVsTG9jYWxlKGRlbEJhc2VQYXRoKHJlc29sdmVkQXMpLCB0aGlzLmxvY2FsZSlcblxuICAgIGlmIChpc0R5bmFtaWNSb3V0ZShyb3V0ZSkpIHtcbiAgICAgIGNvbnN0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChyZXNvbHZlZEFzKVxuICAgICAgY29uc3QgYXNQYXRobmFtZSA9IHBhcnNlZEFzLnBhdGhuYW1lXG5cbiAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSBnZXRSb3V0ZVJlZ2V4KHJvdXRlKVxuICAgICAgY29uc3Qgcm91dGVNYXRjaCA9IGdldFJvdXRlTWF0Y2hlcihyb3V0ZVJlZ2V4KShhc1BhdGhuYW1lKVxuICAgICAgY29uc3Qgc2hvdWxkSW50ZXJwb2xhdGUgPSByb3V0ZSA9PT0gYXNQYXRobmFtZVxuICAgICAgY29uc3QgaW50ZXJwb2xhdGVkQXMgPSBzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICA/IGludGVycG9sYXRlQXMocm91dGUsIGFzUGF0aG5hbWUsIHF1ZXJ5KVxuICAgICAgICA6ICh7fSBhcyB7IHJlc3VsdDogdW5kZWZpbmVkOyBwYXJhbXM6IHVuZGVmaW5lZCB9KVxuXG4gICAgICBpZiAoIXJvdXRlTWF0Y2ggfHwgKHNob3VsZEludGVycG9sYXRlICYmICFpbnRlcnBvbGF0ZWRBcy5yZXN1bHQpKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdQYXJhbXMgPSBPYmplY3Qua2V5cyhyb3V0ZVJlZ2V4Lmdyb3VwcykuZmlsdGVyKFxuICAgICAgICAgIChwYXJhbSkgPT4gIXF1ZXJ5W3BhcmFtXVxuICAgICAgICApXG5cbiAgICAgICAgaWYgKG1pc3NpbmdQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIGAke1xuICAgICAgICAgICAgICAgIHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgICAgICA/IGBJbnRlcnBvbGF0aW5nIGhyZWZgXG4gICAgICAgICAgICAgICAgICA6IGBNaXNtYXRjaGluZyBcXGBhc1xcYCBhbmQgXFxgaHJlZlxcYGBcbiAgICAgICAgICAgICAgfSBmYWlsZWQgdG8gbWFudWFsbHkgcHJvdmlkZSBgICtcbiAgICAgICAgICAgICAgICBgdGhlIHBhcmFtczogJHttaXNzaW5nUGFyYW1zLmpvaW4oXG4gICAgICAgICAgICAgICAgICAnLCAnXG4gICAgICAgICAgICAgICAgKX0gaW4gdGhlIFxcYGhyZWZcXGAncyBcXGBxdWVyeVxcYGBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAoc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgPyBgVGhlIHByb3ZpZGVkIFxcYGhyZWZcXGAgKCR7dXJsfSkgdmFsdWUgaXMgbWlzc2luZyBxdWVyeSB2YWx1ZXMgKCR7bWlzc2luZ1BhcmFtcy5qb2luKFxuICAgICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICAgICl9KSB0byBiZSBpbnRlcnBvbGF0ZWQgcHJvcGVybHkuIGBcbiAgICAgICAgICAgICAgOiBgVGhlIHByb3ZpZGVkIFxcYGFzXFxgIHZhbHVlICgke2FzUGF0aG5hbWV9KSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgXFxgaHJlZlxcYCB2YWx1ZSAoJHtyb3V0ZX0pLiBgKSArXG4gICAgICAgICAgICAgIGBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzLyR7XG4gICAgICAgICAgICAgICAgc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgICAgID8gJ2hyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWQnXG4gICAgICAgICAgICAgICAgICA6ICdpbmNvbXBhdGlibGUtaHJlZi1hcydcbiAgICAgICAgICAgICAgfWBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSW50ZXJwb2xhdGUpIHtcbiAgICAgICAgYXMgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBwYXJzZWRBcywge1xuICAgICAgICAgICAgcGF0aG5hbWU6IGludGVycG9sYXRlZEFzLnJlc3VsdCxcbiAgICAgICAgICAgIHF1ZXJ5OiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnksIGludGVycG9sYXRlZEFzLnBhcmFtcyEpLFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIGBxdWVyeWAsIG92ZXJ3cml0aW5nIGFueSBzcGVjaWZpZWQgaW4gc2VhcmNoXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIHJvdXRlTWF0Y2gpXG4gICAgICB9XG4gICAgfVxuXG4gICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZVN0YXJ0JywgYXMsIHJvdXRlUHJvcHMpXG5cbiAgICB0cnkge1xuICAgICAgbGV0IHJvdXRlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Um91dGVJbmZvKFxuICAgICAgICByb3V0ZSxcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBhcyxcbiAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgcm91dGVQcm9wc1xuICAgICAgKVxuICAgICAgbGV0IHsgZXJyb3IsIHByb3BzLCBfX05fU1NHLCBfX05fU1NQIH0gPSByb3V0ZUluZm9cblxuICAgICAgLy8gaGFuZGxlIHJlZGlyZWN0IG9uIGNsaWVudC10cmFuc2l0aW9uXG4gICAgICBpZiAoKF9fTl9TU0cgfHwgX19OX1NTUCkgJiYgcHJvcHMpIHtcbiAgICAgICAgaWYgKChwcm9wcyBhcyBhbnkpLnBhZ2VQcm9wcyAmJiAocHJvcHMgYXMgYW55KS5wYWdlUHJvcHMuX19OX1JFRElSRUNUKSB7XG4gICAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSAocHJvcHMgYXMgYW55KS5wYWdlUHJvcHMuX19OX1JFRElSRUNUXG5cbiAgICAgICAgICAvLyBjaGVjayBpZiBkZXN0aW5hdGlvbiBpcyBpbnRlcm5hbCAocmVzb2x2ZXMgdG8gYSBwYWdlKSBhbmQgYXR0ZW1wdFxuICAgICAgICAgIC8vIGNsaWVudC1uYXZpZ2F0aW9uIGlmIGl0IGlzIGZhbGxpbmcgYmFjayB0byBoYXJkIG5hdmlnYXRpb24gaWZcbiAgICAgICAgICAvLyBpdCdzIG5vdFxuICAgICAgICAgIGlmIChkZXN0aW5hdGlvbi5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEhyZWYgPSBwYXJzZVJlbGF0aXZlVXJsKGRlc3RpbmF0aW9uKVxuICAgICAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUoXG4gICAgICAgICAgICAgIHBhcnNlZEhyZWYucGF0aG5hbWUsXG4gICAgICAgICAgICAgIHBhZ2VzXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGlmIChwYWdlcy5pbmNsdWRlcyhwYXJzZWRIcmVmLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICBjb25zdCB7IHVybDogbmV3VXJsLCBhczogbmV3QXMgfSA9IHByZXBhcmVVcmxBcyhcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgbmV3VXJsLCBuZXdBcywgb3B0aW9ucylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGRlc3RpbmF0aW9uXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc1ByZXZpZXcgPSAhIXByb3BzLl9fTl9QUkVWSUVXXG5cbiAgICAgICAgLy8gaGFuZGxlIFNTRyBkYXRhIDQwNFxuICAgICAgICBpZiAocHJvcHMubm90Rm91bmQgPT09IFNTR19EQVRBX05PVF9GT1VORCkge1xuICAgICAgICAgIGxldCBub3RGb3VuZFJvdXRlXG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudCgnLzQwNCcpXG4gICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gJy80MDQnXG4gICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9ICcvX2Vycm9yJ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvdXRlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Um91dGVJbmZvKFxuICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgIG5vdEZvdW5kUm91dGUsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgIHsgc2hhbGxvdzogZmFsc2UgfVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLCBhcywgcm91dGVQcm9wcylcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zdCBhcHBDb21wOiBhbnkgPSB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10uQ29tcG9uZW50XG4gICAgICAgIDsod2luZG93IGFzIGFueSkubmV4dC5pc1ByZXJlbmRlcmVkID1cbiAgICAgICAgICBhcHBDb21wLmdldEluaXRpYWxQcm9wcyA9PT0gYXBwQ29tcC5vcmlnR2V0SW5pdGlhbFByb3BzICYmXG4gICAgICAgICAgIShyb3V0ZUluZm8uQ29tcG9uZW50IGFzIGFueSkuZ2V0SW5pdGlhbFByb3BzXG4gICAgICB9XG5cbiAgICAgIC8vIHNoYWxsb3cgcm91dGluZyBpcyBvbmx5IGFsbG93ZWQgZm9yIHNhbWUgcGFnZSBVUkwgY2hhbmdlcy5cbiAgICAgIGNvbnN0IGlzVmFsaWRTaGFsbG93Um91dGUgPSBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGVcblxuICAgICAgaWYgKFxuICAgICAgICAob3B0aW9ucyBhcyBhbnkpLl9oICYmXG4gICAgICAgIHBhdGhuYW1lID09PSAnL19lcnJvcicgJiZcbiAgICAgICAgc2VsZi5fX05FWFRfREFUQV9fLnByb3BzPy5wYWdlUHJvcHM/LnN0YXR1c0NvZGUgPT09IDUwMCAmJlxuICAgICAgICBwcm9wcz8ucGFnZVByb3BzXG4gICAgICApIHtcbiAgICAgICAgLy8gZW5zdXJlIHN0YXR1c0NvZGUgaXMgc3RpbGwgY29ycmVjdCBmb3Igc3RhdGljIDUwMCBwYWdlXG4gICAgICAgIC8vIHdoZW4gdXBkYXRpbmcgcXVlcnkgaW5mb3JtYXRpb25cbiAgICAgICAgcHJvcHMucGFnZVByb3BzLnN0YXR1c0NvZGUgPSA1MDBcbiAgICAgIH1cblxuICAgICAgYXdhaXQgdGhpcy5zZXQoXG4gICAgICAgIHJvdXRlLFxuICAgICAgICBwYXRobmFtZSEsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBjbGVhbmVkQXMsXG4gICAgICAgIHJvdXRlSW5mbyxcbiAgICAgICAgZm9yY2VkU2Nyb2xsIHx8XG4gICAgICAgICAgKGlzVmFsaWRTaGFsbG93Um91dGUgfHwgIW9wdGlvbnMuc2Nyb2xsID8gbnVsbCA6IHsgeDogMCwgeTogMCB9KVxuICAgICAgKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBpZiAoZS5jYW5jZWxsZWQpIGVycm9yID0gZXJyb3IgfHwgZVxuICAgICAgICBlbHNlIHRocm93IGVcbiAgICAgIH0pXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnJvciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICBpZiAodGhpcy5sb2NhbGUpIHtcbiAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZyA9IHRoaXMubG9jYWxlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VDb21wbGV0ZScsIGFzLCByb3V0ZVByb3BzKVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICBjaGFuZ2VTdGF0ZShcbiAgICBtZXRob2Q6IEhpc3RvcnlNZXRob2QsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYXM6IHN0cmluZyxcbiAgICBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9XG4gICk6IHZvaWQge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeSBpcyBub3QgYXZhaWxhYmxlLmApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LiR7bWV0aG9kfSBpcyBub3QgYXZhaWxhYmxlYClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgfHwgZ2V0VVJMKCkgIT09IGFzKSB7XG4gICAgICB0aGlzLl9zaGFsbG93ID0gb3B0aW9ucy5zaGFsbG93XG4gICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKFxuICAgICAgICB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGFzLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgX19OOiB0cnVlLFxuICAgICAgICAgIGlkeDogdGhpcy5faWR4ID0gbWV0aG9kICE9PSAncHVzaFN0YXRlJyA/IHRoaXMuX2lkeCA6IHRoaXMuX2lkeCArIDEsXG4gICAgICAgIH0gYXMgSGlzdG9yeVN0YXRlLFxuICAgICAgICAvLyBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBpZ25vcmVzIHRoaXMgcGFyYW1ldGVyLCBhbHRob3VnaCB0aGV5IG1heSB1c2UgaXQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgLy8gUGFzc2luZyB0aGUgZW1wdHkgc3RyaW5nIGhlcmUgc2hvdWxkIGJlIHNhZmUgYWdhaW5zdCBmdXR1cmUgY2hhbmdlcyB0byB0aGUgbWV0aG9kLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGlzdG9yeS9yZXBsYWNlU3RhdGVcbiAgICAgICAgJycsXG4gICAgICAgIGFzXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgaGFuZGxlUm91dGVJbmZvRXJyb3IoXG4gICAgZXJyOiBFcnJvciAmIHsgY29kZTogYW55OyBjYW5jZWxsZWQ6IGJvb2xlYW4gfSxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgICBhczogc3RyaW5nLFxuICAgIHJvdXRlUHJvcHM6IFJvdXRlUHJvcGVydGllcyxcbiAgICBsb2FkRXJyb3JGYWlsPzogYm9vbGVhblxuICApOiBQcm9taXNlPENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbz4ge1xuICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAvLyBidWJibGUgdXAgY2FuY2VsbGF0aW9uIGVycm9yc1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgaWYgKGlzQXNzZXRFcnJvcihlcnIpIHx8IGxvYWRFcnJvckZhaWwpIHtcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgYXMsIHJvdXRlUHJvcHMpXG5cbiAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAvLyAgMS4gUGFnZSBkb2Vzbid0IGV4aXN0c1xuICAgICAgLy8gIDIuIFBhZ2UgZG9lcyBleGlzdCBpbiBhIGRpZmZlcmVudCB6b25lXG4gICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuXG4gICAgICAvLyBTbywgZG9pbmcgYSBoYXJkIHJlbG9hZCBpcyB0aGUgcHJvcGVyIHdheSB0byBkZWFsIHdpdGggdGhpcy5cbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXNcblxuICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAvLyBTbyBsZXQncyB0aHJvdyBhIGNhbmNlbGxhdGlvbiBlcnJvciBzdG9wIHRoZSByb3V0aW5nIGxvZ2ljLlxuICAgICAgdGhyb3cgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgICAgIGxldCBzdHlsZVNoZWV0czogU3R5bGVTaGVldFR1cGxlW11cbiAgICAgIGxldCBwcm9wczogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZFxuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBDb21wb25lbnQhID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygc3R5bGVTaGVldHMhID09PSAndW5kZWZpbmVkJ1xuICAgICAgKSB7XG4gICAgICAgIDsoeyBwYWdlOiBDb21wb25lbnQsIHN0eWxlU2hlZXRzIH0gPSBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KFxuICAgICAgICAgICcvX2Vycm9yJ1xuICAgICAgICApKVxuICAgICAgfVxuXG4gICAgICBjb25zdCByb3V0ZUluZm86IENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbyA9IHtcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgc3R5bGVTaGVldHMsXG4gICAgICAgIGVycixcbiAgICAgICAgZXJyb3I6IGVycixcbiAgICAgIH1cblxuICAgICAgaWYgKCFyb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIHtcbiAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgfSBhcyBhbnkpXG4gICAgICAgIH0gY2F0Y2ggKGdpcEVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6ICcsIGdpcEVycilcbiAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSB7fVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByb3V0ZUluZm9cbiAgICB9IGNhdGNoIChyb3V0ZUluZm9FcnIpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKFxuICAgICAgICByb3V0ZUluZm9FcnIsXG4gICAgICAgIHBhdGhuYW1lLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgYXMsXG4gICAgICAgIHJvdXRlUHJvcHMsXG4gICAgICAgIHRydWVcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRSb3V0ZUluZm8oXG4gICAgcm91dGU6IHN0cmluZyxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBhbnksXG4gICAgYXM6IHN0cmluZyxcbiAgICByZXNvbHZlZEFzOiBzdHJpbmcsXG4gICAgcm91dGVQcm9wczogUm91dGVQcm9wZXJ0aWVzXG4gICk6IFByb21pc2U8UHJpdmF0ZVJvdXRlSW5mbz4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBleGlzdGluZ1JvdXRlSW5mbzogUHJpdmF0ZVJvdXRlSW5mbyB8IHVuZGVmaW5lZCA9IHRoaXMuY29tcG9uZW50c1tcbiAgICAgICAgcm91dGVcbiAgICAgIF1cbiAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdSb3V0ZUluZm8gJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGUpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nUm91dGVJbmZvXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNhY2hlZFJvdXRlSW5mbzogQ29tcGxldGVQcml2YXRlUm91dGVJbmZvIHwgdW5kZWZpbmVkID1cbiAgICAgICAgZXhpc3RpbmdSb3V0ZUluZm8gJiYgJ2luaXRpYWwnIGluIGV4aXN0aW5nUm91dGVJbmZvXG4gICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICA6IGV4aXN0aW5nUm91dGVJbmZvXG4gICAgICBjb25zdCByb3V0ZUluZm86IENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbyA9IGNhY2hlZFJvdXRlSW5mb1xuICAgICAgICA/IGNhY2hlZFJvdXRlSW5mb1xuICAgICAgICA6IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQocm91dGUpLnRoZW4oKHJlcykgPT4gKHtcbiAgICAgICAgICAgIENvbXBvbmVudDogcmVzLnBhZ2UsXG4gICAgICAgICAgICBzdHlsZVNoZWV0czogcmVzLnN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgX19OX1NTRzogcmVzLm1vZC5fX05fU1NHLFxuICAgICAgICAgICAgX19OX1NTUDogcmVzLm1vZC5fX05fU1NQLFxuICAgICAgICAgIH0pKVxuXG4gICAgICBjb25zdCB7IENvbXBvbmVudCwgX19OX1NTRywgX19OX1NTUCB9ID0gcm91dGVJbmZvXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlIH0gPSByZXF1aXJlKCdyZWFjdC1pcycpXG4gICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKENvbXBvbmVudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIiR7cGF0aG5hbWV9XCJgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBkYXRhSHJlZjogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgICAgIGlmIChfX05fU1NHIHx8IF9fTl9TU1ApIHtcbiAgICAgICAgZGF0YUhyZWYgPSB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoXG4gICAgICAgICAgZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZSwgcXVlcnkgfSksXG4gICAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgICBfX05fU1NHLFxuICAgICAgICAgIHRoaXMubG9jYWxlXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvcHMgPSBhd2FpdCB0aGlzLl9nZXREYXRhPENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbz4oKCkgPT5cbiAgICAgICAgX19OX1NTR1xuICAgICAgICAgID8gdGhpcy5fZ2V0U3RhdGljRGF0YShkYXRhSHJlZiEpXG4gICAgICAgICAgOiBfX05fU1NQXG4gICAgICAgICAgPyB0aGlzLl9nZXRTZXJ2ZXJEYXRhKGRhdGFIcmVmISlcbiAgICAgICAgICA6IHRoaXMuZ2V0SW5pdGlhbFByb3BzKFxuICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgIC8vIHdlIHByb3ZpZGUgQXBwVHJlZSBsYXRlciBzbyB0aGlzIG5lZWRzIHRvIGJlIGBhbnlgXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgICB9IGFzIGFueVxuICAgICAgICAgICAgKVxuICAgICAgKVxuXG4gICAgICByb3V0ZUluZm8ucHJvcHMgPSBwcm9wc1xuICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mb1xuICAgICAgcmV0dXJuIHJvdXRlSW5mb1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoZXJyLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzKVxuICAgIH1cbiAgfVxuXG4gIHNldChcbiAgICByb3V0ZTogc3RyaW5nLFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICAgIGFzOiBzdHJpbmcsXG4gICAgZGF0YTogUHJpdmF0ZVJvdXRlSW5mbyxcbiAgICByZXNldFNjcm9sbDogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgbnVsbFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmlzRmFsbGJhY2sgPSBmYWxzZVxuXG4gICAgdGhpcy5yb3V0ZSA9IHJvdXRlXG4gICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5XG4gICAgdGhpcy5hc1BhdGggPSBhc1xuICAgIHJldHVybiB0aGlzLm5vdGlmeShkYXRhLCByZXNldFNjcm9sbClcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0byBleGVjdXRlIGJlZm9yZSByZXBsYWNpbmcgcm91dGVyIHN0YXRlXG4gICAqIEBwYXJhbSBjYiBjYWxsYmFjayB0byBiZSBleGVjdXRlZFxuICAgKi9cbiAgYmVmb3JlUG9wU3RhdGUoY2I6IEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2spIHtcbiAgICB0aGlzLl9icHMgPSBjYlxuICB9XG5cbiAgb25seUFIYXNoQ2hhbmdlKGFzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuYXNQYXRoKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBbb2xkVXJsTm9IYXNoLCBvbGRIYXNoXSA9IHRoaXMuYXNQYXRoLnNwbGl0KCcjJylcbiAgICBjb25zdCBbbmV3VXJsTm9IYXNoLCBuZXdIYXNoXSA9IGFzLnNwbGl0KCcjJylcblxuICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcbiAgICBpZiAobmV3SGFzaCAmJiBvbGRVcmxOb0hhc2ggPT09IG5ld1VybE5vSGFzaCAmJiBvbGRIYXNoID09PSBuZXdIYXNoKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSB1cmxzIGFyZSBjaGFuZ2UsIHRoZXJlJ3MgbW9yZSB0aGFuIGEgaGFzaCBjaGFuZ2VcbiAgICBpZiAob2xkVXJsTm9IYXNoICE9PSBuZXdVcmxOb0hhc2gpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBoYXNoIGhhcyBjaGFuZ2VkLCB0aGVuIGl0J3MgYSBoYXNoIG9ubHkgY2hhbmdlLlxuICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIGhhbmRsZSBib3RoIHRoZSBlbnRlciBhbmRcbiAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxuICAgIC8vIGFuZCBpcyB0cmVhdGVkIGFzIGEgbmV4dCByZWxvYWQuXG4gICAgcmV0dXJuIG9sZEhhc2ggIT09IG5ld0hhc2hcbiAgfVxuXG4gIHNjcm9sbFRvSGFzaChhczogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgWywgaGFzaF0gPSBhcy5zcGxpdCgnIycpXG4gICAgLy8gU2Nyb2xsIHRvIHRvcCBpZiB0aGUgaGFzaCBpcyBqdXN0IGAjYCB3aXRoIG5vIHZhbHVlIG9yIGAjdG9wYFxuICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgIGlmIChoYXNoID09PSAnJyB8fCBoYXNoID09PSAndG9wJykge1xuICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBGaXJzdCB3ZSBjaGVjayBpZiB0aGUgZWxlbWVudCBieSBpZCBpcyBmb3VuZFxuICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKVxuICAgIGlmIChpZEVsKSB7XG4gICAgICBpZEVsLnNjcm9sbEludG9WaWV3KClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIG5vIGVsZW1lbnQgd2l0aCB0aGUgaWQsIHdlIGNoZWNrIHRoZSBgbmFtZWAgcHJvcGVydHlcbiAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICBjb25zdCBuYW1lRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShoYXNoKVswXVxuICAgIGlmIChuYW1lRWwpIHtcbiAgICAgIG5hbWVFbC5zY3JvbGxJbnRvVmlldygpXG4gICAgfVxuICB9XG5cbiAgdXJsSXNOZXcoYXNQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hc1BhdGggIT09IGFzUGF0aFxuICB9XG5cbiAgLyoqXG4gICAqIFByZWZldGNoIHBhZ2UgY29kZSwgeW91IG1heSB3YWl0IGZvciB0aGUgZGF0YSBkdXJpbmcgcGFnZSByZW5kZXJpbmcuXG4gICAqIFRoaXMgZmVhdHVyZSBvbmx5IHdvcmtzIGluIHByb2R1Y3Rpb24hXG4gICAqIEBwYXJhbSB1cmwgdGhlIGhyZWYgb2YgcHJlZmV0Y2hlZCBwYWdlXG4gICAqIEBwYXJhbSBhc1BhdGggdGhlIGFzIHBhdGggb2YgdGhlIHByZWZldGNoZWQgcGFnZVxuICAgKi9cbiAgYXN5bmMgcHJlZmV0Y2goXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYXNQYXRoOiBzdHJpbmcgPSB1cmwsXG4gICAgb3B0aW9uczogUHJlZmV0Y2hPcHRpb25zID0ge31cbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbGV0IHBhcnNlZCA9IHBhcnNlUmVsYXRpdmVVcmwodXJsKVxuXG4gICAgbGV0IHsgcGF0aG5hbWUgfSA9IHBhcnNlZFxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgIGlmIChvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcGF0aG5hbWUgPSBub3JtYWxpemVMb2NhbGVQYXRoIShwYXRobmFtZSwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZVxuICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG5cbiAgICAgICAgbGV0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChhc1BhdGgpXG4gICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSBub3JtYWxpemVMb2NhbGVQYXRoIShcbiAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSxcbiAgICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgICAgKVxuICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWVcbiAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICBhc1BhdGggPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpXG4gICAgbGV0IHJlc29sdmVkQXMgPSBhc1BhdGhcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTICYmIGFzUGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgIGxldCByZXdyaXRlczogYW55XG4gICAgICA7KHsgX19yZXdyaXRlczogcmV3cml0ZXMgfSA9IGF3YWl0IGdldENsaWVudEJ1aWxkTWFuaWZlc3QoKSlcblxuICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSByZXNvbHZlUmV3cml0ZXMoXG4gICAgICAgIGFkZEJhc2VQYXRoKGFkZExvY2FsZShhc1BhdGgsIHRoaXMubG9jYWxlKSksXG4gICAgICAgIHBhZ2VzLFxuICAgICAgICByZXdyaXRlcyxcbiAgICAgICAgcGFyc2VkLnF1ZXJ5LFxuICAgICAgICAocDogc3RyaW5nKSA9PiByZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKSxcbiAgICAgICAgdGhpcy5sb2NhbGVzXG4gICAgICApXG4gICAgICByZXNvbHZlZEFzID0gZGVsTG9jYWxlKGRlbEJhc2VQYXRoKHJld3JpdGVzUmVzdWx0LmFzUGF0aCksIHRoaXMubG9jYWxlKVxuXG4gICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWZcbiAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZC5wYXRobmFtZSwgcGFnZXMpXG5cbiAgICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XG4gICAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lXG4gICAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgcm91dGUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcblxuICAgIC8vIFByZWZldGNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgb24tZGVtYW5kLWVudHJpZXNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5wYWdlTG9hZGVyLl9pc1NzZyhyb3V0ZSkudGhlbigoaXNTc2c6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgcmV0dXJuIGlzU3NnXG4gICAgICAgICAgPyB0aGlzLl9nZXRTdGF0aWNEYXRhKFxuICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICA/IG9wdGlvbnMubG9jYWxlXG4gICAgICAgICAgICAgICAgICA6IHRoaXMubG9jYWxlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGZhbHNlXG4gICAgICB9KSxcbiAgICAgIHRoaXMucGFnZUxvYWRlcltvcHRpb25zLnByaW9yaXR5ID8gJ2xvYWRQYWdlJyA6ICdwcmVmZXRjaCddKHJvdXRlKSxcbiAgICBdKVxuICB9XG5cbiAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGU6IHN0cmluZyk6IFByb21pc2U8R29vZFBhZ2VDYWNoZT4ge1xuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNhbmNlbCA9ICh0aGlzLmNsYyA9ICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWVcbiAgICB9KVxuXG4gICAgY29uc3QgY29tcG9uZW50UmVzdWx0ID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmxvYWRQYWdlKHJvdXRlKVxuXG4gICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcihcbiAgICAgICAgYEFib3J0IGZldGNoaW5nIGNvbXBvbmVudCBmb3Igcm91dGU6IFwiJHtyb3V0ZX1cImBcbiAgICAgIClcbiAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuXG4gICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiBjb21wb25lbnRSZXN1bHRcbiAgfVxuXG4gIF9nZXREYXRhPFQ+KGZuOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG4gICAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZVxuICAgIH1cbiAgICB0aGlzLmNsYyA9IGNhbmNlbFxuICAgIHJldHVybiBmbigpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgIGNvbnN0IGVycjogYW55ID0gbmV3IEVycm9yKCdMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkJylcbiAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRTdGF0aWNEYXRhKGRhdGFIcmVmOiBzdHJpbmcpOiBQcm9taXNlPG9iamVjdD4ge1xuICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgfSA9IG5ldyBVUkwoZGF0YUhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICF0aGlzLmlzUHJldmlldyAmJlxuICAgICAgdGhpcy5zZGNbY2FjaGVLZXldXG4gICAgKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuc2RjW2NhY2hlS2V5XSlcbiAgICB9XG4gICAgcmV0dXJuIGZldGNoTmV4dERhdGEoZGF0YUhyZWYsIHRoaXMuaXNTc3IpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIHRoaXMuc2RjW2NhY2hlS2V5XSA9IGRhdGFcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRTZXJ2ZXJEYXRhKGRhdGFIcmVmOiBzdHJpbmcpOiBQcm9taXNlPG9iamVjdD4ge1xuICAgIGNvbnN0IHsgaHJlZjogcmVzb3VyY2VLZXkgfSA9IG5ldyBVUkwoZGF0YUhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgIGlmICh0aGlzLnNkcltyZXNvdXJjZUtleV0pIHtcbiAgICAgIHJldHVybiB0aGlzLnNkcltyZXNvdXJjZUtleV1cbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLnNkcltyZXNvdXJjZUtleV0gPSBmZXRjaE5leHREYXRhKGRhdGFIcmVmLCB0aGlzLmlzU3NyKVxuICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2RyW3Jlc291cmNlS2V5XVxuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNkcltyZXNvdXJjZUtleV1cbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9KSlcbiAgfVxuXG4gIGdldEluaXRpYWxQcm9wcyhcbiAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGUsXG4gICAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCB7IENvbXBvbmVudDogQXBwIH0gPSB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ11cbiAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHAgYXMgQXBwQ29tcG9uZW50KVxuICAgIGN0eC5BcHBUcmVlID0gQXBwVHJlZVxuICAgIHJldHVybiBsb2FkR2V0SW5pdGlhbFByb3BzPEFwcENvbnRleHRUeXBlPFJvdXRlcj4+KEFwcCwge1xuICAgICAgQXBwVHJlZSxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgIGN0eCxcbiAgICB9KVxuICB9XG5cbiAgYWJvcnRDb21wb25lbnRMb2FkKGFzOiBzdHJpbmcsIHJvdXRlUHJvcHM6IFJvdXRlUHJvcGVydGllcyk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNsYykge1xuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFxuICAgICAgICAncm91dGVDaGFuZ2VFcnJvcicsXG4gICAgICAgIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSxcbiAgICAgICAgYXMsXG4gICAgICAgIHJvdXRlUHJvcHNcbiAgICAgIClcbiAgICAgIHRoaXMuY2xjKClcbiAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIG5vdGlmeShcbiAgICBkYXRhOiBQcml2YXRlUm91dGVJbmZvLFxuICAgIHJlc2V0U2Nyb2xsOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCBudWxsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnN1YihcbiAgICAgIGRhdGEsXG4gICAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10uQ29tcG9uZW50IGFzIEFwcENvbXBvbmVudCxcbiAgICAgIHJlc2V0U2Nyb2xsXG4gICAgKVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/router.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/format-url.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.formatUrl = formatUrl;\n\nvar querystring = _interopRequireWildcard(__webpack_require__(/*! ./querystring */ \"./node_modules/next/dist/next-server/lib/router/utils/querystring.js\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n} // Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nconst slashedProtocols = /https?|ftp|gopher|file/;\n\nfunction formatUrl(urlObj) {\n  let {\n    auth,\n    hostname\n  } = urlObj;\n  let protocol = urlObj.protocol || '';\n  let pathname = urlObj.pathname || '';\n  let hash = urlObj.hash || '';\n  let query = urlObj.query || '';\n  let host = false;\n  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';\n\n  if (urlObj.host) {\n    host = auth + urlObj.host;\n  } else if (hostname) {\n    host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname);\n\n    if (urlObj.port) {\n      host += ':' + urlObj.port;\n    }\n  }\n\n  if (query && typeof query === 'object') {\n    query = String(querystring.urlQueryToSearchParams(query));\n  }\n\n  let search = urlObj.search || query && `?${query}` || '';\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname[0] !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash[0] !== '#') hash = '#' + hash;\n  if (search && search[0] !== '?') search = '?' + search;\n  pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n  search = search.replace('#', '%23');\n  return `${protocol}${host}${pathname}${search}${hash}`;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsLnRzPzEzYzciXSwibmFtZXMiOlsic2xhc2hlZFByb3RvY29scyIsInByb3RvY29sIiwidXJsT2JqIiwicGF0aG5hbWUiLCJoYXNoIiwicXVlcnkiLCJob3N0IiwiYXV0aCIsImVuY29kZVVSSUNvbXBvbmVudCIsImhvc3RuYW1lIiwiU3RyaW5nIiwicXVlcnlzdHJpbmciLCJzZWFyY2giXSwibWFwcGluZ3MiOiI7Ozs7O0FBd0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeEJBLEMsQ0FBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQU1BLE1BQU1BLGdCQUFnQixHQUF0Qjs7QUFFTywyQkFBc0M7QUFDM0MsTUFBSTtBQUFBO0FBQUE7QUFBQSxNQUFKO0FBQ0EsTUFBSUMsUUFBUSxHQUFHQyxNQUFNLENBQU5BLFlBQWY7QUFDQSxNQUFJQyxRQUFRLEdBQUdELE1BQU0sQ0FBTkEsWUFBZjtBQUNBLE1BQUlFLElBQUksR0FBR0YsTUFBTSxDQUFOQSxRQUFYO0FBQ0EsTUFBSUcsS0FBSyxHQUFHSCxNQUFNLENBQU5BLFNBQVo7QUFDQSxNQUFJSSxJQUFvQixHQUF4QjtBQUVBQyxNQUFJLEdBQUdBLElBQUksR0FBR0Msa0JBQWtCLENBQWxCQSxJQUFrQixDQUFsQkEsd0JBQUgsTUFBWEQ7O0FBRUEsTUFBSUwsTUFBTSxDQUFWLE1BQWlCO0FBQ2ZJLFFBQUksR0FBR0MsSUFBSSxHQUFHTCxNQUFNLENBQXBCSTtBQURGLFNBRU8sY0FBYztBQUNuQkEsUUFBSSxHQUFHQyxJQUFJLElBQUksQ0FBQ0UsUUFBUSxDQUFSQSxRQUFELEdBQUNBLENBQUQsR0FBMEIsSUFBR0EsUUFBN0IsTUFBZkgsUUFBVyxDQUFYQTs7QUFDQSxRQUFJSixNQUFNLENBQVYsTUFBaUI7QUFDZkksVUFBSSxJQUFJLE1BQU1KLE1BQU0sQ0FBcEJJO0FBRUg7QUFFRDs7QUFBQSxNQUFJRCxLQUFLLElBQUksaUJBQWIsVUFBd0M7QUFDdENBLFNBQUssR0FBR0ssTUFBTSxDQUFDQyxXQUFXLENBQVhBLHVCQUFmTixLQUFlTSxDQUFELENBQWROO0FBR0Y7O0FBQUEsTUFBSU8sTUFBTSxHQUFHVixNQUFNLENBQU5BLFVBQWtCRyxLQUFLLElBQUssSUFBR0EsS0FBL0JILE1BQWI7QUFFQSxNQUFJRCxRQUFRLElBQUlBLFFBQVEsQ0FBUkEsT0FBZ0IsQ0FBaEJBLE9BQWhCLEtBQTZDQSxRQUFRLElBQVJBOztBQUU3QyxNQUNFQyxNQUFNLENBQU5BLFdBQ0MsQ0FBQyxhQUFhRixnQkFBZ0IsQ0FBaEJBLEtBQWQsUUFBY0EsQ0FBZCxLQUFrRE0sSUFBSSxLQUZ6RCxPQUdFO0FBQ0FBLFFBQUksR0FBRyxRQUFRQSxJQUFJLElBQW5CQSxFQUFPLENBQVBBO0FBQ0EsUUFBSUgsUUFBUSxJQUFJQSxRQUFRLENBQVJBLENBQVEsQ0FBUkEsS0FBaEIsS0FBcUNBLFFBQVEsR0FBRyxNQUFYQTtBQUx2QyxTQU1PLElBQUksQ0FBSixNQUFXO0FBQ2hCRyxRQUFJLEdBQUpBO0FBR0Y7O0FBQUEsTUFBSUYsSUFBSSxJQUFJQSxJQUFJLENBQUpBLENBQUksQ0FBSkEsS0FBWixLQUE2QkEsSUFBSSxHQUFHLE1BQVBBO0FBQzdCLE1BQUlRLE1BQU0sSUFBSUEsTUFBTSxDQUFOQSxDQUFNLENBQU5BLEtBQWQsS0FBaUNBLE1BQU0sR0FBRyxNQUFUQTtBQUVqQ1QsVUFBUSxHQUFHQSxRQUFRLENBQVJBLGlCQUFYQSxrQkFBV0EsQ0FBWEE7QUFDQVMsUUFBTSxHQUFHQSxNQUFNLENBQU5BLGFBQVRBLEtBQVNBLENBQVRBO0FBRUEsU0FBUSxHQUFFWCxRQUFTLEdBQUVLLElBQUssR0FBRUgsUUFBUyxHQUFFUyxNQUFPLEdBQUVSLElBQWhEO0FBQ0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEZvcm1hdCBmdW5jdGlvbiBtb2RpZmllZCBmcm9tIG5vZGVqc1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuXG5jb25zdCBzbGFzaGVkUHJvdG9jb2xzID0gL2h0dHBzP3xmdHB8Z29waGVyfGZpbGUvXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVcmwodXJsT2JqOiBVcmxPYmplY3QpIHtcbiAgbGV0IHsgYXV0aCwgaG9zdG5hbWUgfSA9IHVybE9ialxuICBsZXQgcHJvdG9jb2wgPSB1cmxPYmoucHJvdG9jb2wgfHwgJydcbiAgbGV0IHBhdGhuYW1lID0gdXJsT2JqLnBhdGhuYW1lIHx8ICcnXG4gIGxldCBoYXNoID0gdXJsT2JqLmhhc2ggfHwgJydcbiAgbGV0IHF1ZXJ5ID0gdXJsT2JqLnF1ZXJ5IHx8ICcnXG4gIGxldCBob3N0OiBzdHJpbmcgfCBmYWxzZSA9IGZhbHNlXG5cbiAgYXV0aCA9IGF1dGggPyBlbmNvZGVVUklDb21wb25lbnQoYXV0aCkucmVwbGFjZSgvJTNBL2ksICc6JykgKyAnQCcgOiAnJ1xuXG4gIGlmICh1cmxPYmouaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdXJsT2JqLmhvc3RcbiAgfSBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKH5ob3N0bmFtZS5pbmRleE9mKCc6JykgPyBgWyR7aG9zdG5hbWV9XWAgOiBob3N0bmFtZSlcbiAgICBpZiAodXJsT2JqLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdXJsT2JqLnBvcnRcbiAgICB9XG4gIH1cblxuICBpZiAocXVlcnkgJiYgdHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgIHF1ZXJ5ID0gU3RyaW5nKHF1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkgYXMgUGFyc2VkVXJsUXVlcnkpKVxuICB9XG5cbiAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgKHF1ZXJ5ICYmIGA/JHtxdWVyeX1gKSB8fCAnJ1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6J1xuXG4gIGlmIChcbiAgICB1cmxPYmouc2xhc2hlcyB8fFxuICAgICgoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbHMudGVzdChwcm90b2NvbCkpICYmIGhvc3QgIT09IGZhbHNlKVxuICApIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKVxuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZVswXSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lXG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJydcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2hbMF0gIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2hcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2hbMF0gIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoXG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGVuY29kZVVSSUNvbXBvbmVudClcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJylcblxuICByZXR1cm4gYCR7cHJvdG9jb2x9JHtob3N0fSR7cGF0aG5hbWV9JHtzZWFyY2h9JHtoYXNofWBcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/utils/format-url.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.isDynamicRoute = isDynamicRoute; // Identify /[param]/ in route string\n\nconst TEST_ROUTE = /\\/\\[[^/]+?\\](?=\\/|$)/;\n\nfunction isDynamicRoute(route) {\n  return TEST_ROUTE.test(route);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljLnRzP2NkZTUiXSwibmFtZXMiOlsiVEVTVF9ST1VURSJdLCJtYXBwaW5ncyI6Ijs7O3lDQUFBOztBQUNBLE1BQU1BLFVBQVUsR0FBaEI7O0FBRU8sK0JBQWdEO0FBQ3JELFNBQU9BLFVBQVUsQ0FBVkEsS0FBUCxLQUFPQSxDQUFQO0FBQ0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIElkZW50aWZ5IC9bcGFyYW1dLyBpbiByb3V0ZSBzdHJpbmdcbmNvbnN0IFRFU1RfUk9VVEUgPSAvXFwvXFxbW14vXSs/XFxdKD89XFwvfCQpL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEeW5hbWljUm91dGUocm91dGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gVEVTVF9ST1VURS50ZXN0KHJvdXRlKVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.parseRelativeUrl = parseRelativeUrl;\n\nvar _utils = __webpack_require__(/*! ../../utils */ \"./node_modules/next/dist/next-server/lib/utils.js\");\n\nvar _querystring = __webpack_require__(/*! ./querystring */ \"./node_modules/next/dist/next-server/lib/router/utils/querystring.js\");\n/**\n* Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative\n* (e.g. `./hello`) then at least base must be.\n* Absolute urls are rejected with one exception, in the browser, absolute urls that are on\n* the current origin will be parsed as relative\n*/\n\n\nfunction parseRelativeUrl(url, base) {\n  const globalBase = new URL(true ? 'http://n' : undefined);\n  const resolvedBase = base ? new URL(base, globalBase) : globalBase;\n  const {\n    pathname,\n    searchParams,\n    search,\n    hash,\n    href,\n    origin\n  } = new URL(url, resolvedBase);\n\n  if (origin !== globalBase.origin) {\n    throw new Error(`invariant: invalid relative URL, router received ${url}`);\n  }\n\n  return {\n    pathname,\n    query: (0, _querystring.searchParamsToUrlQuery)(searchParams),\n    search,\n    hash,\n    href: href.slice(globalBase.origin.length)\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmwudHM/OTQwZCJdLCJuYW1lcyI6WyJnbG9iYWxCYXNlIiwicmVzb2x2ZWRCYXNlIiwiYmFzZSIsIm9yaWdpbiIsInVybCIsInF1ZXJ5IiwiaHJlZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08scUNBQXNEO0FBQzNELFFBQU1BLFVBQVUsR0FBRyxRQUNqQixvQkFBNkMsU0FENUIsQ0FBbkI7QUFHQSxRQUFNQyxZQUFZLEdBQUdDLElBQUksR0FBRyxjQUFILFVBQUcsQ0FBSCxHQUF6QjtBQUNBLFFBQU07QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUF5RCxhQUEvRCxZQUErRCxDQUEvRDs7QUFJQSxNQUFJQyxNQUFNLEtBQUtILFVBQVUsQ0FBekIsUUFBa0M7QUFDaEMsVUFBTSxVQUFXLG9EQUFtREksR0FBcEUsRUFBTSxDQUFOO0FBRUY7O0FBQUEsU0FBTztBQUFBO0FBRUxDLFNBQUssRUFBRSx5Q0FGRixZQUVFLENBRkY7QUFBQTtBQUFBO0FBS0xDLFFBQUksRUFBRUEsSUFBSSxDQUFKQSxNQUFXTixVQUFVLENBQVZBLE9BTG5CLE1BS1FNO0FBTEQsR0FBUDtBQU9EIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldExvY2F0aW9uT3JpZ2luIH0gZnJvbSAnLi4vLi4vdXRpbHMnXG5pbXBvcnQgeyBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IH0gZnJvbSAnLi9xdWVyeXN0cmluZydcblxuLyoqXG4gKiBQYXJzZXMgcGF0aC1yZWxhdGl2ZSB1cmxzIChlLmcuIGAvaGVsbG8vd29ybGQ/Zm9vPWJhcmApLiBJZiB1cmwgaXNuJ3QgcGF0aC1yZWxhdGl2ZVxuICogKGUuZy4gYC4vaGVsbG9gKSB0aGVuIGF0IGxlYXN0IGJhc2UgbXVzdCBiZS5cbiAqIEFic29sdXRlIHVybHMgYXJlIHJlamVjdGVkIHdpdGggb25lIGV4Y2VwdGlvbiwgaW4gdGhlIGJyb3dzZXIsIGFic29sdXRlIHVybHMgdGhhdCBhcmUgb25cbiAqIHRoZSBjdXJyZW50IG9yaWdpbiB3aWxsIGJlIHBhcnNlZCBhcyByZWxhdGl2ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZWxhdGl2ZVVybCh1cmw6IHN0cmluZywgYmFzZT86IHN0cmluZykge1xuICBjb25zdCBnbG9iYWxCYXNlID0gbmV3IFVSTChcbiAgICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICdodHRwOi8vbicgOiBnZXRMb2NhdGlvbk9yaWdpbigpXG4gIClcbiAgY29uc3QgcmVzb2x2ZWRCYXNlID0gYmFzZSA/IG5ldyBVUkwoYmFzZSwgZ2xvYmFsQmFzZSkgOiBnbG9iYWxCYXNlXG4gIGNvbnN0IHsgcGF0aG5hbWUsIHNlYXJjaFBhcmFtcywgc2VhcmNoLCBoYXNoLCBocmVmLCBvcmlnaW4gfSA9IG5ldyBVUkwoXG4gICAgdXJsLFxuICAgIHJlc29sdmVkQmFzZVxuICApXG4gIGlmIChvcmlnaW4gIT09IGdsb2JhbEJhc2Uub3JpZ2luKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhcmlhbnQ6IGludmFsaWQgcmVsYXRpdmUgVVJMLCByb3V0ZXIgcmVjZWl2ZWQgJHt1cmx9YClcbiAgfVxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lLFxuICAgIHF1ZXJ5OiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KHNlYXJjaFBhcmFtcyksXG4gICAgc2VhcmNoLFxuICAgIGhhc2gsXG4gICAgaHJlZjogaHJlZi5zbGljZShnbG9iYWxCYXNlLm9yaWdpbi5sZW5ndGgpLFxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/path-match.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/path-match.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nexports.__esModule = true;\nexports.pathToRegexp = exports.default = exports.customRouteMatcherOptions = exports.matcherOptions = void 0;\n\nvar pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ \"./node_modules/next/dist/compiled/path-to-regexp/index.js\"));\n\nexports.pathToRegexp = pathToRegexp;\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst matcherOptions = {\n  sensitive: false,\n  delimiter: '/'\n};\nexports.matcherOptions = matcherOptions;\n\nconst customRouteMatcherOptions = _objectSpread(_objectSpread({}, matcherOptions), {}, {\n  strict: true\n});\n\nexports.customRouteMatcherOptions = customRouteMatcherOptions;\n\nvar _default = (customRoute = false) => {\n  return path => {\n    const keys = [];\n    const matcherRegex = pathToRegexp.pathToRegexp(path, keys, customRoute ? customRouteMatcherOptions : matcherOptions);\n    const matcher = pathToRegexp.regexpToFunction(matcherRegex, keys);\n    return (pathname, params) => {\n      const res = pathname == null ? false : matcher(pathname);\n\n      if (!res) {\n        return false;\n      }\n\n      if (customRoute) {\n        for (const key of keys) {\n          // unnamed params should be removed as they\n          // are not allowed to be used in the destination\n          if (typeof key.name === 'number') {\n            delete res.params[key.name];\n          }\n        }\n      }\n\n      return _objectSpread(_objectSpread({}, params), res.params);\n    };\n  };\n};\n\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9wYXRoLW1hdGNoLnRzP2YxMGEiXSwibmFtZXMiOlsibWF0Y2hlck9wdGlvbnMiLCJzZW5zaXRpdmUiLCJkZWxpbWl0ZXIiLCJjdXN0b21Sb3V0ZU1hdGNoZXJPcHRpb25zIiwic3RyaWN0IiwiY3VzdG9tUm91dGUiLCJwYXRoIiwia2V5cyIsIm1hdGNoZXJSZWdleCIsInBhdGhUb1JlZ2V4cCIsIm1hdGNoZXIiLCJyZXMiLCJwYXRobmFtZSIsImtleSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSU87O0FBQUEsTUFBTUEsY0FDYyxHQUFHO0FBQzVCQyxXQUFTLEVBRG1CO0FBRTVCQyxXQUFTLEVBSEo7QUFDdUIsQ0FEdkI7OztBQU1BLE1BQU1DLHlCQUNjLG1DQUFHLGNBQUg7QUFFekJDLFFBQU0sRUFIRDtBQUNvQixFQURwQjs7OztlQU1RLENBQUNDLFdBQVcsR0FBWixVQUF5QjtBQUN0QyxTQUFRQyxJQUFELElBQWtCO0FBQ3ZCLFVBQU1DLElBQXdCLEdBQTlCO0FBQ0EsVUFBTUMsWUFBWSxHQUFHQyxZQUFZLENBQVpBLHlCQUduQkosV0FBVywrQkFIYixjQUFxQkksQ0FBckI7QUFLQSxVQUFNQyxPQUFPLEdBQUdELFlBQVksQ0FBWkEsK0JBQWhCLElBQWdCQSxDQUFoQjtBQUVBLFdBQU8sc0JBQXVEO0FBQzVELFlBQU1FLEdBQUcsR0FBR0MsUUFBUSxJQUFSQSxlQUEyQkYsT0FBTyxDQUE5QyxRQUE4QyxDQUE5Qzs7QUFDQSxVQUFJLENBQUosS0FBVTtBQUNSO0FBR0Y7O0FBQUEsdUJBQWlCO0FBQ2YsYUFBSyxNQUFMLGFBQXdCO0FBQ3RCO0FBQ0E7QUFDQSxjQUFJLE9BQU9HLEdBQUcsQ0FBVixTQUFKLFVBQWtDO0FBQ2hDLG1CQUFRRixHQUFHLENBQUosTUFBQ0EsQ0FBbUJFLEdBQUcsQ0FBOUIsSUFBUUYsQ0FBUjtBQUVIO0FBQ0Y7QUFFRDs7QUFBQSw2Q0FBTyxNQUFQLEdBQXVCQSxHQUFHLENBQTFCO0FBaEJGO0FBVEYiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcGF0aC1tYXRjaC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHBhdGhUb1JlZ2V4cCBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC10by1yZWdleHAnXG5cbmV4cG9ydCB7IHBhdGhUb1JlZ2V4cCB9XG5cbmV4cG9ydCBjb25zdCBtYXRjaGVyT3B0aW9uczogcGF0aFRvUmVnZXhwLlRva2Vuc1RvUmVnZXhwT3B0aW9ucyAmXG4gIHBhdGhUb1JlZ2V4cC5QYXJzZU9wdGlvbnMgPSB7XG4gIHNlbnNpdGl2ZTogZmFsc2UsXG4gIGRlbGltaXRlcjogJy8nLFxufVxuXG5leHBvcnQgY29uc3QgY3VzdG9tUm91dGVNYXRjaGVyT3B0aW9uczogcGF0aFRvUmVnZXhwLlRva2Vuc1RvUmVnZXhwT3B0aW9ucyAmXG4gIHBhdGhUb1JlZ2V4cC5QYXJzZU9wdGlvbnMgPSB7XG4gIC4uLm1hdGNoZXJPcHRpb25zLFxuICBzdHJpY3Q6IHRydWUsXG59XG5cbmV4cG9ydCBkZWZhdWx0IChjdXN0b21Sb3V0ZSA9IGZhbHNlKSA9PiB7XG4gIHJldHVybiAocGF0aDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qga2V5czogcGF0aFRvUmVnZXhwLktleVtdID0gW11cbiAgICBjb25zdCBtYXRjaGVyUmVnZXggPSBwYXRoVG9SZWdleHAucGF0aFRvUmVnZXhwKFxuICAgICAgcGF0aCxcbiAgICAgIGtleXMsXG4gICAgICBjdXN0b21Sb3V0ZSA/IGN1c3RvbVJvdXRlTWF0Y2hlck9wdGlvbnMgOiBtYXRjaGVyT3B0aW9uc1xuICAgIClcbiAgICBjb25zdCBtYXRjaGVyID0gcGF0aFRvUmVnZXhwLnJlZ2V4cFRvRnVuY3Rpb24obWF0Y2hlclJlZ2V4LCBrZXlzKVxuXG4gICAgcmV0dXJuIChwYXRobmFtZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCwgcGFyYW1zPzogYW55KSA9PiB7XG4gICAgICBjb25zdCByZXMgPSBwYXRobmFtZSA9PSBudWxsID8gZmFsc2UgOiBtYXRjaGVyKHBhdGhuYW1lKVxuICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmIChjdXN0b21Sb3V0ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgLy8gdW5uYW1lZCBwYXJhbXMgc2hvdWxkIGJlIHJlbW92ZWQgYXMgdGhleVxuICAgICAgICAgIC8vIGFyZSBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIHRoZSBkZXN0aW5hdGlvblxuICAgICAgICAgIGlmICh0eXBlb2Yga2V5Lm5hbWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBkZWxldGUgKHJlcy5wYXJhbXMgYXMgYW55KVtrZXkubmFtZV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgLi4ucGFyYW1zLCAuLi5yZXMucGFyYW1zIH1cbiAgICB9XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/utils/path-match.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nexports.__esModule = true;\nexports.matchHas = matchHas;\nexports.compileNonPath = compileNonPath;\nexports.default = prepareDestination;\nexports.getSafeParamName = void 0;\n\nvar _querystring = __webpack_require__(/*! ./querystring */ \"./node_modules/next/dist/next-server/lib/router/utils/querystring.js\");\n\nvar _parseRelativeUrl = __webpack_require__(/*! ./parse-relative-url */ \"./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js\");\n\nvar pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ \"./node_modules/next/dist/compiled/path-to-regexp/index.js\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n} // ensure only a-zA-Z are used for param names for proper interpolating\n// with path-to-regexp\n\n\nconst getSafeParamName = paramName => {\n  let newParamName = '';\n\n  for (let i = 0; i < paramName.length; i++) {\n    const charCode = paramName.charCodeAt(i);\n\n    if (charCode > 64 && charCode < 91 || // A-Z\n    charCode > 96 && charCode < 123 // a-z\n    ) {\n        newParamName += paramName[i];\n      }\n  }\n\n  return newParamName;\n};\n\nexports.getSafeParamName = getSafeParamName;\n\nfunction matchHas(req, has, query) {\n  const params = {};\n  const allMatch = has.every(hasItem => {\n    let value;\n    let key = hasItem.key;\n\n    switch (hasItem.type) {\n      case 'header':\n        {\n          key = key.toLowerCase();\n          value = req.headers[key];\n          break;\n        }\n\n      case 'cookie':\n        {\n          value = req.cookies[hasItem.key];\n          break;\n        }\n\n      case 'query':\n        {\n          value = query[key];\n          break;\n        }\n\n      case 'host':\n        {\n          const {\n            host\n          } = (req == null ? void 0 : req.headers) || {}; // remove port from host if present\n\n          const hostname = host == null ? void 0 : host.split(':')[0].toLowerCase();\n          value = hostname;\n          break;\n        }\n\n      default:\n        {\n          break;\n        }\n    }\n\n    if (!hasItem.value && value) {\n      params[getSafeParamName(key)] = value;\n      return true;\n    } else if (value) {\n      const matcher = new RegExp(`^${hasItem.value}$`);\n      const matches = value.match(matcher);\n\n      if (matches) {\n        if (matches.groups) {\n          Object.keys(matches.groups).forEach(groupKey => {\n            const safeKey = getSafeParamName(groupKey);\n\n            if (safeKey && matches.groups[groupKey]) {\n              params[safeKey] = matches.groups[groupKey];\n            }\n          });\n        } else {\n          params[getSafeParamName(key || 'host')] = matches[0];\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  });\n\n  if (allMatch) {\n    return params;\n  }\n\n  return false;\n}\n\nfunction compileNonPath(value, params) {\n  if (!value.includes(':')) {\n    return value;\n  }\n\n  for (const key of Object.keys(params)) {\n    if (value.includes(`:${key}`)) {\n      value = value.replace(new RegExp(`:${key}\\\\*`, 'g'), `:${key}--ESCAPED_PARAM_ASTERISKS`).replace(new RegExp(`:${key}\\\\?`, 'g'), `:${key}--ESCAPED_PARAM_QUESTION`).replace(new RegExp(`:${key}\\\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`).replace(new RegExp(`:${key}(?!\\\\w)`, 'g'), `--ESCAPED_PARAM_COLON${key}`);\n    }\n  }\n\n  value = value.replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*'); // the value needs to start with a forward-slash to be compiled\n  // correctly\n\n  return pathToRegexp.compile(`/${value}`, {\n    validate: false\n  })(params).substr(1);\n}\n\nfunction prepareDestination(destination, params, query, appendParamsToQuery) {\n  let parsedDestination = {}; // clone query so we don't modify the original\n\n  query = Object.assign({}, query);\n  const hadLocale = query.__nextLocale;\n  delete query.__nextLocale;\n  delete query.__nextDefaultLocale;\n\n  if (destination.startsWith('/')) {\n    parsedDestination = (0, _parseRelativeUrl.parseRelativeUrl)(destination);\n  } else {\n    const {\n      pathname,\n      searchParams,\n      hash,\n      hostname,\n      port,\n      protocol,\n      search,\n      href\n    } = new URL(destination);\n    parsedDestination = {\n      pathname,\n      query: (0, _querystring.searchParamsToUrlQuery)(searchParams),\n      hash,\n      protocol,\n      hostname,\n      port,\n      search,\n      href\n    };\n  }\n\n  const destQuery = parsedDestination.query;\n  const destPath = `${parsedDestination.pathname}${parsedDestination.hash || ''}`;\n  const destPathParamKeys = [];\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys);\n  const destPathParams = destPathParamKeys.map(key => key.name);\n  let destinationCompiler = pathToRegexp.compile(destPath, // we don't validate while compiling the destination since we should\n  // have already validated before we got to this point and validating\n  // breaks compiling destinations with named pattern params from the source\n  // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n  // since compile validation is meant for reversing and not for inserting\n  // params from a separate path-regex into another\n  {\n    validate: false\n  });\n  let newUrl; // update any params in query values\n\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray;\n\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = compileNonPath(value, params);\n    }\n\n    destQuery[key] = value;\n  } // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n\n\n  let paramKeys = Object.keys(params); // remove internal param for i18n\n\n  if (hadLocale) {\n    paramKeys = paramKeys.filter(name => name !== 'nextInternalLocale');\n  }\n\n  if (appendParamsToQuery && !paramKeys.some(key => destPathParams.includes(key))) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = params[key];\n      }\n    }\n  }\n\n  try {\n    newUrl = destinationCompiler(params);\n    const [pathname, hash] = newUrl.split('#');\n    parsedDestination.pathname = pathname;\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`;\n    delete parsedDestination.search;\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(`To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`);\n    }\n\n    throw err;\n  } // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n\n\n  parsedDestination.query = _objectSpread(_objectSpread({}, query), parsedDestination.query);\n  return {\n    newUrl,\n    parsedDestination\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9wcmVwYXJlLWRlc3RpbmF0aW9uLnRzPzM1NjUiXSwibmFtZXMiOlsiZ2V0U2FmZVBhcmFtTmFtZSIsInBhcmFtTmFtZSIsIm5ld1BhcmFtTmFtZSIsImkiLCJjaGFyQ29kZSIsInBhcmFtcyIsImFsbE1hdGNoIiwiaGFzIiwiaGFzSXRlbSIsImtleSIsInZhbHVlIiwicmVxIiwicXVlcnkiLCJob3N0bmFtZSIsImhvc3QiLCJtYXRjaGVyIiwibWF0Y2hlcyIsIk9iamVjdCIsImdyb3VwS2V5Iiwic2FmZUtleSIsInBhdGhUb1JlZ2V4cCIsInZhbGlkYXRlIiwicGFyc2VkRGVzdGluYXRpb24iLCJoYWRMb2NhbGUiLCJkZXN0aW5hdGlvbiIsImRlc3RRdWVyeSIsImRlc3RQYXRoIiwicGF0aG5hbWUiLCJkZXN0UGF0aFBhcmFtS2V5cyIsImRlc3RQYXRoUGFyYW1zIiwiZGVzdGluYXRpb25Db21waWxlciIsIkFycmF5Iiwic3RyT3JBcnJheSIsImNvbXBpbGVOb25QYXRoIiwicGFyYW1LZXlzIiwibmFtZSIsImFwcGVuZFBhcmFtc1RvUXVlcnkiLCJuZXdVcmwiLCJoYXNoIiwiZXJyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUVBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0EsQyxDQUFBO0FBQ0E7OztBQUNPLE1BQU1BLGdCQUFnQixHQUFJQyxTQUFELElBQXVCO0FBQ3JELE1BQUlDLFlBQVksR0FBaEI7O0FBRUEsT0FBSyxJQUFJQyxDQUFDLEdBQVYsR0FBZ0JBLENBQUMsR0FBR0YsU0FBUyxDQUE3QixRQUFzQ0UsQ0FBdEMsSUFBMkM7QUFDekMsVUFBTUMsUUFBUSxHQUFHSCxTQUFTLENBQVRBLFdBQWpCLENBQWlCQSxDQUFqQjs7QUFFQSxRQUNHRyxRQUFRLEdBQVJB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QTVCQTtBQUVBLFVBQU0sbUJBQW1CQSxNQUFNLENBQU5BLE1BQXpCLEdBQXlCQSxDQUF6QjtBQUNBZixxQkFBaUIsQ0FBakJBO0FBQ0FBLHFCQUFpQixDQUFqQkEsT0FBMEIsR0FBRWdCLElBQUksU0FBUyxFQUFHLEdBQUVBLElBQUksSUFBSSxFQUF0RGhCO0FBQ0EsV0FBUUEsaUJBQUQsQ0FBUDtBQUNBLEdBUEYsQ0FPRSxZQUFZO0FBQ1osUUFBSWlCLEdBQUcsQ0FBSEEsY0FBSiw4Q0FBSUEsQ0FBSixFQUF1RTtBQUNyRSxZQUFNLFVBQU4sMktBQU0sQ0FBTjtBQUlGOztBQUFBO0FBR0YsR0E1R0EsQ0E0R0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBakIsbUJBQWlCLENBQWpCQSx3Q0FBMEIsS0FBMUJBLEdBRUtBLGlCQUFpQixDQUZ0QkE7QUFLQSxTQUFPO0FBQUE7QUFBUDtBQUFPLEdBQVA7QUFJRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9wcmVwYXJlLWRlc3RpbmF0aW9uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5jb21pbmdNZXNzYWdlIH0gZnJvbSAnaHR0cCdcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IH0gZnJvbSAnLi9xdWVyeXN0cmluZydcbmltcG9ydCB7IHBhcnNlUmVsYXRpdmVVcmwgfSBmcm9tICcuL3BhcnNlLXJlbGF0aXZlLXVybCdcbmltcG9ydCAqIGFzIHBhdGhUb1JlZ2V4cCBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC10by1yZWdleHAnXG5pbXBvcnQgeyBSb3V0ZUhhcyB9IGZyb20gJy4uLy4uLy4uLy4uL2xpYi9sb2FkLWN1c3RvbS1yb3V0ZXMnXG5cbnR5cGUgUGFyYW1zID0geyBbcGFyYW06IHN0cmluZ106IGFueSB9XG5cbi8vIGVuc3VyZSBvbmx5IGEtekEtWiBhcmUgdXNlZCBmb3IgcGFyYW0gbmFtZXMgZm9yIHByb3BlciBpbnRlcnBvbGF0aW5nXG4vLyB3aXRoIHBhdGgtdG8tcmVnZXhwXG5leHBvcnQgY29uc3QgZ2V0U2FmZVBhcmFtTmFtZSA9IChwYXJhbU5hbWU6IHN0cmluZykgPT4ge1xuICBsZXQgbmV3UGFyYW1OYW1lID0gJydcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtTmFtZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXJDb2RlID0gcGFyYW1OYW1lLmNoYXJDb2RlQXQoaSlcblxuICAgIGlmIChcbiAgICAgIChjaGFyQ29kZSA+IDY0ICYmIGNoYXJDb2RlIDwgOTEpIHx8IC8vIEEtWlxuICAgICAgKGNoYXJDb2RlID4gOTYgJiYgY2hhckNvZGUgPCAxMjMpIC8vIGEtelxuICAgICkge1xuICAgICAgbmV3UGFyYW1OYW1lICs9IHBhcmFtTmFtZVtpXVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3UGFyYW1OYW1lXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaEhhcyhcbiAgcmVxOiBJbmNvbWluZ01lc3NhZ2UsXG4gIGhhczogUm91dGVIYXNbXSxcbiAgcXVlcnk6IFBhcmFtc1xuKTogZmFsc2UgfCBQYXJhbXMge1xuICBjb25zdCBwYXJhbXM6IFBhcmFtcyA9IHt9XG4gIGNvbnN0IGFsbE1hdGNoID0gaGFzLmV2ZXJ5KChoYXNJdGVtKSA9PiB7XG4gICAgbGV0IHZhbHVlOiB1bmRlZmluZWQgfCBzdHJpbmdcbiAgICBsZXQga2V5ID0gaGFzSXRlbS5rZXlcblxuICAgIHN3aXRjaCAoaGFzSXRlbS50eXBlKSB7XG4gICAgICBjYXNlICdoZWFkZXInOiB7XG4gICAgICAgIGtleSA9IGtleSEudG9Mb3dlckNhc2UoKVxuICAgICAgICB2YWx1ZSA9IHJlcS5oZWFkZXJzW2tleV0gYXMgc3RyaW5nXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdjb29raWUnOiB7XG4gICAgICAgIHZhbHVlID0gKHJlcSBhcyBhbnkpLmNvb2tpZXNbaGFzSXRlbS5rZXldXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdxdWVyeSc6IHtcbiAgICAgICAgdmFsdWUgPSBxdWVyeVtrZXkhXVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnaG9zdCc6IHtcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSByZXE/LmhlYWRlcnMgfHwge31cbiAgICAgICAgLy8gcmVtb3ZlIHBvcnQgZnJvbSBob3N0IGlmIHByZXNlbnRcbiAgICAgICAgY29uc3QgaG9zdG5hbWUgPSBob3N0Py5zcGxpdCgnOicpWzBdLnRvTG93ZXJDYXNlKClcbiAgICAgICAgdmFsdWUgPSBob3N0bmFtZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaGFzSXRlbS52YWx1ZSAmJiB2YWx1ZSkge1xuICAgICAgcGFyYW1zW2dldFNhZmVQYXJhbU5hbWUoa2V5ISldID0gdmFsdWVcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgY29uc3QgbWF0Y2hlciA9IG5ldyBSZWdFeHAoYF4ke2hhc0l0ZW0udmFsdWV9JGApXG4gICAgICBjb25zdCBtYXRjaGVzID0gdmFsdWUubWF0Y2gobWF0Y2hlcilcblxuICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKG1hdGNoZXMuZ3JvdXBzKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXMobWF0Y2hlcy5ncm91cHMpLmZvckVhY2goKGdyb3VwS2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzYWZlS2V5ID0gZ2V0U2FmZVBhcmFtTmFtZShncm91cEtleSlcblxuICAgICAgICAgICAgaWYgKHNhZmVLZXkgJiYgbWF0Y2hlcy5ncm91cHMhW2dyb3VwS2V5XSkge1xuICAgICAgICAgICAgICBwYXJhbXNbc2FmZUtleV0gPSBtYXRjaGVzLmdyb3VwcyFbZ3JvdXBLZXldXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJhbXNbZ2V0U2FmZVBhcmFtTmFtZShrZXkgfHwgJ2hvc3QnKV0gPSBtYXRjaGVzWzBdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0pXG5cbiAgaWYgKGFsbE1hdGNoKSB7XG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZU5vblBhdGgodmFsdWU6IHN0cmluZywgcGFyYW1zOiBQYXJhbXMpOiBzdHJpbmcge1xuICBpZiAoIXZhbHVlLmluY2x1ZGVzKCc6JykpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBhcmFtcykpIHtcbiAgICBpZiAodmFsdWUuaW5jbHVkZXMoYDoke2tleX1gKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZVxuICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICBuZXcgUmVnRXhwKGA6JHtrZXl9XFxcXCpgLCAnZycpLFxuICAgICAgICAgIGA6JHtrZXl9LS1FU0NBUEVEX1BBUkFNX0FTVEVSSVNLU2BcbiAgICAgICAgKVxuICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICBuZXcgUmVnRXhwKGA6JHtrZXl9XFxcXD9gLCAnZycpLFxuICAgICAgICAgIGA6JHtrZXl9LS1FU0NBUEVEX1BBUkFNX1FVRVNUSU9OYFxuICAgICAgICApXG4gICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoYDoke2tleX1cXFxcK2AsICdnJyksIGA6JHtrZXl9LS1FU0NBUEVEX1BBUkFNX1BMVVNgKVxuICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICBuZXcgUmVnRXhwKGA6JHtrZXl9KD8hXFxcXHcpYCwgJ2cnKSxcbiAgICAgICAgICBgLS1FU0NBUEVEX1BBUkFNX0NPTE9OJHtrZXl9YFxuICAgICAgICApXG4gICAgfVxuICB9XG4gIHZhbHVlID0gdmFsdWVcbiAgICAucmVwbGFjZSgvKDp8XFwqfFxcP3xcXCt8XFwofFxcKXxcXHt8XFx9KS9nLCAnXFxcXCQxJylcbiAgICAucmVwbGFjZSgvLS1FU0NBUEVEX1BBUkFNX1BMVVMvZywgJysnKVxuICAgIC5yZXBsYWNlKC8tLUVTQ0FQRURfUEFSQU1fQ09MT04vZywgJzonKVxuICAgIC5yZXBsYWNlKC8tLUVTQ0FQRURfUEFSQU1fUVVFU1RJT04vZywgJz8nKVxuICAgIC5yZXBsYWNlKC8tLUVTQ0FQRURfUEFSQU1fQVNURVJJU0tTL2csICcqJylcblxuICAvLyB0aGUgdmFsdWUgbmVlZHMgdG8gc3RhcnQgd2l0aCBhIGZvcndhcmQtc2xhc2ggdG8gYmUgY29tcGlsZWRcbiAgLy8gY29ycmVjdGx5XG4gIHJldHVybiBwYXRoVG9SZWdleHBcbiAgICAuY29tcGlsZShgLyR7dmFsdWV9YCwgeyB2YWxpZGF0ZTogZmFsc2UgfSkocGFyYW1zKVxuICAgIC5zdWJzdHIoMSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJlcGFyZURlc3RpbmF0aW9uKFxuICBkZXN0aW5hdGlvbjogc3RyaW5nLFxuICBwYXJhbXM6IFBhcmFtcyxcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICBhcHBlbmRQYXJhbXNUb1F1ZXJ5OiBib29sZWFuXG4pIHtcbiAgbGV0IHBhcnNlZERlc3RpbmF0aW9uOiB7XG4gICAgcXVlcnk/OiBQYXJzZWRVcmxRdWVyeVxuICAgIHByb3RvY29sPzogc3RyaW5nXG4gICAgaG9zdG5hbWU/OiBzdHJpbmdcbiAgICBwb3J0Pzogc3RyaW5nXG4gIH0gJiBSZXR1cm5UeXBlPHR5cGVvZiBwYXJzZVJlbGF0aXZlVXJsPiA9IHt9IGFzIGFueVxuXG4gIC8vIGNsb25lIHF1ZXJ5IHNvIHdlIGRvbid0IG1vZGlmeSB0aGUgb3JpZ2luYWxcbiAgcXVlcnkgPSBPYmplY3QuYXNzaWduKHt9LCBxdWVyeSlcbiAgY29uc3QgaGFkTG9jYWxlID0gcXVlcnkuX19uZXh0TG9jYWxlXG4gIGRlbGV0ZSBxdWVyeS5fX25leHRMb2NhbGVcbiAgZGVsZXRlIHF1ZXJ5Ll9fbmV4dERlZmF1bHRMb2NhbGVcblxuICBpZiAoZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgcGFyc2VkRGVzdGluYXRpb24gPSBwYXJzZVJlbGF0aXZlVXJsKGRlc3RpbmF0aW9uKVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgc2VhcmNoUGFyYW1zLFxuICAgICAgaGFzaCxcbiAgICAgIGhvc3RuYW1lLFxuICAgICAgcG9ydCxcbiAgICAgIHByb3RvY29sLFxuICAgICAgc2VhcmNoLFxuICAgICAgaHJlZixcbiAgICB9ID0gbmV3IFVSTChkZXN0aW5hdGlvbilcblxuICAgIHBhcnNlZERlc3RpbmF0aW9uID0ge1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBxdWVyeTogc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShzZWFyY2hQYXJhbXMpLFxuICAgICAgaGFzaCxcbiAgICAgIHByb3RvY29sLFxuICAgICAgaG9zdG5hbWUsXG4gICAgICBwb3J0LFxuICAgICAgc2VhcmNoLFxuICAgICAgaHJlZixcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZXN0UXVlcnkgPSBwYXJzZWREZXN0aW5hdGlvbi5xdWVyeVxuICBjb25zdCBkZXN0UGF0aCA9IGAke3BhcnNlZERlc3RpbmF0aW9uLnBhdGhuYW1lIX0ke1xuICAgIHBhcnNlZERlc3RpbmF0aW9uLmhhc2ggfHwgJydcbiAgfWBcbiAgY29uc3QgZGVzdFBhdGhQYXJhbUtleXM6IHBhdGhUb1JlZ2V4cC5LZXlbXSA9IFtdXG4gIHBhdGhUb1JlZ2V4cC5wYXRoVG9SZWdleHAoZGVzdFBhdGgsIGRlc3RQYXRoUGFyYW1LZXlzKVxuXG4gIGNvbnN0IGRlc3RQYXRoUGFyYW1zID0gZGVzdFBhdGhQYXJhbUtleXMubWFwKChrZXkpID0+IGtleS5uYW1lKVxuXG4gIGxldCBkZXN0aW5hdGlvbkNvbXBpbGVyID0gcGF0aFRvUmVnZXhwLmNvbXBpbGUoXG4gICAgZGVzdFBhdGgsXG4gICAgLy8gd2UgZG9uJ3QgdmFsaWRhdGUgd2hpbGUgY29tcGlsaW5nIHRoZSBkZXN0aW5hdGlvbiBzaW5jZSB3ZSBzaG91bGRcbiAgICAvLyBoYXZlIGFscmVhZHkgdmFsaWRhdGVkIGJlZm9yZSB3ZSBnb3QgdG8gdGhpcyBwb2ludCBhbmQgdmFsaWRhdGluZ1xuICAgIC8vIGJyZWFrcyBjb21waWxpbmcgZGVzdGluYXRpb25zIHdpdGggbmFtZWQgcGF0dGVybiBwYXJhbXMgZnJvbSB0aGUgc291cmNlXG4gICAgLy8gZS5nLiAvc29tZXRoaW5nOmhlbGxvKC4qKSAtPiAvYW5vdGhlci86aGVsbG8gaXMgYnJva2VuIHdpdGggdmFsaWRhdGlvblxuICAgIC8vIHNpbmNlIGNvbXBpbGUgdmFsaWRhdGlvbiBpcyBtZWFudCBmb3IgcmV2ZXJzaW5nIGFuZCBub3QgZm9yIGluc2VydGluZ1xuICAgIC8vIHBhcmFtcyBmcm9tIGEgc2VwYXJhdGUgcGF0aC1yZWdleCBpbnRvIGFub3RoZXJcbiAgICB7IHZhbGlkYXRlOiBmYWxzZSB9XG4gIClcbiAgbGV0IG5ld1VybFxuXG4gIC8vIHVwZGF0ZSBhbnkgcGFyYW1zIGluIHF1ZXJ5IHZhbHVlc1xuICBmb3IgKGNvbnN0IFtrZXksIHN0ck9yQXJyYXldIG9mIE9iamVjdC5lbnRyaWVzKGRlc3RRdWVyeSkpIHtcbiAgICBsZXQgdmFsdWUgPSBBcnJheS5pc0FycmF5KHN0ck9yQXJyYXkpID8gc3RyT3JBcnJheVswXSA6IHN0ck9yQXJyYXlcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIC8vIHRoZSB2YWx1ZSBuZWVkcyB0byBzdGFydCB3aXRoIGEgZm9yd2FyZC1zbGFzaCB0byBiZSBjb21waWxlZFxuICAgICAgLy8gY29ycmVjdGx5XG4gICAgICB2YWx1ZSA9IGNvbXBpbGVOb25QYXRoKHZhbHVlLCBwYXJhbXMpXG4gICAgfVxuICAgIGRlc3RRdWVyeVtrZXldID0gdmFsdWVcbiAgfVxuXG4gIC8vIGFkZCBwYXRoIHBhcmFtcyB0byBxdWVyeSBpZiBpdCdzIG5vdCBhIHJlZGlyZWN0IGFuZCBub3RcbiAgLy8gYWxyZWFkeSBkZWZpbmVkIGluIGRlc3RpbmF0aW9uIHF1ZXJ5IG9yIHBhdGhcbiAgbGV0IHBhcmFtS2V5cyA9IE9iamVjdC5rZXlzKHBhcmFtcylcblxuICAvLyByZW1vdmUgaW50ZXJuYWwgcGFyYW0gZm9yIGkxOG5cbiAgaWYgKGhhZExvY2FsZSkge1xuICAgIHBhcmFtS2V5cyA9IHBhcmFtS2V5cy5maWx0ZXIoKG5hbWUpID0+IG5hbWUgIT09ICduZXh0SW50ZXJuYWxMb2NhbGUnKVxuICB9XG5cbiAgaWYgKFxuICAgIGFwcGVuZFBhcmFtc1RvUXVlcnkgJiZcbiAgICAhcGFyYW1LZXlzLnNvbWUoKGtleSkgPT4gZGVzdFBhdGhQYXJhbXMuaW5jbHVkZXMoa2V5KSlcbiAgKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgcGFyYW1LZXlzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gZGVzdFF1ZXJ5KSkge1xuICAgICAgICBkZXN0UXVlcnlba2V5XSA9IHBhcmFtc1trZXldXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBuZXdVcmwgPSBkZXN0aW5hdGlvbkNvbXBpbGVyKHBhcmFtcylcblxuICAgIGNvbnN0IFtwYXRobmFtZSwgaGFzaF0gPSBuZXdVcmwuc3BsaXQoJyMnKVxuICAgIHBhcnNlZERlc3RpbmF0aW9uLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICBwYXJzZWREZXN0aW5hdGlvbi5oYXNoID0gYCR7aGFzaCA/ICcjJyA6ICcnfSR7aGFzaCB8fCAnJ31gXG4gICAgZGVsZXRlIChwYXJzZWREZXN0aW5hdGlvbiBhcyBhbnkpLnNlYXJjaFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLm1lc3NhZ2UubWF0Y2goL0V4cGVjdGVkIC4qPyB0byBub3QgcmVwZWF0LCBidXQgZ290IGFuIGFycmF5LykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRvIHVzZSBhIG11bHRpLW1hdGNoIGluIHRoZSBkZXN0aW5hdGlvbiB5b3UgbXVzdCBhZGQgXFxgKlxcYCBhdCB0aGUgZW5kIG9mIHRoZSBwYXJhbSBuYW1lIHRvIHNpZ25pZnkgaXQgc2hvdWxkIHJlcGVhdC4gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1tdWx0aS1tYXRjaGBcbiAgICAgIClcbiAgICB9XG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICAvLyBRdWVyeSBtZXJnZSBvcmRlciBsb3dlc3QgcHJpb3JpdHkgdG8gaGlnaGVzdFxuICAvLyAxLiBpbml0aWFsIFVSTCBxdWVyeSB2YWx1ZXNcbiAgLy8gMi4gcGF0aCBzZWdtZW50IHZhbHVlc1xuICAvLyAzLiBkZXN0aW5hdGlvbiBzcGVjaWZpZWQgcXVlcnkgdmFsdWVzXG4gIHBhcnNlZERlc3RpbmF0aW9uLnF1ZXJ5ID0ge1xuICAgIC4uLnF1ZXJ5LFxuICAgIC4uLnBhcnNlZERlc3RpbmF0aW9uLnF1ZXJ5LFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuZXdVcmwsXG4gICAgcGFyc2VkRGVzdGluYXRpb24sXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/querystring.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.searchParamsToUrlQuery = searchParamsToUrlQuery;\nexports.urlQueryToSearchParams = urlQueryToSearchParams;\nexports.assign = assign;\n\nfunction searchParamsToUrlQuery(searchParams) {\n  const query = {};\n  searchParams.forEach((value, key) => {\n    if (typeof query[key] === 'undefined') {\n      query[key] = value;\n    } else if (Array.isArray(query[key])) {\n      ;\n      query[key].push(value);\n    } else {\n      query[key] = [query[key], value];\n    }\n  });\n  return query;\n}\n\nfunction stringifyUrlQueryParam(param) {\n  if (typeof param === 'string' || typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {\n    return String(param);\n  } else {\n    return '';\n  }\n}\n\nfunction urlQueryToSearchParams(urlQuery) {\n  const result = new URLSearchParams();\n  Object.entries(urlQuery).forEach(([key, value]) => {\n    if (Array.isArray(value)) {\n      value.forEach(item => result.append(key, stringifyUrlQueryParam(item)));\n    } else {\n      result.set(key, stringifyUrlQueryParam(value));\n    }\n  });\n  return result;\n}\n\nfunction assign(target, ...searchParamsList) {\n  searchParamsList.forEach(searchParams => {\n    Array.from(searchParams.keys()).forEach(key => target.delete(key));\n    searchParams.forEach((value, key) => target.append(key, value));\n  });\n  return target;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZy50cz8yZWJmIl0sIm5hbWVzIjpbInF1ZXJ5Iiwic2VhcmNoUGFyYW1zIiwiQXJyYXkiLCJpc05hTiIsIlN0cmluZyIsInJlc3VsdCIsIk9iamVjdCIsInZhbHVlIiwiaXRlbSIsInN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0iLCJzZWFyY2hQYXJhbXNMaXN0Iiwia2V5IiwidGFyZ2V0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBRU8sOENBRVc7QUFDaEIsUUFBTUEsS0FBcUIsR0FBM0I7QUFDQUMsY0FBWSxDQUFaQSxRQUFxQixnQkFBZ0I7QUFDbkMsUUFBSSxPQUFPRCxLQUFLLENBQVosR0FBWSxDQUFaLEtBQUosYUFBdUM7QUFDckNBLFdBQUssQ0FBTEEsR0FBSyxDQUFMQTtBQURGLFdBRU8sSUFBSUUsS0FBSyxDQUFMQSxRQUFjRixLQUFLLENBQXZCLEdBQXVCLENBQW5CRSxDQUFKLEVBQStCO0FBQ3BDO0FBQUVGLFdBQUssQ0FBTixHQUFNLENBQUxBLENBQUQsSUFBQ0EsQ0FBRCxLQUFDQTtBQURHLFdBRUE7QUFDTEEsV0FBSyxDQUFMQSxHQUFLLENBQUxBLEdBQWEsQ0FBQ0EsS0FBSyxDQUFOLEdBQU0sQ0FBTixFQUFiQSxLQUFhLENBQWJBO0FBRUg7QUFSREM7QUFTQTtBQUdGOztBQUFBLHVDQUF1RDtBQUNyRCxNQUNFLDZCQUNDLDZCQUE2QixDQUFDRSxLQUFLLENBRHBDLEtBQ29DLENBRHBDLElBRUEsaUJBSEYsV0FJRTtBQUNBLFdBQU9DLE1BQU0sQ0FBYixLQUFhLENBQWI7QUFMRixTQU1PO0FBQ0w7QUFFSDtBQUVNOztBQUFBLDBDQUVZO0FBQ2pCLFFBQU1DLE1BQU0sR0FBRyxJQUFmLGVBQWUsRUFBZjtBQUNBQyxRQUFNLENBQU5BLDBCQUFpQyxDQUFDLE1BQUQsS0FBQyxDQUFELEtBQWtCO0FBQ2pELFFBQUlKLEtBQUssQ0FBTEEsUUFBSixLQUFJQSxDQUFKLEVBQTBCO0FBQ3hCSyxXQUFLLENBQUxBLFFBQWVDLElBQUQsSUFBVUgsTUFBTSxDQUFOQSxZQUFtQkksc0JBQXNCLENBQWpFRixJQUFpRSxDQUF6Q0YsQ0FBeEJFO0FBREYsV0FFTztBQUNMRixZQUFNLENBQU5BLFNBQWdCSSxzQkFBc0IsQ0FBdENKLEtBQXNDLENBQXRDQTtBQUVIO0FBTkRDO0FBT0E7QUFHSzs7QUFBQSx3QkFFTCxHQUZLLGtCQUdZO0FBQ2pCSSxrQkFBZ0IsQ0FBaEJBLFFBQTBCVCxZQUFELElBQWtCO0FBQ3pDQyxTQUFLLENBQUxBLEtBQVdELFlBQVksQ0FBdkJDLElBQVdELEVBQVhDLFVBQXlDUyxHQUFELElBQVNDLE1BQU0sQ0FBTkEsT0FBakRWLEdBQWlEVSxDQUFqRFY7QUFDQUQsZ0JBQVksQ0FBWkEsUUFBcUIsZ0JBQWdCVyxNQUFNLENBQU5BLFlBQXJDWCxLQUFxQ1csQ0FBckNYO0FBRkZTO0FBSUE7QUFDRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5cbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KFxuICBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc1xuKTogUGFyc2VkVXJsUXVlcnkge1xuICBjb25zdCBxdWVyeTogUGFyc2VkVXJsUXVlcnkgPSB7fVxuICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmICh0eXBlb2YgcXVlcnlba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHF1ZXJ5W2tleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkge1xuICAgICAgOyhxdWVyeVtrZXldIGFzIHN0cmluZ1tdKS5wdXNoKHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeVtrZXldID0gW3F1ZXJ5W2tleV0gYXMgc3RyaW5nLCB2YWx1ZV1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBxdWVyeVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHBhcmFtOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoXG4gICAgdHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJyB8fFxuICAgICh0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInICYmICFpc05hTihwYXJhbSkpIHx8XG4gICAgdHlwZW9mIHBhcmFtID09PSAnYm9vbGVhbidcbiAgKSB7XG4gICAgcmV0dXJuIFN0cmluZyhwYXJhbSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJydcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhcbiAgdXJsUXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4pOiBVUkxTZWFyY2hQYXJhbXMge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKClcbiAgT2JqZWN0LmVudHJpZXModXJsUXVlcnkpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSkgPT4gcmVzdWx0LmFwcGVuZChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0oaXRlbSkpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbSh2YWx1ZSkpXG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24oXG4gIHRhcmdldDogVVJMU2VhcmNoUGFyYW1zLFxuICAuLi5zZWFyY2hQYXJhbXNMaXN0OiBVUkxTZWFyY2hQYXJhbXNbXVxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgc2VhcmNoUGFyYW1zTGlzdC5mb3JFYWNoKChzZWFyY2hQYXJhbXMpID0+IHtcbiAgICBBcnJheS5mcm9tKHNlYXJjaFBhcmFtcy5rZXlzKCkpLmZvckVhY2goKGtleSkgPT4gdGFyZ2V0LmRlbGV0ZShrZXkpKVxuICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB0YXJnZXQuYXBwZW5kKGtleSwgdmFsdWUpKVxuICB9KVxuICByZXR1cm4gdGFyZ2V0XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/utils/querystring.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.default = resolveRewrites;\n\nvar _pathMatch = _interopRequireDefault(__webpack_require__(/*! ./path-match */ \"./node_modules/next/dist/next-server/lib/router/utils/path-match.js\"));\n\nvar _prepareDestination = _interopRequireWildcard(__webpack_require__(/*! ./prepare-destination */ \"./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js\"));\n\nvar _normalizeTrailingSlash = __webpack_require__(/*! ../../../../client/normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\n\nvar _normalizeLocalePath = __webpack_require__(/*! ../../i18n/normalize-locale-path */ \"./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js\");\n\nvar _parseRelativeUrl = __webpack_require__(/*! ./parse-relative-url */ \"./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js\");\n\nvar _router = __webpack_require__(/*! ../router */ \"./node_modules/next/dist/next-server/lib/router/router.js\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst customRouteMatcher = (0, _pathMatch.default)(true);\n\nfunction resolveRewrites(asPath, pages, rewrites, query, resolveHref, locales) {\n  let matchedPage = false;\n  let parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(asPath);\n  let fsPathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)((0, _normalizeLocalePath.normalizeLocalePath)((0, _router.delBasePath)(parsedAs.pathname), locales).pathname);\n  let resolvedHref;\n\n  const handleRewrite = rewrite => {\n    const matcher = customRouteMatcher(rewrite.source);\n    let params = matcher(parsedAs.pathname);\n\n    if (rewrite.has && params) {\n      const hasParams = (0, _prepareDestination.matchHas)({\n        headers: {\n          host: document.location.hostname\n        },\n        cookies: Object.fromEntries(document.cookie.split('; ').map(item => {\n          const [key, ...value] = item.split('=');\n          return [key, value.join('=')];\n        }))\n      }, rewrite.has, parsedAs.query);\n\n      if (hasParams) {\n        Object.assign(params, hasParams);\n      } else {\n        params = false;\n      }\n    }\n\n    if (params) {\n      if (!rewrite.destination) {\n        // this is a proxied rewrite which isn't handled on the client\n        return true;\n      }\n\n      const destRes = (0, _prepareDestination.default)(rewrite.destination, params, query, true);\n      parsedAs = destRes.parsedDestination;\n      asPath = destRes.newUrl;\n      Object.assign(query, destRes.parsedDestination.query);\n      fsPathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)((0, _normalizeLocalePath.normalizeLocalePath)((0, _router.delBasePath)(asPath), locales).pathname);\n\n      if (pages.includes(fsPathname)) {\n        // check if we now match a page as this means we are done\n        // resolving the rewrites\n        matchedPage = true;\n        resolvedHref = fsPathname;\n        return true;\n      } // check if we match a dynamic-route, if so we break the rewrites chain\n\n\n      resolvedHref = resolveHref(fsPathname);\n\n      if (resolvedHref !== asPath && pages.includes(resolvedHref)) {\n        matchedPage = true;\n        return true;\n      }\n    }\n  };\n\n  let finished = false;\n\n  for (let i = 0; i < rewrites.beforeFiles.length; i++) {\n    const rewrite = rewrites.beforeFiles[i];\n\n    if (handleRewrite(rewrite)) {\n      finished = true;\n      break;\n    }\n  }\n\n  if (!pages.includes(fsPathname)) {\n    if (!finished) {\n      for (let i = 0; i < rewrites.afterFiles.length; i++) {\n        const rewrite = rewrites.afterFiles[i];\n\n        if (handleRewrite(rewrite)) {\n          finished = true;\n          break;\n        }\n      }\n    } // check dynamic route before processing fallback rewrites\n\n\n    if (!finished) {\n      resolvedHref = resolveHref(fsPathname);\n      matchedPage = pages.includes(resolvedHref);\n      finished = matchedPage;\n    }\n\n    if (!finished) {\n      for (let i = 0; i < rewrites.fallback.length; i++) {\n        const rewrite = rewrites.fallback[i];\n\n        if (handleRewrite(rewrite)) {\n          finished = true;\n          break;\n        }\n      }\n    }\n  }\n\n  return {\n    asPath,\n    parsedAs,\n    matchedPage,\n    resolvedHref\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yZXNvbHZlLXJld3JpdGVzLnRzPzY3ODciXSwibmFtZXMiOlsiY3VzdG9tUm91dGVNYXRjaGVyIiwibWF0Y2hlZFBhZ2UiLCJwYXJzZWRBcyIsImZzUGF0aG5hbWUiLCJoYW5kbGVSZXdyaXRlIiwicmV3cml0ZSIsIm1hdGNoZXIiLCJwYXJhbXMiLCJoYXNQYXJhbXMiLCJoZWFkZXJzIiwiaG9zdCIsImRvY3VtZW50IiwiY29va2llcyIsIk9iamVjdCIsIml0ZW0iLCJ2YWx1ZSIsImRlc3RSZXMiLCJhc1BhdGgiLCJwYWdlcyIsInJlc29sdmVkSHJlZiIsInJlc29sdmVIcmVmIiwiZmluaXNoZWQiLCJpIiwicmV3cml0ZXMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7QUFBQSxNQUFNQSxrQkFBa0IsR0FBRyx3QkFBM0IsSUFBMkIsQ0FBM0I7O0FBRWUsK0VBZ0JiO0FBQ0EsTUFBSUMsV0FBVyxHQUFmO0FBQ0EsTUFBSUMsUUFBUSxHQUFHLHdDQUFmLE1BQWUsQ0FBZjtBQUNBLE1BQUlDLFVBQVUsR0FBRyxxREFDZiw4Q0FBb0IseUJBQVlELFFBQVEsQ0FBeEMsUUFBb0IsQ0FBcEIsV0FERixRQUFpQixDQUFqQjtBQUdBOztBQUVBLFFBQU1FLGFBQWEsR0FBSUMsT0FBRCxJQUFzQjtBQUMxQyxVQUFNQyxPQUFPLEdBQUdOLGtCQUFrQixDQUFDSyxPQUFPLENBQTFDLE1BQWtDLENBQWxDO0FBQ0EsUUFBSUUsTUFBTSxHQUFHRCxPQUFPLENBQUNKLFFBQVEsQ0FBN0IsUUFBb0IsQ0FBcEI7O0FBRUEsUUFBSUcsT0FBTyxDQUFQQSxPQUFKLFFBQTJCO0FBQ3pCLFlBQU1HLFNBQVMsR0FBRyxrQ0FD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O0FBQzFCaUIsa0JBQVEsR0FBUkE7QUFDQTtBQUVIO0FBQ0Y7QUFDRjtBQUVEOztBQUFBLFNBQU87QUFBQTtBQUFBO0FBQUE7QUFBUDtBQUFPLEdBQVA7QUFNRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yZXNvbHZlLXJld3JpdGVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCBwYXRoTWF0Y2ggZnJvbSAnLi9wYXRoLW1hdGNoJ1xuaW1wb3J0IHByZXBhcmVEZXN0aW5hdGlvbiwgeyBtYXRjaEhhcyB9IGZyb20gJy4vcHJlcGFyZS1kZXN0aW5hdGlvbidcbmltcG9ydCB7IFJld3JpdGUgfSBmcm9tICcuLi8uLi8uLi8uLi9saWIvbG9hZC1jdXN0b20tcm91dGVzJ1xuaW1wb3J0IHsgcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2ggfSBmcm9tICcuLi8uLi8uLi8uLi9jbGllbnQvbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoJ1xuaW1wb3J0IHsgbm9ybWFsaXplTG9jYWxlUGF0aCB9IGZyb20gJy4uLy4uL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoJ1xuaW1wb3J0IHsgcGFyc2VSZWxhdGl2ZVVybCB9IGZyb20gJy4vcGFyc2UtcmVsYXRpdmUtdXJsJ1xuaW1wb3J0IHsgZGVsQmFzZVBhdGggfSBmcm9tICcuLi9yb3V0ZXInXG5cbmNvbnN0IGN1c3RvbVJvdXRlTWF0Y2hlciA9IHBhdGhNYXRjaCh0cnVlKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXNvbHZlUmV3cml0ZXMoXG4gIGFzUGF0aDogc3RyaW5nLFxuICBwYWdlczogc3RyaW5nW10sXG4gIHJld3JpdGVzOiB7XG4gICAgYmVmb3JlRmlsZXM6IFJld3JpdGVbXVxuICAgIGFmdGVyRmlsZXM6IFJld3JpdGVbXVxuICAgIGZhbGxiYWNrOiBSZXdyaXRlW11cbiAgfSxcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICByZXNvbHZlSHJlZjogKHBhdGg6IHN0cmluZykgPT4gc3RyaW5nLFxuICBsb2NhbGVzPzogc3RyaW5nW11cbik6IHtcbiAgbWF0Y2hlZFBhZ2U6IGJvb2xlYW5cbiAgcGFyc2VkQXM6IFJldHVyblR5cGU8dHlwZW9mIHBhcnNlUmVsYXRpdmVVcmw+XG4gIGFzUGF0aDogc3RyaW5nXG4gIHJlc29sdmVkSHJlZj86IHN0cmluZ1xufSB7XG4gIGxldCBtYXRjaGVkUGFnZSA9IGZhbHNlXG4gIGxldCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwoYXNQYXRoKVxuICBsZXQgZnNQYXRobmFtZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKFxuICAgIG5vcm1hbGl6ZUxvY2FsZVBhdGgoZGVsQmFzZVBhdGgocGFyc2VkQXMucGF0aG5hbWUpLCBsb2NhbGVzKS5wYXRobmFtZVxuICApXG4gIGxldCByZXNvbHZlZEhyZWZcblxuICBjb25zdCBoYW5kbGVSZXdyaXRlID0gKHJld3JpdGU6IFJld3JpdGUpID0+IHtcbiAgICBjb25zdCBtYXRjaGVyID0gY3VzdG9tUm91dGVNYXRjaGVyKHJld3JpdGUuc291cmNlKVxuICAgIGxldCBwYXJhbXMgPSBtYXRjaGVyKHBhcnNlZEFzLnBhdGhuYW1lKVxuXG4gICAgaWYgKHJld3JpdGUuaGFzICYmIHBhcmFtcykge1xuICAgICAgY29uc3QgaGFzUGFyYW1zID0gbWF0Y2hIYXMoXG4gICAgICAgIHtcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBob3N0OiBkb2N1bWVudC5sb2NhdGlvbi5ob3N0bmFtZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvb2tpZXM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOyAnKS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgW2tleSwgLi4udmFsdWVdID0gaXRlbS5zcGxpdCgnPScpXG4gICAgICAgICAgICAgIHJldHVybiBba2V5LCB2YWx1ZS5qb2luKCc9JyldXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICksXG4gICAgICAgIH0gYXMgYW55LFxuICAgICAgICByZXdyaXRlLmhhcyxcbiAgICAgICAgcGFyc2VkQXMucXVlcnlcbiAgICAgIClcblxuICAgICAgaWYgKGhhc1BhcmFtcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHBhcmFtcywgaGFzUGFyYW1zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICBpZiAoIXJld3JpdGUuZGVzdGluYXRpb24pIHtcbiAgICAgICAgLy8gdGhpcyBpcyBhIHByb3hpZWQgcmV3cml0ZSB3aGljaCBpc24ndCBoYW5kbGVkIG9uIHRoZSBjbGllbnRcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlc3RSZXMgPSBwcmVwYXJlRGVzdGluYXRpb24oXG4gICAgICAgIHJld3JpdGUuZGVzdGluYXRpb24sXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIHRydWVcbiAgICAgIClcbiAgICAgIHBhcnNlZEFzID0gZGVzdFJlcy5wYXJzZWREZXN0aW5hdGlvblxuICAgICAgYXNQYXRoID0gZGVzdFJlcy5uZXdVcmxcbiAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIGRlc3RSZXMucGFyc2VkRGVzdGluYXRpb24ucXVlcnkpXG5cbiAgICAgIGZzUGF0aG5hbWUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChcbiAgICAgICAgbm9ybWFsaXplTG9jYWxlUGF0aChkZWxCYXNlUGF0aChhc1BhdGgpLCBsb2NhbGVzKS5wYXRobmFtZVxuICAgICAgKVxuXG4gICAgICBpZiAocGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSkpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2Ugbm93IG1hdGNoIGEgcGFnZSBhcyB0aGlzIG1lYW5zIHdlIGFyZSBkb25lXG4gICAgICAgIC8vIHJlc29sdmluZyB0aGUgcmV3cml0ZXNcbiAgICAgICAgbWF0Y2hlZFBhZ2UgPSB0cnVlXG4gICAgICAgIHJlc29sdmVkSHJlZiA9IGZzUGF0aG5hbWVcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgaWYgd2UgbWF0Y2ggYSBkeW5hbWljLXJvdXRlLCBpZiBzbyB3ZSBicmVhayB0aGUgcmV3cml0ZXMgY2hhaW5cbiAgICAgIHJlc29sdmVkSHJlZiA9IHJlc29sdmVIcmVmKGZzUGF0aG5hbWUpXG5cbiAgICAgIGlmIChyZXNvbHZlZEhyZWYgIT09IGFzUGF0aCAmJiBwYWdlcy5pbmNsdWRlcyhyZXNvbHZlZEhyZWYpKSB7XG4gICAgICAgIG1hdGNoZWRQYWdlID0gdHJ1ZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgZmluaXNoZWQgPSBmYWxzZVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmV3cml0ZXMuYmVmb3JlRmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCByZXdyaXRlID0gcmV3cml0ZXMuYmVmb3JlRmlsZXNbaV1cblxuICAgIGlmIChoYW5kbGVSZXdyaXRlKHJld3JpdGUpKSB7XG4gICAgICBmaW5pc2hlZCA9IHRydWVcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKCFwYWdlcy5pbmNsdWRlcyhmc1BhdGhuYW1lKSkge1xuICAgIGlmICghZmluaXNoZWQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV3cml0ZXMuYWZ0ZXJGaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCByZXdyaXRlID0gcmV3cml0ZXMuYWZ0ZXJGaWxlc1tpXVxuICAgICAgICBpZiAoaGFuZGxlUmV3cml0ZShyZXdyaXRlKSkge1xuICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBkeW5hbWljIHJvdXRlIGJlZm9yZSBwcm9jZXNzaW5nIGZhbGxiYWNrIHJld3JpdGVzXG4gICAgaWYgKCFmaW5pc2hlZCkge1xuICAgICAgcmVzb2x2ZWRIcmVmID0gcmVzb2x2ZUhyZWYoZnNQYXRobmFtZSlcbiAgICAgIG1hdGNoZWRQYWdlID0gcGFnZXMuaW5jbHVkZXMocmVzb2x2ZWRIcmVmKVxuICAgICAgZmluaXNoZWQgPSBtYXRjaGVkUGFnZVxuICAgIH1cblxuICAgIGlmICghZmluaXNoZWQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV3cml0ZXMuZmFsbGJhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmV3cml0ZSA9IHJld3JpdGVzLmZhbGxiYWNrW2ldXG4gICAgICAgIGlmIChoYW5kbGVSZXdyaXRlKHJld3JpdGUpKSB7XG4gICAgICAgICAgZmluaXNoZWQgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYXNQYXRoLFxuICAgIHBhcnNlZEFzLFxuICAgIG1hdGNoZWRQYWdlLFxuICAgIHJlc29sdmVkSHJlZixcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.getRouteMatcher = getRouteMatcher;\n\nfunction getRouteMatcher(routeRegex) {\n  const {\n    re,\n    groups\n  } = routeRegex;\n  return pathname => {\n    const routeMatch = re.exec(pathname);\n\n    if (!routeMatch) {\n      return false;\n    }\n\n    const decode = param => {\n      try {\n        return decodeURIComponent(param);\n      } catch (_) {\n        const err = new Error('failed to decode param');\n        err.code = 'DECODE_FAILED';\n        throw err;\n      }\n    };\n\n    const params = {};\n    Object.keys(groups).forEach(slugName => {\n      const g = groups[slugName];\n      const m = routeMatch[g.pos];\n\n      if (m !== undefined) {\n        params[slugName] = ~m.indexOf('/') ? m.split('/').map(entry => decode(entry)) : g.repeat ? [decode(m)] : decode(m);\n      }\n    });\n    return params;\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yb3V0ZS1tYXRjaGVyLnRzP2E2NzIiXSwibmFtZXMiOlsicGF0aG5hbWUiLCJyb3V0ZU1hdGNoIiwicmUiLCJkZWNvZGUiLCJwYXJhbSIsImRlY29kZVVSSUNvbXBvbmVudCIsImVyciIsInBhcmFtcyIsIk9iamVjdCIsInNsdWdOYW1lIiwiZyIsImdyb3VwcyIsIm0iLCJlbnRyeSJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFTyxxQ0FBdUU7QUFDNUUsUUFBTTtBQUFBO0FBQUE7QUFBQSxNQUFOO0FBQ0EsU0FBUUEsUUFBRCxJQUF5QztBQUM5QyxVQUFNQyxVQUFVLEdBQUdDLEVBQUUsQ0FBRkEsS0FBbkIsUUFBbUJBLENBQW5COztBQUNBLFFBQUksQ0FBSixZQUFpQjtBQUNmO0FBR0Y7O0FBQUEsVUFBTUMsTUFBTSxHQUFJQyxLQUFELElBQW1CO0FBQ2hDLFVBQUk7QUFDRixlQUFPQyxrQkFBa0IsQ0FBekIsS0FBeUIsQ0FBekI7QUFDQSxPQUZGLENBRUUsVUFBVTtBQUNWLGNBQU1DLEdBQThCLEdBQUcsVUFBdkMsd0JBQXVDLENBQXZDO0FBR0FBLFdBQUcsQ0FBSEE7QUFDQTtBQUVIO0FBVkQ7O0FBV0EsVUFBTUMsTUFBa0QsR0FBeEQ7QUFFQUMsVUFBTSxDQUFOQSxxQkFBNkJDLFFBQUQsSUFBc0I7QUFDaEQsWUFBTUMsQ0FBQyxHQUFHQyxNQUFNLENBQWhCLFFBQWdCLENBQWhCO0FBQ0EsWUFBTUMsQ0FBQyxHQUFHWCxVQUFVLENBQUNTLENBQUMsQ0FBdEIsR0FBb0IsQ0FBcEI7O0FBQ0EsVUFBSUUsQ0FBQyxLQUFMLFdBQXFCO0FBQ25CTCxjQUFNLENBQU5BLFFBQU0sQ0FBTkEsR0FBbUIsQ0FBQ0ssQ0FBQyxDQUFEQSxRQUFELEdBQUNBLENBQUQsR0FDZkEsQ0FBQyxDQUFEQSxlQUFrQkMsS0FBRCxJQUFXVixNQUFNLENBRG5CLEtBQ21CLENBQWxDUyxDQURlLEdBRWZGLENBQUMsQ0FBREEsU0FDQSxDQUFDUCxNQUFNLENBRFBPLENBQ08sQ0FBUCxDQURBQSxHQUVBUCxNQUFNLENBSlZJLENBSVUsQ0FKVkE7QUFNSDtBQVZEQztBQVdBO0FBOUJGO0FBZ0NEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3JvdXRlLW1hdGNoZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRSb3V0ZVJlZ2V4IH0gZnJvbSAnLi9yb3V0ZS1yZWdleCdcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdXRlTWF0Y2hlcihyb3V0ZVJlZ2V4OiBSZXR1cm5UeXBlPHR5cGVvZiBnZXRSb3V0ZVJlZ2V4Pikge1xuICBjb25zdCB7IHJlLCBncm91cHMgfSA9IHJvdXRlUmVnZXhcbiAgcmV0dXJuIChwYXRobmFtZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4ge1xuICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSByZS5leGVjKHBhdGhuYW1lISlcbiAgICBpZiAoIXJvdXRlTWF0Y2gpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGRlY29kZSA9IChwYXJhbTogc3RyaW5nKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtKVxuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICBjb25zdCBlcnI6IEVycm9yICYgeyBjb2RlPzogc3RyaW5nIH0gPSBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2ZhaWxlZCB0byBkZWNvZGUgcGFyYW0nXG4gICAgICAgIClcbiAgICAgICAgZXJyLmNvZGUgPSAnREVDT0RFX0ZBSUxFRCdcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtczogeyBbcGFyYW1OYW1lOiBzdHJpbmddOiBzdHJpbmcgfCBzdHJpbmdbXSB9ID0ge31cblxuICAgIE9iamVjdC5rZXlzKGdyb3VwcykuZm9yRWFjaCgoc2x1Z05hbWU6IHN0cmluZykgPT4ge1xuICAgICAgY29uc3QgZyA9IGdyb3Vwc1tzbHVnTmFtZV1cbiAgICAgIGNvbnN0IG0gPSByb3V0ZU1hdGNoW2cucG9zXVxuICAgICAgaWYgKG0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJhbXNbc2x1Z05hbWVdID0gfm0uaW5kZXhPZignLycpXG4gICAgICAgICAgPyBtLnNwbGl0KCcvJykubWFwKChlbnRyeSkgPT4gZGVjb2RlKGVudHJ5KSlcbiAgICAgICAgICA6IGcucmVwZWF0XG4gICAgICAgICAgPyBbZGVjb2RlKG0pXVxuICAgICAgICAgIDogZGVjb2RlKG0pXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gcGFyYW1zXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module\n// to reduce bytes\n\nfunction escapeRegex(str) {\n  return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&');\n}\n\nfunction parseParameter(param) {\n  const optional = param.startsWith('[') && param.endsWith(']');\n\n  if (optional) {\n    param = param.slice(1, -1);\n  }\n\n  const repeat = param.startsWith('...');\n\n  if (repeat) {\n    param = param.slice(3);\n  }\n\n  return {\n    key: param,\n    repeat,\n    optional\n  };\n}\n\nfunction getRouteRegex(normalizedRoute) {\n  const segments = (normalizedRoute.replace(/\\/$/, '') || '/').slice(1).split('/');\n  const groups = {};\n  let groupIndex = 1;\n  const parameterizedRoute = segments.map(segment => {\n    if (segment.startsWith('[') && segment.endsWith(']')) {\n      const {\n        key,\n        optional,\n        repeat\n      } = parseParameter(segment.slice(1, -1));\n      groups[key] = {\n        pos: groupIndex++,\n        repeat,\n        optional\n      };\n      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n    } else {\n      return `/${escapeRegex(segment)}`;\n    }\n  }).join(''); // dead code eliminate for browser since it's only needed\n  // while generating routes-manifest\n\n  if (true) {\n    let routeKeyCharCode = 97;\n    let routeKeyCharLength = 1; // builds a minimal routeKey using only a-z and minimal number of characters\n\n    const getSafeRouteKey = () => {\n      let routeKey = '';\n\n      for (let i = 0; i < routeKeyCharLength; i++) {\n        routeKey += String.fromCharCode(routeKeyCharCode);\n        routeKeyCharCode++;\n\n        if (routeKeyCharCode > 122) {\n          routeKeyCharLength++;\n          routeKeyCharCode = 97;\n        }\n      }\n\n      return routeKey;\n    };\n\n    const routeKeys = {};\n    let namedParameterizedRoute = segments.map(segment => {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        const {\n          key,\n          optional,\n          repeat\n        } = parseParameter(segment.slice(1, -1)); // replace any non-word characters since they can break\n        // the named regex\n\n        let cleanedKey = key.replace(/\\W/g, '');\n        let invalidKey = false; // check if the key is still invalid and fallback to using a known\n        // safe key\n\n        if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n          invalidKey = true;\n        }\n\n        if (!isNaN(parseInt(cleanedKey.substr(0, 1)))) {\n          invalidKey = true;\n        }\n\n        if (invalidKey) {\n          cleanedKey = getSafeRouteKey();\n        }\n\n        routeKeys[cleanedKey] = key;\n        return repeat ? optional ? `(?:/(?<${cleanedKey}>.+?))?` : `/(?<${cleanedKey}>.+?)` : `/(?<${cleanedKey}>[^/]+?)`;\n      } else {\n        return `/${escapeRegex(segment)}`;\n      }\n    }).join('');\n    return {\n      re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n      groups,\n      routeKeys,\n      namedRegex: `^${namedParameterizedRoute}(?:/)?$`\n    };\n  }\n\n  return {\n    re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n    groups\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yb3V0ZS1yZWdleC50cz85ZGJjIl0sIm5hbWVzIjpbInN0ciIsIm9wdGlvbmFsIiwicGFyYW0iLCJyZXBlYXQiLCJrZXkiLCJzZWdtZW50cyIsIm5vcm1hbGl6ZWRSb3V0ZSIsImdyb3VwcyIsImdyb3VwSW5kZXgiLCJwYXJhbWV0ZXJpemVkUm91dGUiLCJzZWdtZW50IiwicGFyc2VQYXJhbWV0ZXIiLCJwb3MiLCJlc2NhcGVSZWdleCIsInJvdXRlS2V5Q2hhckNvZGUiLCJyb3V0ZUtleUNoYXJMZW5ndGgiLCJnZXRTYWZlUm91dGVLZXkiLCJyb3V0ZUtleSIsImkiLCJTdHJpbmciLCJyb3V0ZUtleXMiLCJuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSIsImNsZWFuZWRLZXkiLCJpbnZhbGlkS2V5IiwiaXNOYU4iLCJwYXJzZUludCIsInJlIiwibmFtZWRSZWdleCJdLCJtYXBwaW5ncyI6Ijs7O3VDQU1BO0FBQ0E7O0FBQ0EsMEJBQWtDO0FBQ2hDLFNBQU9BLEdBQUcsQ0FBSEEsZ0NBQVAsTUFBT0EsQ0FBUDtBQUdGOztBQUFBLCtCQUF1QztBQUNyQyxRQUFNQyxRQUFRLEdBQUdDLEtBQUssQ0FBTEEsbUJBQXlCQSxLQUFLLENBQUxBLFNBQTFDLEdBQTBDQSxDQUExQzs7QUFDQSxnQkFBYztBQUNaQSxTQUFLLEdBQUdBLEtBQUssQ0FBTEEsU0FBZSxDQUF2QkEsQ0FBUUEsQ0FBUkE7QUFFRjs7QUFBQSxRQUFNQyxNQUFNLEdBQUdELEtBQUssQ0FBTEEsV0FBZixLQUFlQSxDQUFmOztBQUNBLGNBQVk7QUFDVkEsU0FBSyxHQUFHQSxLQUFLLENBQUxBLE1BQVJBLENBQVFBLENBQVJBO0FBRUY7O0FBQUEsU0FBTztBQUFFRSxPQUFHLEVBQUw7QUFBQTtBQUFQO0FBQU8sR0FBUDtBQUdLOztBQUFBLHdDQU9MO0FBQ0EsUUFBTUMsUUFBUSxHQUFHLENBQUNDLGVBQWUsQ0FBZkEsc0JBQUQsb0JBQWpCLEdBQWlCLENBQWpCO0FBSUEsUUFBTUMsTUFBc0MsR0FBNUM7QUFDQSxNQUFJQyxVQUFVLEdBQWQ7QUFDQSxRQUFNQyxrQkFBa0IsR0FBR0osUUFBUSxDQUFSQSxJQUNuQkssT0FBRCxJQUFhO0FBQ2hCLFFBQUlBLE9BQU8sQ0FBUEEsbUJBQTJCQSxPQUFPLENBQVBBLFNBQS9CLEdBQStCQSxDQUEvQixFQUFzRDtBQUNwRCxZQUFNO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFBNEJDLGNBQWMsQ0FBQ0QsT0FBTyxDQUFQQSxTQUFpQixDQUFsRSxDQUFpREEsQ0FBRCxDQUFoRDtBQUNBSCxZQUFNLENBQU5BLEdBQU0sQ0FBTkEsR0FBYztBQUFFSyxXQUFHLEVBQUVKLFVBQVA7QUFBQTtBQUFkRDtBQUFjLE9BQWRBO0FBQ0EsYUFBT0osTUFBTSxHQUFJRixRQUFRLG1CQUFaLFdBQWI7QUFIRixXQUlPO0FBQ0wsYUFBUSxJQUFHWSxXQUFXLFNBQXRCO0FBRUg7QUFUd0JSLFVBQTNCLEVBQTJCQSxDQUEzQixDQVBBLENBbUJBO0FBQ0E7O0FBQ0EsWUFBbUM7QUFDakMsUUFBSVMsZ0JBQWdCLEdBQXBCO0FBQ0EsUUFBSUMsa0JBQWtCLEdBQXRCLEVBRmlDLENBSWpDOztBQUNBLFVBQU1DLGVBQWUsR0FBRyxNQUFNO0FBQzVCLFVBQUlDLFFBQVEsR0FBWjs7QUFFQSxXQUFLLElBQUlDLENBQUMsR0FBVixHQUFnQkEsQ0FBQyxHQUFqQixvQkFBd0NBLENBQXhDLElBQTZDO0FBQzNDRCxnQkFBUSxJQUFJRSxNQUFNLENBQU5BLGFBQVpGLGdCQUFZRSxDQUFaRjtBQUNBSCx3QkFBZ0I7O0FBRWhCLFlBQUlBLGdCQUFnQixHQUFwQixLQUE0QjtBQUMxQkMsNEJBQWtCO0FBQ2xCRCwwQkFBZ0IsR0FBaEJBO0FBRUg7QUFDRDs7QUFBQTtBQVpGOztBQWVBLFVBQU1NLFNBQXNDLEdBQTVDO0FBRUEsUUFBSUMsdUJBQXVCLEdBQUdoQixRQUFRLENBQVJBLElBQ3RCSyxPQUFELElBQWE7QUFDaEIsVUFBSUEsT0FBTyxDQUFQQSxtQkFBMkJBLE9BQU8sQ0FBUEEsU0FBL0IsR0FBK0JBLENBQS9CLEVBQXNEO0FBQ3BELGNBQU07QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUE0QkMsY0FBYyxDQUFDRCxPQUFPLENBQVBBLFNBQWlCLENBQWxFLENBQWlEQSxDQUFELENBQWhELENBRG9ELENBRXBEO0FBQ0E7O0FBQ0EsWUFBSVksVUFBVSxHQUFHbEIsR0FBRyxDQUFIQSxlQUFqQixFQUFpQkEsQ0FBakI7QUFDQSxZQUFJbUIsVUFBVSxHQUFkLE1BTG9ELENBT3BEO0FBQ0E7O0FBQ0EsWUFBSUQsVUFBVSxDQUFWQSxnQkFBMkJBLFVBQVUsQ0FBVkEsU0FBL0IsSUFBdUQ7QUFDckRDLG9CQUFVLEdBQVZBO0FBRUY7O0FBQUEsWUFBSSxDQUFDQyxLQUFLLENBQUNDLFFBQVEsQ0FBQ0gsVUFBVSxDQUFWQSxVQUFwQixDQUFvQkEsQ0FBRCxDQUFULENBQVYsRUFBK0M7QUFDN0NDLG9CQUFVLEdBQVZBO0FBR0Y7O0FBQUEsd0JBQWdCO0FBQ2RELG9CQUFVLEdBQUdOLGVBQWJNO0FBR0ZGOztBQUFBQSxpQkFBUyxDQUFUQSxVQUFTLENBQVRBO0FBQ0EsZUFBT2pCLE1BQU0sR0FDVEYsUUFBUSxHQUNMLFVBQVNxQixVQURKLFlBRUwsT0FBTUEsVUFIQSxVQUlSLE9BQU1BLFVBSlg7QUFyQkYsYUEwQk87QUFDTCxlQUFRLElBQUdULFdBQVcsU0FBdEI7QUFFSDtBQS9CMkJSLFlBQTlCLEVBQThCQSxDQUE5QjtBQWtDQSxXQUFPO0FBQ0xxQixRQUFFLEVBQUUsV0FBWSxJQUFHakIsa0JBRGQsU0FDRCxDQURDO0FBQUE7QUFBQTtBQUlMa0IsZ0JBQVUsRUFBRyxJQUFHTix1QkFKbEI7QUFBTyxLQUFQO0FBUUY7O0FBQUEsU0FBTztBQUNMSyxNQUFFLEVBQUUsV0FBWSxJQUFHakIsa0JBRGQsU0FDRCxDQURDO0FBQVA7QUFBTyxHQUFQO0FBSUQiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIEdyb3VwIHtcbiAgcG9zOiBudW1iZXJcbiAgcmVwZWF0OiBib29sZWFuXG4gIG9wdGlvbmFsOiBib29sZWFuXG59XG5cbi8vIHRoaXMgaXNuJ3QgaW1wb3J0aW5nIHRoZSBlc2NhcGUtc3RyaW5nLXJlZ2V4IG1vZHVsZVxuLy8gdG8gcmVkdWNlIGJ5dGVzXG5mdW5jdGlvbiBlc2NhcGVSZWdleChzdHI6IHN0cmluZykge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrKj8uLV0vZywgJ1xcXFwkJicpXG59XG5cbmZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyKHBhcmFtOiBzdHJpbmcpIHtcbiAgY29uc3Qgb3B0aW9uYWwgPSBwYXJhbS5zdGFydHNXaXRoKCdbJykgJiYgcGFyYW0uZW5kc1dpdGgoJ10nKVxuICBpZiAob3B0aW9uYWwpIHtcbiAgICBwYXJhbSA9IHBhcmFtLnNsaWNlKDEsIC0xKVxuICB9XG4gIGNvbnN0IHJlcGVhdCA9IHBhcmFtLnN0YXJ0c1dpdGgoJy4uLicpXG4gIGlmIChyZXBlYXQpIHtcbiAgICBwYXJhbSA9IHBhcmFtLnNsaWNlKDMpXG4gIH1cbiAgcmV0dXJuIHsga2V5OiBwYXJhbSwgcmVwZWF0LCBvcHRpb25hbCB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3V0ZVJlZ2V4KFxuICBub3JtYWxpemVkUm91dGU6IHN0cmluZ1xuKToge1xuICByZTogUmVnRXhwXG4gIG5hbWVkUmVnZXg/OiBzdHJpbmdcbiAgcm91dGVLZXlzPzogeyBbbmFtZWQ6IHN0cmluZ106IHN0cmluZyB9XG4gIGdyb3VwczogeyBbZ3JvdXBOYW1lOiBzdHJpbmddOiBHcm91cCB9XG59IHtcbiAgY29uc3Qgc2VnbWVudHMgPSAobm9ybWFsaXplZFJvdXRlLnJlcGxhY2UoL1xcLyQvLCAnJykgfHwgJy8nKVxuICAgIC5zbGljZSgxKVxuICAgIC5zcGxpdCgnLycpXG5cbiAgY29uc3QgZ3JvdXBzOiB7IFtncm91cE5hbWU6IHN0cmluZ106IEdyb3VwIH0gPSB7fVxuICBsZXQgZ3JvdXBJbmRleCA9IDFcbiAgY29uc3QgcGFyYW1ldGVyaXplZFJvdXRlID0gc2VnbWVudHNcbiAgICAubWFwKChzZWdtZW50KSA9PiB7XG4gICAgICBpZiAoc2VnbWVudC5zdGFydHNXaXRoKCdbJykgJiYgc2VnbWVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50LnNsaWNlKDEsIC0xKSlcbiAgICAgICAgZ3JvdXBzW2tleV0gPSB7IHBvczogZ3JvdXBJbmRleCsrLCByZXBlYXQsIG9wdGlvbmFsIH1cbiAgICAgICAgcmV0dXJuIHJlcGVhdCA/IChvcHRpb25hbCA/ICcoPzovKC4rPykpPycgOiAnLyguKz8pJykgOiAnLyhbXi9dKz8pJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAvJHtlc2NhcGVSZWdleChzZWdtZW50KX1gXG4gICAgICB9XG4gICAgfSlcbiAgICAuam9pbignJylcblxuICAvLyBkZWFkIGNvZGUgZWxpbWluYXRlIGZvciBicm93c2VyIHNpbmNlIGl0J3Mgb25seSBuZWVkZWRcbiAgLy8gd2hpbGUgZ2VuZXJhdGluZyByb3V0ZXMtbWFuaWZlc3RcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbGV0IHJvdXRlS2V5Q2hhckNvZGUgPSA5N1xuICAgIGxldCByb3V0ZUtleUNoYXJMZW5ndGggPSAxXG5cbiAgICAvLyBidWlsZHMgYSBtaW5pbWFsIHJvdXRlS2V5IHVzaW5nIG9ubHkgYS16IGFuZCBtaW5pbWFsIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgY29uc3QgZ2V0U2FmZVJvdXRlS2V5ID0gKCkgPT4ge1xuICAgICAgbGV0IHJvdXRlS2V5ID0gJydcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZUtleUNoYXJMZW5ndGg7IGkrKykge1xuICAgICAgICByb3V0ZUtleSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJvdXRlS2V5Q2hhckNvZGUpXG4gICAgICAgIHJvdXRlS2V5Q2hhckNvZGUrK1xuXG4gICAgICAgIGlmIChyb3V0ZUtleUNoYXJDb2RlID4gMTIyKSB7XG4gICAgICAgICAgcm91dGVLZXlDaGFyTGVuZ3RoKytcbiAgICAgICAgICByb3V0ZUtleUNoYXJDb2RlID0gOTdcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJvdXRlS2V5XG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGVLZXlzOiB7IFtuYW1lZDogc3RyaW5nXTogc3RyaW5nIH0gPSB7fVxuXG4gICAgbGV0IG5hbWVkUGFyYW1ldGVyaXplZFJvdXRlID0gc2VnbWVudHNcbiAgICAgIC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICAgICAgaWYgKHNlZ21lbnQuc3RhcnRzV2l0aCgnWycpICYmIHNlZ21lbnQuZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50LnNsaWNlKDEsIC0xKSlcbiAgICAgICAgICAvLyByZXBsYWNlIGFueSBub24td29yZCBjaGFyYWN0ZXJzIHNpbmNlIHRoZXkgY2FuIGJyZWFrXG4gICAgICAgICAgLy8gdGhlIG5hbWVkIHJlZ2V4XG4gICAgICAgICAgbGV0IGNsZWFuZWRLZXkgPSBrZXkucmVwbGFjZSgvXFxXL2csICcnKVxuICAgICAgICAgIGxldCBpbnZhbGlkS2V5ID0gZmFsc2VcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBrZXkgaXMgc3RpbGwgaW52YWxpZCBhbmQgZmFsbGJhY2sgdG8gdXNpbmcgYSBrbm93blxuICAgICAgICAgIC8vIHNhZmUga2V5XG4gICAgICAgICAgaWYgKGNsZWFuZWRLZXkubGVuZ3RoID09PSAwIHx8IGNsZWFuZWRLZXkubGVuZ3RoID4gMzApIHtcbiAgICAgICAgICAgIGludmFsaWRLZXkgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VJbnQoY2xlYW5lZEtleS5zdWJzdHIoMCwgMSkpKSkge1xuICAgICAgICAgICAgaW52YWxpZEtleSA9IHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW52YWxpZEtleSkge1xuICAgICAgICAgICAgY2xlYW5lZEtleSA9IGdldFNhZmVSb3V0ZUtleSgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm91dGVLZXlzW2NsZWFuZWRLZXldID0ga2V5XG4gICAgICAgICAgcmV0dXJuIHJlcGVhdFxuICAgICAgICAgICAgPyBvcHRpb25hbFxuICAgICAgICAgICAgICA/IGAoPzovKD88JHtjbGVhbmVkS2V5fT4uKz8pKT9gXG4gICAgICAgICAgICAgIDogYC8oPzwke2NsZWFuZWRLZXl9Pi4rPylgXG4gICAgICAgICAgICA6IGAvKD88JHtjbGVhbmVkS2V5fT5bXi9dKz8pYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgLyR7ZXNjYXBlUmVnZXgoc2VnbWVudCl9YFxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmpvaW4oJycpXG5cbiAgICByZXR1cm4ge1xuICAgICAgcmU6IG5ldyBSZWdFeHAoYF4ke3BhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYCksXG4gICAgICBncm91cHMsXG4gICAgICByb3V0ZUtleXMsXG4gICAgICBuYW1lZFJlZ2V4OiBgXiR7bmFtZWRQYXJhbWV0ZXJpemVkUm91dGV9KD86Lyk/JGAsXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZTogbmV3IFJlZ0V4cChgXiR7cGFyYW1ldGVyaXplZFJvdXRlfSg/Oi8pPyRgKSxcbiAgICBncm91cHMsXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/utils/route-regex.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.execOnce = execOnce;\nexports.getLocationOrigin = getLocationOrigin;\nexports.getURL = getURL;\nexports.getDisplayName = getDisplayName;\nexports.isResSent = isResSent;\nexports.loadGetInitialProps = loadGetInitialProps;\nexports.formatWithValidation = formatWithValidation;\nexports.ST = exports.SP = exports.urlObjectKeys = void 0;\n\nvar _formatUrl = __webpack_require__(/*! ./router/utils/format-url */ \"./node_modules/next/dist/next-server/lib/router/utils/format-url.js\");\n/**\n* Utils\n*/\n\n\nfunction execOnce(fn) {\n  let used = false;\n  let result;\n  return (...args) => {\n    if (!used) {\n      used = true;\n      result = fn(...args);\n    }\n\n    return result;\n  };\n}\n\nfunction getLocationOrigin() {\n  const {\n    protocol,\n    hostname,\n    port\n  } = window.location;\n  return `${protocol}//${hostname}${port ? ':' + port : ''}`;\n}\n\nfunction getURL() {\n  const {\n    href\n  } = window.location;\n  const origin = getLocationOrigin();\n  return href.substring(origin.length);\n}\n\nfunction getDisplayName(Component) {\n  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';\n}\n\nfunction isResSent(res) {\n  return res.finished || res.headersSent;\n}\n\nasync function loadGetInitialProps(App, ctx) {\n  if (true) {\n    var _App$prototype;\n\n    if ((_App$prototype = App.prototype) != null && _App$prototype.getInitialProps) {\n      const message = `\"${getDisplayName(App)}.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`;\n      throw new Error(message);\n    }\n  } // when called from _app `ctx` is nested in `ctx`\n\n\n  const res = ctx.res || ctx.ctx && ctx.ctx.res;\n\n  if (!App.getInitialProps) {\n    if (ctx.ctx && ctx.Component) {\n      // @ts-ignore pageProps default\n      return {\n        pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n      };\n    }\n\n    return {};\n  }\n\n  const props = await App.getInitialProps(ctx);\n\n  if (res && isResSent(res)) {\n    return props;\n  }\n\n  if (!props) {\n    const message = `\"${getDisplayName(App)}.getInitialProps()\" should resolve to an object. But found \"${props}\" instead.`;\n    throw new Error(message);\n  }\n\n  if (true) {\n    if (Object.keys(props).length === 0 && !ctx.ctx) {\n      console.warn(`${getDisplayName(App)} returned an empty object from \\`getInitialProps\\`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`);\n    }\n  }\n\n  return props;\n}\n\nconst urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];\nexports.urlObjectKeys = urlObjectKeys;\n\nfunction formatWithValidation(url) {\n  if (true) {\n    if (url !== null && typeof url === 'object') {\n      Object.keys(url).forEach(key => {\n        if (urlObjectKeys.indexOf(key) === -1) {\n          console.warn(`Unknown key passed via urlObject into url.format: ${key}`);\n        }\n      });\n    }\n  }\n\n  return (0, _formatUrl.formatUrl)(url);\n}\n\nconst SP = typeof performance !== 'undefined';\nexports.SP = SP;\nconst ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';\nexports.ST = ST;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3V0aWxzLnRzP2I2ZjkiXSwibmFtZXMiOlsidXNlZCIsInJlc3VsdCIsImZuIiwid2luZG93IiwicHJvdG9jb2wiLCJob3N0bmFtZSIsInBvcnQiLCJvcmlnaW4iLCJnZXRMb2NhdGlvbk9yaWdpbiIsImhyZWYiLCJDb21wb25lbnQiLCJyZXMiLCJBcHAiLCJtZXNzYWdlIiwiZ2V0RGlzcGxheU5hbWUiLCJjdHgiLCJwYWdlUHJvcHMiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwicHJvcHMiLCJpc1Jlc1NlbnQiLCJPYmplY3QiLCJjb25zb2xlIiwidXJsT2JqZWN0S2V5cyIsInVybCIsImtleSIsIlNQIiwiU1QiLCJwZXJmb3JtYW5jZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBSUE7QUE0UUE7QUFDQTtBQUNBOzs7QUFDTyxzQkFFRjtBQUNILE1BQUlBLElBQUksR0FBUjtBQUNBO0FBRUEsU0FBUSxDQUFDLEdBQUQsU0FBb0I7QUFDMUIsUUFBSSxDQUFKLE1BQVc7QUFDVEEsVUFBSSxHQUFKQTtBQUNBQyxZQUFNLEdBQUdDLEVBQUUsQ0FBQyxHQUFaRCxJQUFXLENBQVhBO0FBRUY7O0FBQUE7QUFMRjtBQVNLOztBQUFBLDZCQUE2QjtBQUNsQyxRQUFNO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFBK0JFLE1BQU0sQ0FBM0M7QUFDQSxTQUFRLEdBQUVDLFFBQVMsS0FBSUMsUUFBUyxHQUFFQyxJQUFJLEdBQUcsTUFBSCxPQUFnQixFQUF0RDtBQUdLOztBQUFBLGtCQUFrQjtBQUN2QixRQUFNO0FBQUE7QUFBQSxNQUFXSCxNQUFNLENBQXZCO0FBQ0EsUUFBTUksTUFBTSxHQUFHQyxpQkFBZjtBQUNBLFNBQU9DLElBQUksQ0FBSkEsVUFBZUYsTUFBTSxDQUE1QixNQUFPRSxDQUFQO0FBR0s7O0FBQUEsbUNBQXdEO0FBQzdELFNBQU8sNENBRUhDLFNBQVMsQ0FBVEEsZUFBeUJBLFNBQVMsQ0FBbENBLFFBRko7QUFLSzs7QUFBQSx3QkFBd0M7QUFDN0MsU0FBT0MsR0FBRyxDQUFIQSxZQUFnQkEsR0FBRyxDQUExQjtBQUdLOztBQUFBLDZDQUlrRDtBQUN2RCxZQUEyQztBQUFBOztBQUN6QywwQkFBSUMsR0FBRyxDQUFQLHNCQUFJQSxlQUFKLGlCQUFvQztBQUNsQyxZQUFNQyxPQUFPLEdBQUksSUFBR0MsY0FBYyxLQUFsQztBQUdBLFlBQU0sVUFBTixPQUFNLENBQU47QUFFSDtBQUNELEdBVHVELENBU3ZEOzs7QUFDQSxRQUFNSCxHQUFHLEdBQUdJLEdBQUcsQ0FBSEEsT0FBWUEsR0FBRyxDQUFIQSxPQUFXQSxHQUFHLENBQUhBLElBQW5DOztBQUVBLE1BQUksQ0FBQ0gsR0FBRyxDQUFSLGlCQUEwQjtBQUN4QixRQUFJRyxHQUFHLENBQUhBLE9BQVdBLEdBQUcsQ0FBbEIsV0FBOEI7QUFDNUI7QUFDQSxhQUFPO0FBQ0xDLGlCQUFTLEVBQUUsTUFBTUMsbUJBQW1CLENBQUNGLEdBQUcsQ0FBSixXQUFnQkEsR0FBRyxDQUR6RCxHQUNzQztBQUQvQixPQUFQO0FBSUY7O0FBQUE7QUFHRjs7QUFBQSxRQUFNRyxLQUFLLEdBQUcsTUFBTU4sR0FBRyxDQUFIQSxnQkFBcEIsR0FBb0JBLENBQXBCOztBQUVBLE1BQUlELEdBQUcsSUFBSVEsU0FBUyxDQUFwQixHQUFvQixDQUFwQixFQUEyQjtBQUN6QjtBQUdGOztBQUFBLE1BQUksQ0FBSixPQUFZO0FBQ1YsVUFBTU4sT0FBTyxHQUFJLElBQUdDLGNBQWMsS0FFaEMsK0RBQThESSxLQUZoRTtBQUdBLFVBQU0sVUFBTixPQUFNLENBQU47QUFHRjs7QUFBQSxZQUEyQztBQUN6QyxRQUFJRSxNQUFNLENBQU5BLDRCQUFtQyxDQUFDTCxHQUFHLENBQTNDLEtBQWlEO0FBQy9DTSxhQUFPLENBQVBBLEtBQ0csR0FBRVAsY0FBYyxLQURuQk87QUFNSDtBQUVEOztBQUFBO0FBR0s7O0FBQUEsTUFBTUMsYUFBYSxHQUFHLHdHQUF0QixTQUFzQixDQUF0Qjs7O0FBZUEsbUNBQXNEO0FBQzNELFlBQTRDO0FBQzFDLFFBQUlDLEdBQUcsS0FBSEEsUUFBZ0IsZUFBcEIsVUFBNkM7QUFDM0NILFlBQU0sQ0FBTkEsa0JBQTBCSSxHQUFELElBQVM7QUFDaEMsWUFBSUYsYUFBYSxDQUFiQSxpQkFBK0IsQ0FBbkMsR0FBdUM7QUFDckNELGlCQUFPLENBQVBBLEtBQ0cscURBQW9ERyxHQUR2REg7QUFJSDtBQU5ERDtBQVFIO0FBRUQ7O0FBQUEsU0FBTywwQkFBUCxHQUFPLENBQVA7QUFHSzs7QUFBQSxNQUFNSyxFQUFFLEdBQUcsdUJBQVg7O0FBQ0EsTUFBTUMsRUFBRSxHQUNiRCxFQUFFLElBQ0YsT0FBT0UsV0FBVyxDQUFsQixTQURBRixjQUVBLE9BQU9FLFdBQVcsQ0FBbEIsWUFISyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3V0aWxzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5jb21pbmdNZXNzYWdlLCBTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJ2h0dHAnXG5pbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHsgZm9ybWF0VXJsIH0gZnJvbSAnLi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybCdcbmltcG9ydCB7IE1hbmlmZXN0SXRlbSB9IGZyb20gJy4uL3NlcnZlci9sb2FkLWNvbXBvbmVudHMnXG5pbXBvcnQgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi9yb3V0ZXIvcm91dGVyJ1xuaW1wb3J0IHsgRW52IH0gZnJvbSAnQG5leHQvZW52J1xuaW1wb3J0IHsgQnVpbGRNYW5pZmVzdCB9IGZyb20gJy4uL3NlcnZlci9nZXQtcGFnZS1maWxlcydcbmltcG9ydCB7IERvbWFpbkxvY2FsZXMgfSBmcm9tICcuLi9zZXJ2ZXIvY29uZmlnJ1xuXG4vKipcbiAqIFR5cGVzIHVzZWQgYnkgYm90aCBuZXh0IGFuZCBuZXh0LXNlcnZlclxuICovXG5cbmV4cG9ydCB0eXBlIE5leHRDb21wb25lbnRUeXBlPFxuICBDIGV4dGVuZHMgQmFzZUNvbnRleHQgPSBOZXh0UGFnZUNvbnRleHQsXG4gIElQID0ge30sXG4gIFAgPSB7fVxuPiA9IENvbXBvbmVudFR5cGU8UD4gJiB7XG4gIC8qKlxuICAgKiBVc2VkIGZvciBpbml0aWFsIHBhZ2UgbG9hZCBkYXRhIHBvcHVsYXRpb24uIERhdGEgcmV0dXJuZWQgZnJvbSBgZ2V0SW5pdGlhbFByb3BzYCBpcyBzZXJpYWxpemVkIHdoZW4gc2VydmVyIHJlbmRlcmVkLlxuICAgKiBNYWtlIHN1cmUgdG8gcmV0dXJuIHBsYWluIGBPYmplY3RgIHdpdGhvdXQgdXNpbmcgYERhdGVgLCBgTWFwYCwgYFNldGAuXG4gICAqIEBwYXJhbSBjdHggQ29udGV4dCBvZiBgcGFnZWBcbiAgICovXG4gIGdldEluaXRpYWxQcm9wcz8oY29udGV4dDogQyk6IElQIHwgUHJvbWlzZTxJUD5cbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRUeXBlID0gTmV4dENvbXBvbmVudFR5cGU8XG4gIERvY3VtZW50Q29udGV4dCxcbiAgRG9jdW1lbnRJbml0aWFsUHJvcHMsXG4gIERvY3VtZW50UHJvcHNcbj4gJiB7XG4gIHJlbmRlckRvY3VtZW50KFxuICAgIERvY3VtZW50OiBEb2N1bWVudFR5cGUsXG4gICAgcHJvcHM6IERvY3VtZW50UHJvcHNcbiAgKTogUmVhY3QuUmVhY3RFbGVtZW50XG59XG5cbmV4cG9ydCB0eXBlIEFwcFR5cGUgPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgQXBwQ29udGV4dFR5cGUsXG4gIEFwcEluaXRpYWxQcm9wcyxcbiAgQXBwUHJvcHNUeXBlXG4+XG5cbmV4cG9ydCB0eXBlIEFwcFRyZWVUeXBlID0gQ29tcG9uZW50VHlwZTxcbiAgQXBwSW5pdGlhbFByb3BzICYgeyBbbmFtZTogc3RyaW5nXTogYW55IH1cbj5cblxuLyoqXG4gKiBXZWIgdml0YWxzIHByb3ZpZGVkIHRvIF9hcHAucmVwb3J0V2ViVml0YWxzIGJ5IENvcmUgV2ViIFZpdGFscyBwbHVnaW4gZGV2ZWxvcGVkIGJ5IEdvb2dsZSBDaHJvbWUgdGVhbS5cbiAqIGh0dHBzOi8vbmV4dGpzLm9yZy9ibG9nL25leHQtOS00I2ludGVncmF0ZWQtd2ViLXZpdGFscy1yZXBvcnRpbmdcbiAqL1xuZXhwb3J0IHR5cGUgTmV4dFdlYlZpdGFsc01ldHJpYyA9IHtcbiAgaWQ6IHN0cmluZ1xuICBsYWJlbDogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICBzdGFydFRpbWU6IG51bWJlclxuICB2YWx1ZTogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIEVuaGFuY2VyPEM+ID0gKENvbXBvbmVudDogQykgPT4gQ1xuXG5leHBvcnQgdHlwZSBDb21wb25lbnRzRW5oYW5jZXIgPVxuICB8IHtcbiAgICAgIGVuaGFuY2VBcHA/OiBFbmhhbmNlcjxBcHBUeXBlPlxuICAgICAgZW5oYW5jZUNvbXBvbmVudD86IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuICAgIH1cbiAgfCBFbmhhbmNlcjxOZXh0Q29tcG9uZW50VHlwZT5cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZVJlc3VsdCA9IHtcbiAgaHRtbDogc3RyaW5nXG4gIGhlYWQ/OiBBcnJheTxKU1guRWxlbWVudCB8IG51bGw+XG59XG5cbmV4cG9ydCB0eXBlIFJlbmRlclBhZ2UgPSAoXG4gIG9wdGlvbnM/OiBDb21wb25lbnRzRW5oYW5jZXJcbikgPT4gUmVuZGVyUGFnZVJlc3VsdCB8IFByb21pc2U8UmVuZGVyUGFnZVJlc3VsdD5cblxuZXhwb3J0IHR5cGUgQmFzZUNvbnRleHQgPSB7XG4gIHJlcz86IFNlcnZlclJlc3BvbnNlXG4gIFtrOiBzdHJpbmddOiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgTkVYVF9EQVRBID0ge1xuICBwcm9wczogUmVjb3JkPHN0cmluZywgYW55PlxuICBwYWdlOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGJ1aWxkSWQ6IHN0cmluZ1xuICBhc3NldFByZWZpeD86IHN0cmluZ1xuICBydW50aW1lQ29uZmlnPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfVxuICBuZXh0RXhwb3J0PzogYm9vbGVhblxuICBhdXRvRXhwb3J0PzogYm9vbGVhblxuICBpc0ZhbGxiYWNrPzogYm9vbGVhblxuICBkeW5hbWljSWRzPzogc3RyaW5nW11cbiAgZXJyPzogRXJyb3IgJiB7IHN0YXR1c0NvZGU/OiBudW1iZXIgfVxuICBnc3A/OiBib29sZWFuXG4gIGdzc3A/OiBib29sZWFuXG4gIGN1c3RvbVNlcnZlcj86IGJvb2xlYW5cbiAgZ2lwPzogYm9vbGVhblxuICBhcHBHaXA/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZ1xuICBsb2NhbGVzPzogc3RyaW5nW11cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICBkb21haW5Mb2NhbGVzPzogRG9tYWluTG9jYWxlc1xuICBzY3JpcHRMb2FkZXI/OiBhbnlbXVxuICBpc1ByZXZpZXc/OiBib29sZWFuXG59XG5cbi8qKlxuICogYE5leHRgIGNvbnRleHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0UGFnZUNvbnRleHQge1xuICAvKipcbiAgICogRXJyb3Igb2JqZWN0IGlmIGVuY291bnRlcmVkIGR1cmluZyByZW5kZXJpbmdcbiAgICovXG4gIGVycj86IChFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9KSB8IG51bGxcbiAgLyoqXG4gICAqIGBIVFRQYCByZXF1ZXN0IG9iamVjdC5cbiAgICovXG4gIHJlcT86IEluY29taW5nTWVzc2FnZVxuICAvKipcbiAgICogYEhUVFBgIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIHJlcz86IFNlcnZlclJlc3BvbnNlXG4gIC8qKlxuICAgKiBQYXRoIHNlY3Rpb24gb2YgYFVSTGAuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nXG4gIC8qKlxuICAgKiBRdWVyeSBzdHJpbmcgc2VjdGlvbiBvZiBgVVJMYCBwYXJzZWQgYXMgYW4gb2JqZWN0LlxuICAgKi9cbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIC8qKlxuICAgKiBgU3RyaW5nYCBvZiB0aGUgYWN0dWFsIHBhdGggaW5jbHVkaW5nIHF1ZXJ5LlxuICAgKi9cbiAgYXNQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBgQ29tcG9uZW50YCB0aGUgdHJlZSBvZiB0aGUgQXBwIHRvIHVzZSBpZiBuZWVkaW5nIHRvIHJlbmRlciBzZXBhcmF0ZWx5XG4gICAqL1xuICBBcHBUcmVlOiBBcHBUcmVlVHlwZVxufVxuXG5leHBvcnQgdHlwZSBBcHBDb250ZXh0VHlwZTxSIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXI+ID0ge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dD5cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbiAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgcm91dGVyOiBSXG59XG5cbmV4cG9ydCB0eXBlIEFwcEluaXRpYWxQcm9wcyA9IHtcbiAgcGFnZVByb3BzOiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgQXBwUHJvcHNUeXBlPFxuICBSIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXIsXG4gIFAgPSB7fVxuPiA9IEFwcEluaXRpYWxQcm9wcyAmIHtcbiAgQ29tcG9uZW50OiBOZXh0Q29tcG9uZW50VHlwZTxOZXh0UGFnZUNvbnRleHQsIGFueSwgUD5cbiAgcm91dGVyOiBSXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50Q29udGV4dCA9IE5leHRQYWdlQ29udGV4dCAmIHtcbiAgcmVuZGVyUGFnZTogUmVuZGVyUGFnZVxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudEluaXRpYWxQcm9wcyA9IFJlbmRlclBhZ2VSZXN1bHQgJiB7XG4gIHN0eWxlcz86IFJlYWN0LlJlYWN0RWxlbWVudFtdIHwgUmVhY3QuUmVhY3RGcmFnbWVudFxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFByb3BzID0gRG9jdW1lbnRJbml0aWFsUHJvcHMgJiB7XG4gIF9fTkVYVF9EQVRBX186IE5FWFRfREFUQVxuICBkYW5nZXJvdXNBc1BhdGg6IHN0cmluZ1xuICBkb2NDb21wb25lbnRzUmVuZGVyZWQ6IHtcbiAgICBIdG1sPzogYm9vbGVhblxuICAgIE1haW4/OiBib29sZWFuXG4gICAgSGVhZD86IGJvb2xlYW5cbiAgICBOZXh0U2NyaXB0PzogYm9vbGVhblxuICB9XG4gIGJ1aWxkTWFuaWZlc3Q6IEJ1aWxkTWFuaWZlc3RcbiAgYW1wUGF0aDogc3RyaW5nXG4gIGluQW1wTW9kZTogYm9vbGVhblxuICBoeWJyaWRBbXA6IGJvb2xlYW5cbiAgaXNEZXZlbG9wbWVudDogYm9vbGVhblxuICBkeW5hbWljSW1wb3J0czogTWFuaWZlc3RJdGVtW11cbiAgYXNzZXRQcmVmaXg/OiBzdHJpbmdcbiAgY2Fub25pY2FsQmFzZTogc3RyaW5nXG4gIGhlYWRUYWdzOiBhbnlbXVxuICB1bnN0YWJsZV9ydW50aW1lSlM/OiBmYWxzZVxuICB1bnN0YWJsZV9Kc1ByZWxvYWQ/OiBmYWxzZVxuICBkZXZPbmx5Q2FjaGVCdXN0ZXJRdWVyeVN0cmluZzogc3RyaW5nXG4gIHNjcmlwdExvYWRlcjogeyBkZWZlcj86IHN0cmluZ1tdOyBlYWdlcj86IGFueVtdIH1cbiAgbG9jYWxlPzogc3RyaW5nXG59XG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dEFwaVJlcXVlc3QgZXh0ZW5kcyBJbmNvbWluZ01lc3NhZ2Uge1xuICAvKipcbiAgICogT2JqZWN0IG9mIGBxdWVyeWAgdmFsdWVzIGZyb20gdXJsXG4gICAqL1xuICBxdWVyeToge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHN0cmluZ1tdXG4gIH1cbiAgLyoqXG4gICAqIE9iamVjdCBvZiBgY29va2llc2AgZnJvbSBoZWFkZXJcbiAgICovXG4gIGNvb2tpZXM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgfVxuXG4gIGJvZHk6IGFueVxuXG4gIGVudjogRW52XG5cbiAgcHJldmlldz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFByZXZpZXcgZGF0YSBzZXQgb24gdGhlIHJlcXVlc3QsIGlmIGFueVxuICAgKiAqL1xuICBwcmV2aWV3RGF0YT86IGFueVxufVxuXG4vKipcbiAqIFNlbmQgYm9keSBvZiByZXNwb25zZVxuICovXG50eXBlIFNlbmQ8VD4gPSAoYm9keTogVCkgPT4gdm9pZFxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgcmVzcG9uc2VcbiAqL1xuZXhwb3J0IHR5cGUgTmV4dEFwaVJlc3BvbnNlPFQgPSBhbnk+ID0gU2VydmVyUmVzcG9uc2UgJiB7XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgYGFueWAgZGF0YSBpbiByZXNwb25zZVxuICAgKi9cbiAgc2VuZDogU2VuZDxUPlxuICAvKipcbiAgICogU2VuZCBkYXRhIGBqc29uYCBkYXRhIGluIHJlc3BvbnNlXG4gICAqL1xuICBqc29uOiBTZW5kPFQ+XG4gIHN0YXR1czogKHN0YXR1c0NvZGU6IG51bWJlcikgPT4gTmV4dEFwaVJlc3BvbnNlPFQ+XG4gIHJlZGlyZWN0KHVybDogc3RyaW5nKTogTmV4dEFwaVJlc3BvbnNlPFQ+XG4gIHJlZGlyZWN0KHN0YXR1czogbnVtYmVyLCB1cmw6IHN0cmluZyk6IE5leHRBcGlSZXNwb25zZTxUPlxuXG4gIC8qKlxuICAgKiBTZXQgcHJldmlldyBkYXRhIGZvciBOZXh0LmpzJyBwcmVyZW5kZXIgbW9kZVxuICAgKi9cbiAgc2V0UHJldmlld0RhdGE6IChcbiAgICBkYXRhOiBvYmplY3QgfCBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHtcbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lmaWVzIHRoZSBudW1iZXIgKGluIHNlY29uZHMpIGZvciB0aGUgcHJldmlldyBzZXNzaW9uIHRvIGxhc3QgZm9yLlxuICAgICAgICogVGhlIGdpdmVuIG51bWJlciB3aWxsIGJlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyIGJ5IHJvdW5kaW5nIGRvd24uXG4gICAgICAgKiBCeSBkZWZhdWx0LCBubyBtYXhpbXVtIGFnZSBpcyBzZXQgYW5kIHRoZSBwcmV2aWV3IHNlc3Npb24gZmluaXNoZXNcbiAgICAgICAqIHdoZW4gdGhlIGNsaWVudCBzaHV0cyBkb3duIChicm93c2VyIGlzIGNsb3NlZCkuXG4gICAgICAgKi9cbiAgICAgIG1heEFnZT86IG51bWJlclxuICAgIH1cbiAgKSA9PiBOZXh0QXBpUmVzcG9uc2U8VD5cbiAgY2xlYXJQcmV2aWV3RGF0YTogKCkgPT4gTmV4dEFwaVJlc3BvbnNlPFQ+XG59XG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSBoYW5kbGVyXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRBcGlIYW5kbGVyPFQgPSBhbnk+ID0gKFxuICByZXE6IE5leHRBcGlSZXF1ZXN0LFxuICByZXM6IE5leHRBcGlSZXNwb25zZTxUPlxuKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPlxuXG4vKipcbiAqIFV0aWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjT25jZTxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBSZXR1cm5UeXBlPFQ+PihcbiAgZm46IFRcbik6IFQge1xuICBsZXQgdXNlZCA9IGZhbHNlXG4gIGxldCByZXN1bHQ6IFJldHVyblR5cGU8VD5cblxuICByZXR1cm4gKCguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgIGlmICghdXNlZCkge1xuICAgICAgdXNlZCA9IHRydWVcbiAgICAgIHJlc3VsdCA9IGZuKC4uLmFyZ3MpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSkgYXMgVFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9jYXRpb25PcmlnaW4oKSB7XG4gIGNvbnN0IHsgcHJvdG9jb2wsIGhvc3RuYW1lLCBwb3J0IH0gPSB3aW5kb3cubG9jYXRpb25cbiAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0bmFtZX0ke3BvcnQgPyAnOicgKyBwb3J0IDogJyd9YFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VVJMKCkge1xuICBjb25zdCB7IGhyZWYgfSA9IHdpbmRvdy5sb2NhdGlvblxuICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG4gIHJldHVybiBocmVmLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWU8UD4oQ29tcG9uZW50OiBDb21wb25lbnRUeXBlPFA+KSB7XG4gIHJldHVybiB0eXBlb2YgQ29tcG9uZW50ID09PSAnc3RyaW5nJ1xuICAgID8gQ29tcG9uZW50XG4gICAgOiBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Jlc1NlbnQocmVzOiBTZXJ2ZXJSZXNwb25zZSkge1xuICByZXR1cm4gcmVzLmZpbmlzaGVkIHx8IHJlcy5oZWFkZXJzU2VudFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZEdldEluaXRpYWxQcm9wczxcbiAgQyBleHRlbmRzIEJhc2VDb250ZXh0LFxuICBJUCA9IHt9LFxuICBQID0ge31cbj4oQXBwOiBOZXh0Q29tcG9uZW50VHlwZTxDLCBJUCwgUD4sIGN0eDogQyk6IFByb21pc2U8SVA+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoQXBwLnByb3RvdHlwZT8uZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShcbiAgICAgICAgQXBwXG4gICAgICApfS5nZXRJbml0aWFsUHJvcHMoKVwiIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIC0gdmlzaXQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZ2V0LWluaXRpYWwtcHJvcHMtYXMtYW4taW5zdGFuY2UtbWV0aG9kIGZvciBtb3JlIGluZm9ybWF0aW9uLmBcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgIH1cbiAgfVxuICAvLyB3aGVuIGNhbGxlZCBmcm9tIF9hcHAgYGN0eGAgaXMgbmVzdGVkIGluIGBjdHhgXG4gIGNvbnN0IHJlcyA9IGN0eC5yZXMgfHwgKGN0eC5jdHggJiYgY3R4LmN0eC5yZXMpXG5cbiAgaWYgKCFBcHAuZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgaWYgKGN0eC5jdHggJiYgY3R4LkNvbXBvbmVudCkge1xuICAgICAgLy8gQHRzLWlnbm9yZSBwYWdlUHJvcHMgZGVmYXVsdFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZVByb3BzOiBhd2FpdCBsb2FkR2V0SW5pdGlhbFByb3BzKGN0eC5Db21wb25lbnQsIGN0eC5jdHgpLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge30gYXMgSVBcbiAgfVxuXG4gIGNvbnN0IHByb3BzID0gYXdhaXQgQXBwLmdldEluaXRpYWxQcm9wcyhjdHgpXG5cbiAgaWYgKHJlcyAmJiBpc1Jlc1NlbnQocmVzKSkge1xuICAgIHJldHVybiBwcm9wc1xuICB9XG5cbiAgaWYgKCFwcm9wcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgXCIke2dldERpc3BsYXlOYW1lKFxuICAgICAgQXBwXG4gICAgKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBzaG91bGQgcmVzb2x2ZSB0byBhbiBvYmplY3QuIEJ1dCBmb3VuZCBcIiR7cHJvcHN9XCIgaW5zdGVhZC5gXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoID09PSAwICYmICFjdHguY3R4KSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGAke2dldERpc3BsYXlOYW1lKFxuICAgICAgICAgIEFwcFxuICAgICAgICApfSByZXR1cm5lZCBhbiBlbXB0eSBvYmplY3QgZnJvbSBcXGBnZXRJbml0aWFsUHJvcHNcXGAuIFRoaXMgZGUtb3B0aW1pemVzIGFuZCBwcmV2ZW50cyBhdXRvbWF0aWMgc3RhdGljIG9wdGltaXphdGlvbi4gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZW1wdHktb2JqZWN0LWdldEluaXRpYWxQcm9wc2BcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvcHNcbn1cblxuZXhwb3J0IGNvbnN0IHVybE9iamVjdEtleXMgPSBbXG4gICdhdXRoJyxcbiAgJ2hhc2gnLFxuICAnaG9zdCcsXG4gICdob3N0bmFtZScsXG4gICdocmVmJyxcbiAgJ3BhdGgnLFxuICAncGF0aG5hbWUnLFxuICAncG9ydCcsXG4gICdwcm90b2NvbCcsXG4gICdxdWVyeScsXG4gICdzZWFyY2gnLFxuICAnc2xhc2hlcycsXG5dXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRXaXRoVmFsaWRhdGlvbih1cmw6IFVybE9iamVjdCk6IHN0cmluZyB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGlmICh1cmwgIT09IG51bGwgJiYgdHlwZW9mIHVybCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKHVybCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmICh1cmxPYmplY3RLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgVW5rbm93biBrZXkgcGFzc2VkIHZpYSB1cmxPYmplY3QgaW50byB1cmwuZm9ybWF0OiAke2tleX1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3JtYXRVcmwodXJsKVxufVxuXG5leHBvcnQgY29uc3QgU1AgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnXG5leHBvcnQgY29uc3QgU1QgPVxuICBTUCAmJlxuICB0eXBlb2YgcGVyZm9ybWFuY2UubWFyayA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSA9PT0gJ2Z1bmN0aW9uJ1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/utils.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/server/denormalize-page-path.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/server/denormalize-page-path.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("exports.__esModule=true;exports.normalizePathSep=normalizePathSep;exports.denormalizePagePath=denormalizePagePath;function normalizePathSep(path){return path.replace(/\\\\/g,'/');}function denormalizePagePath(page){page=normalizePathSep(page);if(page.startsWith('/index/')){page=page.slice(6);}else if(page==='/index'){page='/';}return page;}\n//# sourceMappingURL=denormalize-page-path.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL3NlcnZlci9kZW5vcm1hbGl6ZS1wYWdlLXBhdGguanM/YzI0MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYSx3QkFBd0IsMENBQTBDLGdEQUFnRCxnQ0FBZ0MsZ0NBQWdDLG1DQUFtQyw0QkFBNEIsK0JBQStCLG9CQUFvQix5QkFBeUIsVUFBVTtBQUNwViIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvc2VydmVyL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMubm9ybWFsaXplUGF0aFNlcD1ub3JtYWxpemVQYXRoU2VwO2V4cG9ydHMuZGVub3JtYWxpemVQYWdlUGF0aD1kZW5vcm1hbGl6ZVBhZ2VQYXRoO2Z1bmN0aW9uIG5vcm1hbGl6ZVBhdGhTZXAocGF0aCl7cmV0dXJuIHBhdGgucmVwbGFjZSgvXFxcXC9nLCcvJyk7fWZ1bmN0aW9uIGRlbm9ybWFsaXplUGFnZVBhdGgocGFnZSl7cGFnZT1ub3JtYWxpemVQYXRoU2VwKHBhZ2UpO2lmKHBhZ2Uuc3RhcnRzV2l0aCgnL2luZGV4LycpKXtwYWdlPXBhZ2Uuc2xpY2UoNik7fWVsc2UgaWYocGFnZT09PScvaW5kZXgnKXtwYWdlPScvJzt9cmV0dXJuIHBhZ2U7fVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVub3JtYWxpemUtcGFnZS1wYXRoLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/server/denormalize-page-path.js\n");

/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./dist/client/link */ \"./node_modules/next/dist/client/link.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzPzYwNWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsbUVBQW9CIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvbGluay5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2NsaWVudC9saW5rJylcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/link.js\n");

/***/ }),

/***/ "./pages/projects.jsx":
/*!****************************!*\
  !*** ./pages/projects.jsx ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Projects; });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _layouts_default__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../layouts/default */ \"./layouts/default.jsx\");\n/* harmony import */ var _components_repos__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/repos */ \"./components/repos.jsx\");\n\nvar _jsxFileName = \"/Users/guy/Development/Web/Site/pages/projects.jsx\";\n\n\nfunction Projects(props) {\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_layouts_default__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_components_repos__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 8,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 7,\n    columnNumber: 9\n  }, this);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWdlcy9wcm9qZWN0cy5qc3g/ZGE0YiJdLCJuYW1lcyI6WyJQcm9qZWN0cyIsInByb3BzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBRUE7QUFFZSxTQUFTQSxRQUFULENBQWtCQyxLQUFsQixFQUF5QjtBQUNwQyxzQkFDSSxxRUFBQyx3REFBRDtBQUFBLDJCQUNJLHFFQUFDLHlEQUFEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFESjtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBREo7QUFLSCIsImZpbGUiOiIuL3BhZ2VzL3Byb2plY3RzLmpzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEZWZhdWx0IGZyb20gJy4uL2xheW91dHMvZGVmYXVsdCdcblxuaW1wb3J0IFJlcG9zIGZyb20gJy4uL2NvbXBvbmVudHMvcmVwb3MnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFByb2plY3RzKHByb3BzKSB7XG4gICAgcmV0dXJuKFxuICAgICAgICA8RGVmYXVsdD5cbiAgICAgICAgICAgIDxSZXBvcy8+XG4gICAgICAgIDwvRGVmYXVsdD5cbiAgICApXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/projects.jsx\n");

/***/ }),

/***/ "./styles/default.module.css":
/*!***********************************!*\
  !*** ./styles/default.module.css ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Exports\nmodule.exports = {\n\t\"main\": \"default_main__3nCiq\",\n\t\"left\": \"default_left__1lSUr\",\n\t\"leftGrad\": \"default_leftGrad__3GcSF\",\n\t\"about\": \"default_about__f_hN4\",\n\t\"title\": \"default_title___RY85\",\n\t\"subHeading\": \"default_subHeading__2Rbpq\",\n\t\"links\": \"default_links__2gLIP\",\n\t\"icon\": \"default_icon__3Qq20\",\n\t\"navItem\": \"default_navItem__prefS\",\n\t\"right\": \"default_right__3JKmS\",\n\t\"rightGrad\": \"default_rightGrad__2dqIv\",\n\t\"nav\": \"default_nav__3lzQs\",\n\t\"navLinks\": \"default_navLinks__3_tKg\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZXMvZGVmYXVsdC5tb2R1bGUuY3NzPzZhNjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9zdHlsZXMvZGVmYXVsdC5tb2R1bGUuY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwibWFpblwiOiBcImRlZmF1bHRfbWFpbl9fM25DaXFcIixcblx0XCJsZWZ0XCI6IFwiZGVmYXVsdF9sZWZ0X18xbFNVclwiLFxuXHRcImxlZnRHcmFkXCI6IFwiZGVmYXVsdF9sZWZ0R3JhZF9fM0djU0ZcIixcblx0XCJhYm91dFwiOiBcImRlZmF1bHRfYWJvdXRfX2ZfaE40XCIsXG5cdFwidGl0bGVcIjogXCJkZWZhdWx0X3RpdGxlX19fUlk4NVwiLFxuXHRcInN1YkhlYWRpbmdcIjogXCJkZWZhdWx0X3N1YkhlYWRpbmdfXzJSYnBxXCIsXG5cdFwibGlua3NcIjogXCJkZWZhdWx0X2xpbmtzX18yZ0xJUFwiLFxuXHRcImljb25cIjogXCJkZWZhdWx0X2ljb25fXzNRcTIwXCIsXG5cdFwibmF2SXRlbVwiOiBcImRlZmF1bHRfbmF2SXRlbV9fcHJlZlNcIixcblx0XCJyaWdodFwiOiBcImRlZmF1bHRfcmlnaHRfXzNKS21TXCIsXG5cdFwicmlnaHRHcmFkXCI6IFwiZGVmYXVsdF9yaWdodEdyYWRfXzJkcUl2XCIsXG5cdFwibmF2XCI6IFwiZGVmYXVsdF9uYXZfXzNselFzXCIsXG5cdFwibmF2TGlua3NcIjogXCJkZWZhdWx0X25hdkxpbmtzX18zX3RLZ1wiXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./styles/default.module.css\n");

/***/ }),

/***/ "./styles/repos.module.css":
/*!*********************************!*\
  !*** ./styles/repos.module.css ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Exports\nmodule.exports = {\n\t\"row\": \"repos_row__3eKbQ\",\n\t\"title\": \"repos_title__1QrCM\",\n\t\"subTitle\": \"repos_subTitle__AnL_K\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZXMvcmVwb3MubW9kdWxlLmNzcz84Y2U4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3N0eWxlcy9yZXBvcy5tb2R1bGUuY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwicm93XCI6IFwicmVwb3Nfcm93X18zZUtiUVwiLFxuXHRcInRpdGxlXCI6IFwicmVwb3NfdGl0bGVfXzFRckNNXCIsXG5cdFwic3ViVGl0bGVcIjogXCJyZXBvc19zdWJUaXRsZV9fQW5MX0tcIlxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./styles/repos.module.css\n");

/***/ }),

/***/ "next/head":
/*!****************************!*\
  !*** external "next/head" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"next/head\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJuZXh0L2hlYWRcIj81ZWYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6Im5leHQvaGVhZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5leHQvaGVhZFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///next/head\n");

/***/ }),

/***/ "next/router":
/*!******************************!*\
  !*** external "next/router" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"next/router\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJuZXh0L3JvdXRlclwiP2Q4M2UiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoibmV4dC9yb3V0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXh0L3JvdXRlclwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///next/router\n");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"react\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdFwiPzU4OGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoicmVhY3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWFjdFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///react\n");

/***/ }),

/***/ "react-icons/fa":
/*!*********************************!*\
  !*** external "react-icons/fa" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"react-icons/fa\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdC1pY29ucy9mYVwiP2Q2NmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoicmVhY3QtaWNvbnMvZmEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWFjdC1pY29ucy9mYVwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///react-icons/fa\n");

/***/ }),

/***/ "react-is":
/*!***************************!*\
  !*** external "react-is" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"react-is\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdC1pc1wiPzBkMzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoicmVhY3QtaXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWFjdC1pc1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///react-is\n");

/***/ }),

/***/ "react/jsx-dev-runtime":
/*!****************************************!*\
  !*** external "react/jsx-dev-runtime" ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"react/jsx-dev-runtime\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdC9qc3gtZGV2LXJ1bnRpbWVcIj9jZDkwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6InJlYWN0L2pzeC1kZXYtcnVudGltZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlYWN0L2pzeC1kZXYtcnVudGltZVwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///react/jsx-dev-runtime\n");

/***/ })

/******/ });